from typing import Any, Dict, List, Optional
from uuid import UUID

from fastapi import Depends

# from lib.database import create_session # Will be replaced
from sqlalchemy import delete, desc, select, update  # Added select, delete, update
from sqlalchemy.ext.asyncio import AsyncSession  # Added AsyncSession
from sqlalchemy.orm import Session

from apps.core.lib.database.connection import (
    get_async_db_session,  # Import async session getter
)
from apps.core.models.chat_model import Chat, Message


class ChatRepository:
    def __init__(self, db: AsyncSession):  # Changed to AsyncSession
        self.db = db

    # Chat operations
    async def get_chat(self, chat_id: UUID) -> Optional[Chat]:  # async def
        result = await self.db.execute(select(Chat).filter(Chat.id == chat_id))
        return result.scalars().first()

    async def get_chats(
        self, skip: int = 0, limit: int = 20
    ) -> List[Chat]:  # async def
        result = await self.db.execute(
            select(Chat).order_by(desc(Chat.updated_at)).offset(skip).limit(limit)
        )
        return list(result.scalars().all())

    async def create_chat(self, chat_data: Dict[str, Any]) -> Chat:  # async def
        chat = Chat(**chat_data)
        self.db.add(chat)
        await self.db.commit()  # await commit
        await self.db.refresh(chat)  # await refresh
        return chat

    async def update_chat(
        self, chat_id: UUID, chat_data: Dict[str, Any]
    ) -> Optional[Chat]:  # async def
        # chat = await self.get_chat(chat_id) # Fetch first approach
        # if chat:
        #     for key, value in chat_data.items():
        #         setattr(chat, key, value)
        #     await self.db.commit()
        #     await self.db.refresh(chat)
        # return chat
        # Direct update approach (more efficient for partial updates)
        stmt = update(Chat).where(Chat.id == chat_id).values(**chat_data)
        result = await self.db.execute(stmt)
        if result.rowcount == 0:
            return None
        await self.db.commit()
        return await self.get_chat(
            chat_id
        )  # Re-fetch to get updated model with all fields

    async def delete_chat(self, chat_id: UUID) -> bool:  # async def
        stmt = delete(Chat).where(Chat.id == chat_id)
        result = await self.db.execute(stmt)
        await self.db.commit()
        return result.rowcount > 0

    # Message operations
    async def get_message(self, message_id: UUID) -> Optional[Message]:  # async def
        result = await self.db.execute(select(Message).filter(Message.id == message_id))
        return result.scalars().first()

    async def get_messages_by_chat(  # async def
        self, chat_id: UUID, skip: int = 0, limit: int = 50
    ) -> List[Message]:
        result = await self.db.execute(
            select(Message)
            .filter(Message.chat_id == chat_id)
            .order_by(Message.created_at)
            .offset(skip)
            .limit(limit)
        )
        return list(result.scalars().all())

    async def create_message(
        self, message_data: Dict[str, Any]
    ) -> Message:  # async def
        message = Message(**message_data)
        self.db.add(message)

        # Update the chat's updated_at timestamp
        # The comment "The updated_at will be automatically updated due to onupdate" implies
        # that the database might handle this. If not, an explicit update might be needed.
        # Forcing an update via ORM could be:
        chat = await self.get_chat(message_data["chat_id"])
        if chat:
            # If Chat model has a listener or if there's a DB trigger for updated_at,
            # simply adding the message and committing might be enough.
            # If we need to explicitly mark chat as dirty for ORM to update `updated_at` (if it's ORM-managed):
            # from sqlalchemy.orm.attributes import flag_modified
            # chat.some_field_to_trigger_update = chat.some_field_to_trigger_update # or flag_modified(chat, "updated_at") if it is not autogenerated by DB
            # self.db.add(chat) # Ensure chat is part of the session if it needs an update.
            pass  # Assuming DB onupdate handles Chat.updated_at, or ORM handles it on relationship changes.

        await self.db.commit()  # await commit
        await self.db.refresh(message)  # await refresh
        return message

    async def delete_message(self, message_id: UUID) -> bool:  # async def
        stmt = delete(Message).where(Message.id == message_id)
        result = await self.db.execute(stmt)
        await self.db.commit()
        return result.rowcount > 0


async def get_chat_repository(  # async def
    db: AsyncSession = Depends(get_async_db_session),  # Use get_async_db_session
) -> ChatRepository:
    return ChatRepository(db)
