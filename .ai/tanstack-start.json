[
  {
    "title": "React TanStack Start Start Trellaux Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-trellaux",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Trellaux\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\n.vscode\npublic\nsrc\nassets\ncomponents\ndb\nhooks\nicons\nroutes\n__root.tsx\nboards.$boardId.tsx\nindex.tsx\nstyles\nutils\nclient.tsx\nqueries.ts\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\ntypes.ts\n.gitignore\n.prettierignore\nREADME.md\napp.config.ts\npackage.json\npostcss.config.mjs\ntailwind.config.mjs\ntsconfig.json\ntsx\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools/production'\nimport {\n  HeadContent,\n  Link,\n  Outlet,\n  Scripts,\n  createRootRouteWithContext,\n  useRouterState,\n} from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\nimport * as React from 'react'\nimport { Toaster } from 'react-hot-toast'\nimport type { QueryClient } from '@tanstack/react-query'\nimport { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary'\nimport { IconLink } from '~/components/IconLink'\nimport { NotFound } from '~/components/NotFound'\nimport appCss from '~/styles/app.css?url'\nimport { seo } from '~/utils/seo'\nimport { Loader } from '~/components/Loader'\n\nexport const Route = createRootRouteWithContext<{\n  queryClient: QueryClient\n}>()({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      ...seo({\n        title:\n          'TanStack Start | Type-Safe, Client-First, Full-Stack React Framework',\n        description: `TanStack Start is a type-safe, client-first, full-stack React framework. `,\n      }),\n    ],\n    links: [\n      { rel: 'stylesheet', href: appCss },\n      {\n        rel: 'apple-touch-icon',\n        sizes: '180x180',\n        href: '/apple-touch-icon.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '32x32',\n        href: '/favicon-32x32.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '16x16',\n        href: '/favicon-16x16.png',\n      },\n      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },\n      { rel: 'icon', href: '/favicon.ico' },\n    ],\n  }),\n  errorComponent: (props) => {\n    return (\n      <RootDocument>\n        <DefaultCatchBoundary {...props} />\n      </RootDocument>\n    )\n  },\n  notFoundComponent: () => <NotFound />,\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <div className=\"h-screen flex flex-col min-h-0\">\n          <div className=\"bg-slate-900 border-b border-slate-800 flex items-center justify-between py-4 px-8 box-border\">\n            <div className=\"flex items-center gap-4\">\n              <div>\n                <Link to=\"/\" className=\"block leading-tight\">\n                  <div className=\"font-black text-2xl text-white\">Trellaux</div>\n                  <div className=\"text-slate-500\">a TanStack Demo</div>\n                </Link>\n              </div>\n              <LoadingIndicator />\n            </div>\n            <div className=\"flex items-center gap-6\">\n              {/* <label\n                htmlFor=\"countries\"\n                className=\"block text-sm font-medium text-gray-900 dark:text-white\"\n              >\n                Delay\n              </label>\n              <select\n                className=\"border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500\"\n                onChange={(event) => {\n                  // setExtraDelay(Number(event.currentTarget.value))\n                }}\n                defaultValue=\"0\"\n              >\n                <option value=\"0\">None</option>\n                <option value=\"100\">100</option>\n                <option value=\"500\">500</option>\n                <option value=\"2000\">2000</option>\n              </select> */}\n              <IconLink\n                href=\"https://github.com/TanStack/router/tree/main/examples/react/start-trellaux\"\n                label=\"Source\"\n                icon=\"/github-mark-white.png\"\n              />\n              <IconLink\n                href=\"https://tanstack.com\"\n                icon=\"/tanstack.png\"\n                label=\"TanStack\"\n              />\n            </div>\n          </div>\n\n          <div className=\"flex-grow min-h-0 h-full flex flex-col\">\n            {children}\n            <Toaster />\n          </div>\n        </div>\n        <ReactQueryDevtools />\n        <TanStackRouterDevtools position=\"bottom-right\" />\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nfunction LoadingIndicator() {\n  const isLoading = useRouterState({ select: (s) => s.isLoading })\n  return (\n    <div\n      className={`h-12 transition-all duration-300 ${\n        isLoading ? `opacity-100 delay-300` : `opacity-0 delay-0`\n      }`}\n    >\n      <Loader />\n    </div>\n  )\n}\n\nTrellaux + Convex\nWorkOS\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "React TanStack Start Start Basic Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-basic",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Basic\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\n.vscode\npublic\nsrc\ncomponents\nroutes\n_pathlessLayout\napi\n__root.tsx\n_pathlessLayout.tsx\ndeferred.tsx\nindex.tsx\nposts.$postId.tsx\nposts.index.tsx\nposts.route.tsx\nposts_.$postId.deep.tsx\nredirect.tsx\nusers.$userId.tsx\nusers.index.tsx\nusers.route.tsx\nstyles\nutils\napi.ts\nclient.tsx\nglobal-middleware.ts\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\n.gitignore\n.prettierignore\nREADME.md\napp.config.ts\npackage.json\npostcss.config.mjs\ntailwind.config.mjs\ntsconfig.json\ntsx\nimport {\n  HeadContent,\n  Link,\n  Outlet,\n  Scripts,\n  createRootRoute,\n} from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\nimport * as React from 'react'\nimport { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary'\nimport { NotFound } from '~/components/NotFound'\nimport appCss from '~/styles/app.css?url'\nimport { seo } from '~/utils/seo'\n\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      ...seo({\n        title:\n          'TanStack Start | Type-Safe, Client-First, Full-Stack React Framework',\n        description: `TanStack Start is a type-safe, client-first, full-stack React framework. `,\n      }),\n    ],\n    links: [\n      { rel: 'stylesheet', href: appCss },\n      {\n        rel: 'apple-touch-icon',\n        sizes: '180x180',\n        href: '/apple-touch-icon.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '32x32',\n        href: '/favicon-32x32.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '16x16',\n        href: '/favicon-16x16.png',\n      },\n      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },\n      { rel: 'icon', href: '/favicon.ico' },\n    ],\n  }),\n  errorComponent: (props) => {\n    return (\n      <RootDocument>\n        <DefaultCatchBoundary {...props} />\n      </RootDocument>\n    )\n  },\n  notFoundComponent: () => <NotFound />,\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <div className=\"p-2 flex gap-2 text-lg\">\n          <Link\n            to=\"/\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n            activeOptions={{ exact: true }}\n          >\n            Home\n          </Link>{' '}\n          <Link\n            to=\"/posts\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Posts\n          </Link>{' '}\n          <Link\n            to=\"/users\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Users\n          </Link>{' '}\n          <Link\n            to=\"/route-a\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Pathless Layout\n          </Link>{' '}\n          <Link\n            to=\"/deferred\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Deferred\n          </Link>{' '}\n          <Link\n            // @ts-expect-error\n            to=\"/this-route-does-not-exist\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            This Route Does Not Exist\n          </Link>\n        </div>\n        <hr />\n        {children}\n        <TanStackRouterDevtools position=\"bottom-right\" />\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nPath Aliases\nBasic + React Query\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "React TanStack Start Start Clerk Basic Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-clerk-basic",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Clerk Basic\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\n.vscode\npublic\nsrc\ncomponents\nroutes\n_authed\n__root.tsx\n_authed.tsx\nindex.tsx\nstyles\nutils\nclient.tsx\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\n.env\n.gitignore\n.prettierignore\nREADME.md\napp.config.ts\npackage.json\npostcss.config.mjs\ntailwind.config.mjs\ntsconfig.json\ntsx\n/// <reference types=\"vite/client\" />\nimport {\n  HeadContent,\n  Link,\n  Outlet,\n  Scripts,\n  createRootRoute,\n} from '@tanstack/react-router'\nimport {\n  ClerkProvider,\n  SignInButton,\n  SignedIn,\n  SignedOut,\n  UserButton,\n} from '@clerk/tanstack-react-start'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\nimport { createServerFn } from '@tanstack/react-start'\nimport * as React from 'react'\nimport { getAuth } from '@clerk/tanstack-react-start/server'\nimport { getWebRequest } from '@tanstack/react-start/server'\nimport { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary.js'\nimport { NotFound } from '~/components/NotFound.js'\nimport appCss from '~/styles/app.css?url'\n\nconst fetchClerkAuth = createServerFn({ method: 'GET' }).handler(async () => {\n  const { userId } = await getAuth(getWebRequest()!)\n\n  return {\n    userId,\n  }\n})\n\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n    ],\n    links: [\n      { rel: 'stylesheet', href: appCss },\n      {\n        rel: 'apple-touch-icon',\n        sizes: '180x180',\n        href: '/apple-touch-icon.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '32x32',\n        href: '/favicon-32x32.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '16x16',\n        href: '/favicon-16x16.png',\n      },\n      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },\n      { rel: 'icon', href: '/favicon.ico' },\n    ],\n  }),\n  beforeLoad: async () => {\n    const { userId } = await fetchClerkAuth()\n\n    return {\n      userId,\n    }\n  },\n  errorComponent: (props) => {\n    return (\n      <RootDocument>\n        <DefaultCatchBoundary {...props} />\n      </RootDocument>\n    )\n  },\n  notFoundComponent: () => <NotFound />,\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <ClerkProvider>\n      <RootDocument>\n        <Outlet />\n      </RootDocument>\n    </ClerkProvider>\n  )\n}\n\nfunction RootDocument({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <div className=\"p-2 flex gap-2 text-lg\">\n          <Link\n            to=\"/\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n            activeOptions={{ exact: true }}\n          >\n            Home\n          </Link>{' '}\n          <Link\n            to=\"/posts\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Posts\n          </Link>\n          <div className=\"ml-auto\">\n            <SignedIn>\n              <UserButton />\n            </SignedIn>\n            <SignedOut>\n              <SignInButton mode=\"modal\" />\n            </SignedOut>\n          </div>\n        </div>\n        <hr />\n        {children}\n        <TanStackRouterDevtools position=\"bottom-right\" />\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nBasic + React Query\nBasic + DIY Auth\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "API Routes | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/api-routes",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nAPI Routes\n\nAPI Routes are a powerful feature of TanStack Start that allow you to create server-side endpoints in your application without the need for a separate server. API Routes are useful for handling form submissions, user authentication, and more.\n\nBy default, API Routes are defined in your ./app/routes/api directory of your project and are automatically handled by the TanStack Start server.\n\nðŸ§  This means that by default, your API Routes will be prefixed with /api and will be served from the same server as your application. You can customize this base path by changing the tsr.apiBase in your TanStack Start config.\n\nFile Route Conventions\n\nAPI Routes in TanStack Start, follow the same file-based routing conventions as TanStack Router. This means that each file in your routes directory that is prefixed with api (which can be configured) will be treated as an API route. Here are a few examples:\n\nroutes/api.users.ts will create an API route at /api/users\nroutes/api/users.ts will also create an API route at /api/users\nroutes/api/users.index.ts will also create an API route at /api/users\nroutes/api/users/$id.ts will create an API route at /api/users/$id\nroutes/api/users/$id/posts.ts will create an API route at /api/users/$id/posts\nroutes/api.users.$id.posts.ts will also create an API route at /api/users/$id/posts\nroutes/api/file/$.ts will create an API route at /api/file/$\n\nYour route files that are prefixed with api, can be thought of as the handlers for the given API route path.\n\nIt's important to remember that each route can only have a single handler file associated with it. So, if you have a file named routes/api/users.ts which'd equal the request path of /api/users, you cannot have other files that'd also resolve to the same route, like:\n\nroutes/api/users.index.ts\nroutes/api.users.ts.\nroutes/api.users.index.ts.\n\nâ— One more thing, API Routes do not have the concept of pathless layout routes or parallel routes. So, a file named:\n\nroutes/api/_pathlessLayout/users.ts would resolve to /api/_pathlessLayout/users and NOT /api/users.\nNested Directories vs File-names\n\nIn the examples above, you may have noticed that the file naming conventions are flexible and allow you to mix and match directories and file names. This is intentional and allows you to organize your API Routes in a way that makes sense for your application. You can read more about this in the TanStack Router File-based Routing Guide.\n\nSetting up the entry handler\n\nBefore you can create your API routes, you need to set up the entry handler for your TanStack Start project. This entry handler, similar to client and ssr, handles the API incoming requests and routes them to the appropriate API route handler. The API entry handler is defined in the app/api.ts file in your project.\n\nHere's an example implementation:\n\nts\n// app/api.ts\nimport {\n  createStartAPIHandler,\n  defaultAPIFileRouteHandler,\n} from '@tanstack/react-start/api'\n\nexport default createStartAPIHandler(defaultAPIFileRouteHandler)\n\n\nThis file is responsible for creating the API handler that will be used to route incoming requests to the appropriate API route handler. The defaultAPIFileRouteHandler is a helper function that will automatically load and execute the appropriate API route handler based on the incoming request.\n\nDefining an API Route\n\nAPI Routes export an APIRoute instance by calling the createAPIFileRoute function. Similar to other file-based routes in TanStack Router, the first argument to this function is the path of the route. The function returned is called again with an object that defines the route handlers for each HTTP method.\n\nTip\n\nIf you've already got the dev server running, when you create a new API route, it'll automatically have the initial handler set up for you. From there on, you can customize the handler as needed.\n\nNote\n\nThe export variable must be named APIRoute or the resulting response will be a 404 not found.\n\nts\n// routes/api/hello.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/api/hello')({\n  GET: async ({ request }) => {\n    return new Response('Hello, World! from ' + request.url)\n  },\n})\n\n\nEach HTTP method handler receives an object with the following properties:\n\nrequest: The incoming request object. You can read more about the Request object in the MDN Web Docs.\nparams: An object containing the dynamic path parameters of the route. For example, if the route path is /users/$id, and the request is made to /users/123, then params will be { id: '123' }. We'll cover dynamic path parameters and wildcard parameters later in this guide.\n\nOnce you've processed the request, you need to return a Response object or Promise<Response>. This can be done by creating a new Response object and returning it from the handler. You can read more about the Response object in the MDN Web Docs.\n\nDynamic Path Params\n\nAPI Routes support dynamic path parameters, which are denoted by a $ followed by the parameter name. For example, a file named routes/api/users/$id.ts will create an API route at /api/users/$id that accepts a dynamic id parameter.\n\nts\n// routes/api/users/$id.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/users/$id')({\n  GET: async ({ params }) => {\n    const { id } = params\n    return new Response(`User ID: ${id}`)\n  },\n})\n\n// Visit /api/users/123 to see the response\n// User ID: 123\n\n\nYou can also have multiple dynamic path parameters in a single route. For example, a file named routes/api/users/$id/posts/$postId.ts will create an API route at /api/users/$id/posts/$postId that accepts two dynamic parameters.\n\nts\n// routes/api/users/$id/posts/$postId.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/users/$id/posts/$postId')({\n  GET: async ({ params }) => {\n    const { id, postId } = params\n    return new Response(`User ID: ${id}, Post ID: ${postId}`)\n  },\n})\n\n// Visit /api/users/123/posts/456 to see the response\n// User ID: 123, Post ID: 456\n\nWildcard/Splat Param\n\nAPI Routes also support wildcard parameters at the end of the path, which are denoted by a $ followed by nothing. For example, a file named routes/api/file/$.ts will create an API route at /api/file/$ that accepts a wildcard parameter.\n\nts\n// routes/api/file/$.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/file/$')({\n  GET: async ({ params }) => {\n    const { _splat } = params\n    return new Response(`File: ${_splat}`)\n  },\n})\n\n// Visit /api/file/hello.txt to see the response\n// File: hello.txt\n\nHandling requests with a body\n\nTo handle POST requests,you can add a POST handler to the route object. The handler will receive the request object as the first argument, and you can access the request body using the request.json() method.\n\nts\n// routes/api/hello.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/api/hello')({\n  POST: async ({ request }) => {\n    const body = await request.json()\n    return new Response(`Hello, ${body.name}!`)\n  },\n})\n\n// Send a POST request to /api/hello with a JSON body like { \"name\": \"Tanner\" }\n// Hello, Tanner!\n\n\nThis also applies to other HTTP methods like PUT, PATCH, and DELETE. You can add handlers for these methods in the route object and access the request body using the appropriate method.\n\nIt's important to remember that the request.json() method returns a Promise that resolves to the parsed JSON body of the request. You need to await the result to access the body.\n\nThis is a common pattern for handling POST requests in API Routes. You can also use other methods like request.text() or request.formData() to access the body of the request.\n\nResponding with JSON\n\nWhen returning JSON using a Response object, this is a common pattern:\n\nts\n// routes/api/hello.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/api/hello')({\n  GET: async ({ request }) => {\n    return new Response(JSON.stringify({ message: 'Hello, World!' }), {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n  },\n})\n\n// Visit /api/hello to see the response\n// {\"message\":\"Hello, World!\"}\n\nUsing the json helper function\n\nOr you can use the json helper function to automatically set the Content-Type header to application/json and serialize the JSON object for you.\n\nts\n// routes/api/hello.ts\nimport { json } from '@tanstack/react-start'\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/api/hello')({\n  GET: async ({ request }) => {\n    return json({ message: 'Hello, World!' })\n  },\n})\n\n// Visit /api/hello to see the response\n// {\"message\":\"Hello, World!\"}\n\nResponding with a status code\n\nYou can set the status code of the response by either:\n\nPassing it as a property of the second argument to the Response constructor\n\nts\n// routes/api/hello.ts\nimport { json } from '@tanstack/react-start'\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/users/$id')({\n  GET: async ({ request, params }) => {\n    const user = await findUser(params.id)\n    if (!user) {\n      return new Response('User not found', {\n        status: 404,\n      })\n    }\n    return json(user)\n  },\n})\n\n\nUsing the setResponseStatus helper function from @tanstack/react-start/server\n\nts\n// routes/api/hello.ts\nimport { json } from '@tanstack/react-start'\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\nimport { setResponseStatus } from '@tanstack/react-start/server'\n\nexport const APIRoute = createAPIFileRoute('/users/$id')({\n  GET: async ({ request, params }) => {\n    const user = await findUser(params.id)\n    if (!user) {\n      setResponseStatus(404)\n      return new Response('User not found')\n    }\n    return json(user)\n  },\n})\n\n\nIn this example, we're returning a 404 status code if the user is not found. You can set any valid HTTP status code using this method.\n\nSetting headers in the response\n\nSometimes you may need to set headers in the response. You can do this by either:\n\nPassing an object as the second argument to the Response constructor.\n\nts\n// routes/api/hello.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\n\nexport const APIRoute = createAPIFileRoute('/api/hello')({\n  GET: async ({ request }) => {\n    return new Response('Hello, World!', {\n      headers: {\n        'Content-Type': 'text/plain',\n      },\n    })\n  },\n})\n\n// Visit /api/hello to see the response\n// Hello, World!\n\n\nOr using the setHeaders helper function from @tanstack/react-start/server.\n\nts\n// routes/api/hello.ts\nimport { createAPIFileRoute } from '@tanstack/react-start/api'\nimport { setHeaders } from '@tanstack/react-start/server'\n\nexport const APIRoute = createAPIFileRoute('/api/hello')({\n  GET: async ({ request }) => {\n    setHeaders({\n      'Content-Type': 'text/plain',\n    })\n    return new Response('Hello, World!')\n  },\n})\n\nEdit on GitHub\nMiddleware\nSSR\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "React TanStack Start Start Workos Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-workos",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Workos\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\nsrc\nauthkit\ncomponents\nroutes\n_authenticated\napi\n__root.tsx\n_authenticated.tsx\nindex.tsx\nlogout.tsx\napi.ts\nclient.tsx\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\n.env.example\n.gitignore\nREADME.md\napp.config.ts\npackage.json\nprettier.config.js\ntsconfig.json\ntsx\nimport { Box, Button, Card, Container, Flex, Theme } from '@radix-ui/themes';\nimport '@radix-ui/themes/styles.css';\nimport { HeadContent, Link, Outlet, Scripts, createRootRoute } from '@tanstack/react-router';\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools';\nimport { Suspense } from 'react';\nimport { getAuth, getSignInUrl } from '../authkit/serverFunctions';\nimport Footer from '../components/footer';\nimport SignInButton from '../components/sign-in-button';\nimport type { ReactNode } from 'react';\n\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      {\n        title: 'AuthKit Example in TanStack Start',\n      },\n    ],\n  }),\n  beforeLoad: async () => {\n    const { user } = await getAuth();\n\n    return { user };\n  },\n  loader: async ({ context }) => {\n    const { user } = context;\n    const url = await getSignInUrl();\n    return {\n      user,\n      url,\n    };\n  },\n  component: RootComponent,\n  notFoundComponent: () => <div>Not Found</div>,\n});\n\nfunction RootComponent() {\n  const { user, url } = Route.useLoaderData();\n  return (\n    <RootDocument>\n      <Theme accentColor=\"iris\" panelBackground=\"solid\" style={{ backgroundColor: 'var(--gray-1)' }}>\n        <Container style={{ backgroundColor: 'var(--gray-1)' }}>\n          <Flex direction=\"column\" gap=\"5\" p=\"5\" height=\"100vh\">\n            <Box asChild flexGrow=\"1\">\n              <Card size=\"4\">\n                <Flex direction=\"column\" height=\"100%\">\n                  <Flex asChild justify=\"between\">\n                    <header>\n                      <Flex gap=\"4\">\n                        <Button asChild variant=\"soft\">\n                          <Link to=\"/\">Home</Link>\n                        </Button>\n\n                        <Button asChild variant=\"soft\">\n                          <Link to=\"/account\">Account</Link>\n                        </Button>\n                      </Flex>\n\n                      <Suspense fallback={<div>Loading...</div>}>\n                        <SignInButton user={user} url={url} />\n                      </Suspense>\n                    </header>\n                  </Flex>\n\n                  <Flex flexGrow=\"1\" align=\"center\" justify=\"center\">\n                    <main>\n                      <Outlet />\n                    </main>\n                  </Flex>\n                </Flex>\n              </Card>\n            </Box>\n            <Footer />\n          </Flex>\n        </Container>\n      </Theme>\n      <TanStackRouterDevtools position=\"bottom-right\" />\n    </RootDocument>\n  );\n}\n\nfunction RootDocument({ children }: Readonly<{ children: ReactNode }>) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        {children}\n        <Scripts />\n      </body>\n    </html>\n  );\n}\n\nTrellaux\nMaterial UI\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "React TanStack Start Start Supabase Basic Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-supabase-basic",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Supabase Basic\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\n.vscode\nsrc\ncomponents\nhooks\nroutes\n_authed\n__root.tsx\n_authed.tsx\nindex.tsx\nlogin.tsx\nlogout.tsx\nsignup.tsx\nstyles\nutils\nclient.tsx\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\n.env\n.gitignore\n.prettierignore\napp.config.ts\npackage.json\npostcss.config.mjs\ntailwind.config.mjs\ntsconfig.json\ntsx\nimport {\n  HeadContent,\n  Link,\n  Outlet,\n  Scripts,\n  createRootRoute,\n} from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\nimport { createServerFn } from '@tanstack/react-start'\nimport * as React from 'react'\nimport { DefaultCatchBoundary } from '../components/DefaultCatchBoundary'\nimport { NotFound } from '../components/NotFound'\nimport appCss from '../styles/app.css?url'\nimport { seo } from '../utils/seo'\nimport { getSupabaseServerClient } from '../utils/supabase'\n\nconst fetchUser = createServerFn({ method: 'GET' }).handler(async () => {\n  const supabase = await getSupabaseServerClient()\n  const { data, error: _error } = await supabase.auth.getUser()\n\n  if (!data.user?.email) {\n    return null\n  }\n\n  return {\n    email: data.user.email,\n  }\n})\n\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      ...seo({\n        title:\n          'TanStack Start | Type-Safe, Client-First, Full-Stack React Framework',\n        description: `TanStack Start is a type-safe, client-first, full-stack React framework. `,\n      }),\n    ],\n    links: [\n      { rel: 'stylesheet', href: appCss },\n      {\n        rel: 'apple-touch-icon',\n        sizes: '180x180',\n        href: '/apple-touch-icon.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '32x32',\n        href: '/favicon-32x32.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '16x16',\n        href: '/favicon-16x16.png',\n      },\n      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },\n      { rel: 'icon', href: '/favicon.ico' },\n    ],\n  }),\n  beforeLoad: async () => {\n    const user = await fetchUser()\n\n    return {\n      user,\n    }\n  },\n  errorComponent: (props) => {\n    return (\n      <RootDocument>\n        <DefaultCatchBoundary {...props} />\n      </RootDocument>\n    )\n  },\n  notFoundComponent: () => <NotFound />,\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: { children: React.ReactNode }) {\n  const { user } = Route.useRouteContext()\n\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <div className=\"p-2 flex gap-2 text-lg\">\n          <Link\n            to=\"/\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n            activeOptions={{ exact: true }}\n          >\n            Home\n          </Link>{' '}\n          <Link\n            to=\"/posts\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Posts\n          </Link>\n          <div className=\"ml-auto\">\n            {user ? (\n              <>\n                <span className=\"mr-2\">{user.email}</span>\n                <Link to=\"/logout\">Logout</Link>\n              </>\n            ) : (\n              <Link to=\"/login\">Login</Link>\n            )}\n          </div>\n        </div>\n        <hr />\n        {children}\n        <TanStackRouterDevtools position=\"bottom-right\" />\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nBasic + DIY Auth\nTrellaux + Convex\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "React TanStack Start Start Basic React Query Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-basic-react-query",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Basic React Query\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\n.vscode\npublic\nsrc\ncomponents\nroutes\n_pathlessLayout\napi\n__root.tsx\n_pathlessLayout.tsx\napi.users.ts\ndeferred.tsx\nindex.tsx\nposts.$postId.tsx\nposts.index.tsx\nposts.route.tsx\nposts_.$postId.deep.tsx\nredirect.tsx\nusers.$userId.tsx\nusers.index.tsx\nusers.route.tsx\nstyles\nutils\napi.ts\nclient.tsx\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\n.gitignore\n.prettierignore\nREADME.md\napp.config.ts\npackage.json\npostcss.config.mjs\ntailwind.config.mjs\ntsconfig.json\ntsx\nimport {\n  HeadContent,\n  Link,\n  Outlet,\n  Scripts,\n  createRootRouteWithContext,\n} from '@tanstack/react-router'\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\nimport * as React from 'react'\nimport type { QueryClient } from '@tanstack/react-query'\nimport { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary'\nimport { NotFound } from '~/components/NotFound'\nimport appCss from '~/styles/app.css?url'\nimport { seo } from '~/utils/seo'\n\nexport const Route = createRootRouteWithContext<{\n  queryClient: QueryClient\n}>()({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      ...seo({\n        title:\n          'TanStack Start | Type-Safe, Client-First, Full-Stack React Framework',\n        description: `TanStack Start is a type-safe, client-first, full-stack React framework. `,\n      }),\n    ],\n    links: [\n      { rel: 'stylesheet', href: appCss },\n      {\n        rel: 'apple-touch-icon',\n        sizes: '180x180',\n        href: '/apple-touch-icon.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '32x32',\n        href: '/favicon-32x32.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '16x16',\n        href: '/favicon-16x16.png',\n      },\n      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },\n      { rel: 'icon', href: '/favicon.ico' },\n    ],\n  }),\n  errorComponent: (props) => {\n    return (\n      <RootDocument>\n        <DefaultCatchBoundary {...props} />\n      </RootDocument>\n    )\n  },\n  notFoundComponent: () => <NotFound />,\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <div className=\"p-2 flex gap-2 text-lg\">\n          <Link\n            to=\"/\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n            activeOptions={{ exact: true }}\n          >\n            Home\n          </Link>{' '}\n          <Link\n            to=\"/posts\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Posts\n          </Link>{' '}\n          <Link\n            to=\"/users\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Users\n          </Link>{' '}\n          <Link\n            to=\"/route-a\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Pathless Layout\n          </Link>{' '}\n          <Link\n            to=\"/deferred\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            Deferred\n          </Link>{' '}\n          <Link\n            // @ts-expect-error\n            to=\"/this-route-does-not-exist\"\n            activeProps={{\n              className: 'font-bold',\n            }}\n          >\n            This Route Does Not Exist\n          </Link>\n        </div>\n        <hr />\n        {children}\n        <TanStackRouterDevtools position=\"bottom-right\" />\n        <ReactQueryDevtools buttonPosition=\"bottom-left\" />\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nBasic\nBasic + Clerk Auth\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "SSR | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/ssr",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nSSR\n\nServer-side rendering (SSR) is the process of rendering your application on the server and sending or streaming the rendered HTML to the client. This can be useful for both improving the performance of your application and improving SEO, as it allows users to see the content of your application faster and allows search engines to crawl your application more easily.\n\nSSR Basics\n\nTanStack Start supports server-side rendering out of the box. To enable server-side rendering, create an app/ssr.tsx file in your project:\n\ntsx\n// app/ssr.tsx\n\nimport {\n  createStartHandler,\n  defaultStreamHandler,\n} from '@tanstack/react-start/server'\nimport { getRouterManifest } from '@tanstack/react-start/router-manifest'\n\nimport { createRouter } from './router'\n\nexport default createStartHandler({\n  createRouter,\n  getRouterManifest,\n})(defaultStreamHandler)\n\n\nThis file exports a function that creates a server-side rendering handler. The handler is created using the createStartHandler function from @tanstack/react-start/server, which takes an object with the following properties:\n\ncreateRouter: A function that creates a router for your application. This function should return a new router instance each time it is called.\ngetRouterManifest: A function that returns a manifest of all the routes in your application.\n\nThe handler is then called with the defaultStreamHandler function from @tanstack/react-start/server, which is a function that streams the response to the client.\n\nEdit on GitHub\nAPI Routes\nHosting\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Server Functions | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/server-functions",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nServer Functions\nWhat are Server Functions?\n\nServer functions allow you to specify logic that can be invoked almost anywhere (even the client), but run only on the server. In fact, they are not so different from an API Route, but with a few key differences:\n\nThey do not have stable public URL\nThey can be called from anywhere in your application, including loaders, hooks, components, etc., but cannot be called from API Routes.\n\nHowever, they are similar to regular API Routes in that:\n\nThey have access to the request context, allowing you to read headers, set cookies, and more\nThey can access sensitive information, such as environment variables, without exposing them to the client\nThey can be used to perform any kind of server-side logic, such as fetching data from a database, sending emails, or interacting with other services\nThey can return any value, including primitives, JSON-serializable objects, and even raw Response objects\nThey can throw errors, including redirects and notFounds, which can be handled automatically by the router\n\nHow are server functions different from \"React Server Functions\"?\n\nTanStack Server Functions are not tied to a specific front-end framework, and can be used with any front-end framework or none at all.\nTanStack Server Functions are backed by standard HTTP requests and can be called as often as you like without suffering from serial-execution bottlenecks.\nHow do they work?\n\nServer functions can be defined anywhere in your application, but must be defined at the top level of a file. They can be called throughout your application, including loaders, hooks, etc. Traditionally, this pattern is known as a Remote Procedure Call (RPC), but due to the isomorphic nature of these functions, we refer to them as server functions.\n\nOn the server bundle, server functions logic is left alone. Nothing needs to be done since they are already in the correct place.\nOn the client, server functions will be removed; they exist only on the server. Any calls to the server function on the client will be replaced with a fetch request to the server to execute the server function, and send the response back to the client.\nServer Function Middleware\n\nServer functions can use middleware to share logic, context, common operations, prerequisites, and much more. To learn more about server function middleware, be sure to read about them in the Middleware guide.\n\nDefining Server Functions\n\nWe'd like to thank the tRPC team for both the inspiration of TanStack Start's server function design and guidance while implementing it. We love (and recommend) using tRPC for API Routes so much that we insisted on server functions getting the same 1st class treatment and developer experience. Thank you!\n\nServer functions are defined with the createServerFn function, from the @tanstack/react-start package. This function takes an optional options argument for specifying configuration like the HTTP method and response type, and allows you to chain off the result to define things like the body of the server function, input validation, middleware, etc. Here's a simple example:\n\ntsx\n// getServerTime.ts\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const getServerTime = createServerFn().handler(async () => {\n  // Wait for 1 second\n  await new Promise((resolve) => setTimeout(resolve, 1000))\n  // Return the current time\n  return new Date().toISOString()\n})\n\nConfiguration Options\n\nWhen creating a server function, you can provide configuration options to customize its behavior:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const getData = createServerFn({\n  method: 'GET', // HTTP method to use\n  response: 'data', // Response handling mode\n}).handler(async () => {\n  // Function implementation\n})\n\nAvailable Options\n\nmethod\n\nSpecifies the HTTP method for the server function request:\n\ntsx\nmethod?: 'GET' | 'POST'\n\n\nBy default, server functions use GET if not specified.\n\nresponse\n\nControls how responses are processed and returned:\n\ntsx\nresponse?: 'data' | 'full' | 'raw'\n\n'data' (default): Automatically parses JSON responses and returns just the data\n'full': Returns a response object with result data, error information, and context\n'raw': Returns the raw Response object directly, enabling streaming responses and custom headers\nWhere can I call server functions?\nFrom server-side code\nFrom client-side code\nFrom other server functions\n\nWarning\n\nServer functions cannot be called from API Routes. If you need to share business logic between server functions and API Routes, extract the shared logic into utility functions that can be imported by both.\n\nAccepting Parameters\n\nServer functions accept a single parameter, which can be a variety of types:\n\nStandard JavaScript types\nstring\nnumber\nboolean\nnull\nArray\nObject\nFormData\nReadableStream (of any of the above)\nPromise (of any of the above)\n\nHere's an example of a server function that accepts a simple string parameter:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const greet = createServerFn({\n  method: 'GET',\n})\n  .validator((data: string) => data)\n  .handler(async (ctx) => {\n    return `Hello, ${ctx.data}!`\n  })\n\ngreet({\n  data: 'John',\n})\n\nRuntime Input Validation / Type Safety\n\nServer functions can be configured to validate their input data at runtime, while adding type safety. This is useful for ensuring the input is of the correct type before executing the server function, and providing more friendly error messages.\n\nThis is done with the validator method. It will accept whatever input is passed to the server function. The value (and type) you return from this function will become the input passed to the actual server function handler.\n\nValidators also integrate seamlessly with external validators, if you want to use something like Zod.\n\nBasic Validation\n\nHere's a simple example of a server function that validates the input parameter:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\ntype Person = {\n  name: string\n}\n\nexport const greet = createServerFn({ method: 'GET' })\n  .validator((person: unknown): Person => {\n    if (typeof person !== 'object' || person === null) {\n      throw new Error('Person must be an object')\n    }\n\n    if ('name' in person && typeof person.name !== 'string') {\n      throw new Error('Person.name must be a string')\n    }\n\n    return person as Person\n  })\n  .handler(async ({ data }) => {\n    return `Hello, ${data.name}!`\n  })\n\nUsing a Validation Library\n\nValidation libraries like Zod can be used like so:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nimport { z } from 'zod'\n\nconst Person = z.object({\n  name: z.string(),\n})\n\nexport const greet = createServerFn({ method: 'GET' })\n  .validator((person: unknown) => {\n    return Person.parse(person)\n  })\n  .handler(async (ctx) => {\n    return `Hello, ${ctx.data.name}!`\n  })\n\ngreet({\n  data: {\n    name: 'John',\n  },\n})\n\nType Safety\n\nSince server-functions cross the network boundary, it's important to ensure the data being passed to them is not only the right type, but also validated at runtime. This is especially important when dealing with user input, as it can be unpredictable. To ensure developers validate their I/O data, types are reliant on validation. The return type of the validator function will be the input to the server function's handler.\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\ntype Person = {\n  name: string\n}\n\nexport const greet = createServerFn({ method: 'GET' })\n  .validator((person: unknown): Person => {\n    if (typeof person !== 'object' || person === null) {\n      throw new Error('Person must be an object')\n    }\n\n    if ('name' in person && typeof person.name !== 'string') {\n      throw new Error('Person.name must be a string')\n    }\n\n    return person as Person\n  })\n  .handler(\n    async ({\n      data, // Person\n    }) => {\n      return `Hello, ${data.name}!`\n    },\n  )\n\nfunction test() {\n  greet({ data: { name: 'John' } }) // OK\n  greet({ data: { name: 123 } }) // Error: Argument of type '{ name: number; }' is not assignable to parameter of type 'Person'.\n}\n\nInference\n\nServer functions infer their input, and output types based on the input to the validator, and return value of handler functions, respectively. In fact, the validator you define can even have its own separate input/output types, which can be useful if your validator performs transformations on the input data.\n\nTo illustrate this, let's take a look at an example using the zod validation library:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { z } from 'zod'\n\nconst transactionSchema = z.object({\n  amount: z.string().transform((val) => parseInt(val, 10)),\n})\n\nconst createTransaction = createServerFn()\n  .validator(transactionSchema)\n  .handler(({ data }) => {\n    return data.amount // Returns a number\n  })\n\ncreateTransaction({\n  data: {\n    amount: '123', // Accepts a string\n  },\n})\n\nNon-Validated Inference\n\nWhile we highly recommend using a validation library to validate your network I/O data, you may, for whatever reason not want to validate your data, but still have type safety. To do this, provide type information to the server function using an identity function as the validator, that types the input, and or output to the correct types:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\ntype Person = {\n  name: string\n}\n\nexport const greet = createServerFn({ method: 'GET' })\n  .validator((d: Person) => d)\n  .handler(async (ctx) => {\n    return `Hello, ${ctx.data.name}!`\n  })\n\ngreet({\n  data: {\n    name: 'John',\n  },\n})\n\nJSON Parameters\n\nServer functions can accept JSON-serializable objects as parameters. This is useful for passing complex data structures to the server:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\ntype Person = {\n  name: string\n  age: number\n}\n\nexport const greet = createServerFn({ method: 'GET' })\n  .validator((data: Person) => data)\n  .handler(async ({ data }) => {\n    return `Hello, ${data.name}! You are ${data.age} years old.`\n  })\n\ngreet({\n  data: {\n    name: 'John',\n    age: 34,\n  },\n})\n\nFormData Parameters\n\nServer functions can accept FormData objects as parameters\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const greetUser = createServerFn({ method: 'POST' })\n  .validator((data) => {\n    if (!(data instanceof FormData)) {\n      throw new Error('Invalid form data')\n    }\n    const name = data.get('name')\n    const age = data.get('age')\n\n    if (!name || !age) {\n      throw new Error('Name and age are required')\n    }\n\n    return {\n      name: name.toString(),\n      age: parseInt(age.toString(), 10),\n    }\n  })\n  .handler(async ({ data: { name, age } }) => {\n    return `Hello, ${name}! You are ${age} years old.`\n  })\n\n// Usage\nfunction Test() {\n  return (\n    <form\n      onSubmit={async (event) => {\n        event.preventDefault()\n        const formData = new FormData(event.currentTarget)\n        const response = await greetUser({ data: formData })\n        console.log(response)\n      }}\n    >\n      <input name=\"name\" />\n      <input name=\"age\" />\n      <button type=\"submit\">Submit</button>\n    </form>\n  )\n}\n\nServer Function Context\n\nIn addition to the single parameter that server functions accept, you can also access server request context from within any server function using utilities from @tanstack/react-start/server. Under the hood, we use Unjs's h3 package to perform cross-platform HTTP requests.\n\nThere are many context functions available to you for things like:\n\nAccessing the request context\nAccessing/setting headers\nAccessing/setting sessions/cookies\nSetting response status codes and status messages\nDealing with multi-part form data\nReading/Setting custom server context properties\n\nFor a full list of available context functions, see all of the available h3 Methods or inspect the @tanstack/start-server-core Source Code.\n\nFor starters, here are a few examples:\n\nAccessing the Request Context\n\nLet's use the getWebRequest function to access the request itself from within a server function:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { getWebRequest } from '@tanstack/react-start/server'\n\nexport const getServerTime = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    const request = getWebRequest()\n\n    console.log(request.method) // GET\n\n    console.log(request.headers.get('User-Agent')) // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\n  },\n)\n\nAccessing Headers\n\nUse the getHeaders function to access all headers from within a server function:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { getHeaders } from '@tanstack/react-start/server'\n\nexport const getServerTime = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    console.log(getHeaders())\n    // {\n    //   \"accept\": \"*/*\",\n    //   \"accept-encoding\": \"gzip, deflate, br\",\n    //   \"accept-language\": \"en-US,en;q=0.9\",\n    //   \"connection\": \"keep-alive\",\n    //   \"host\": \"localhost:3000\",\n    //   ...\n    // }\n  },\n)\n\n\nYou can also access individual headers using the getHeader function:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { getHeader } from '@tanstack/react-start/server'\n\nexport const getServerTime = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    console.log(getHeader('User-Agent')) // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3\n  },\n)\n\nReturning Values\n\nServer functions can return a few different types of values:\n\nPrimitives\nJSON-serializable objects\nredirect errors (can also be thrown)\nnotFound errors (can also be thrown)\nRaw Response objects\nReturning Primitives and JSON\n\nTo return any primitive or JSON-serializable object, simply return the value from the server function:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const getServerTime = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    return new Date().toISOString()\n  },\n)\n\nexport const getServerData = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    return {\n      message: 'Hello, World!',\n    }\n  },\n)\n\n\nBy default, server functions assume that any non-Response object returned is either a primitive or JSON-serializable object.\n\nResponding with Custom Headers\n\nTo respond with custom headers, you can use the setHeader function:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { setHeader } from '@tanstack/react-start/server'\n\nexport const getServerTime = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    setHeader('X-Custom-Header', 'value')\n    return new Date().toISOString()\n  },\n)\n\nResponding with Custom Status Codes\n\nTo respond with a custom status code, you can use the setResponseStatus function:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { setResponseStatus } from '@tanstack/react-start/server'\n\nexport const getServerTime = createServerFn({ method: 'GET' }).handler(\n  async () => {\n    setResponseStatus(201)\n    return new Date().toISOString()\n  },\n)\n\nReturning Raw Response objects\n\nTo return a raw Response object, return a Response object from the server function and set response: 'raw':\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const getServerTime = createServerFn({\n  method: 'GET',\n  response: 'raw',\n}).handler(async () => {\n  // Read a file from s3\n  return fetch('https://example.com/time.txt')\n})\n\n\nThe response: 'raw' option also allows for streaming responses among other things:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const streamEvents = createServerFn({\n  method: 'GET',\n  response: 'raw',\n}).handler(async ({ signal }) => {\n  // Create a ReadableStream to send chunks of data\n  const stream = new ReadableStream({\n    async start(controller) {\n      // Send initial response immediately\n      controller.enqueue(new TextEncoder().encode('Connection established\\n'))\n\n      let count = 0\n      const interval = setInterval(() => {\n        // Check if the client disconnected\n        if (signal.aborted) {\n          clearInterval(interval)\n          controller.close()\n          return\n        }\n\n        // Send a data chunk\n        controller.enqueue(\n          new TextEncoder().encode(\n            `Event ${++count}: ${new Date().toISOString()}\\n`,\n          ),\n        )\n\n        // End after 10 events\n        if (count >= 10) {\n          clearInterval(interval)\n          controller.close()\n        }\n      }, 1000)\n\n      // Ensure we clean up if the request is aborted\n      signal.addEventListener('abort', () => {\n        clearInterval(interval)\n        controller.close()\n      })\n    },\n  })\n\n  // Return a streaming response\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      Connection: 'keep-alive',\n    },\n  })\n})\n\n\nThe response: 'raw' option is particularly useful for:\n\nStreaming APIs where data is sent incrementally\nServer-sent events\nLong-polling responses\nCustom content types and binary data\nThrowing Errors\n\nAside from special redirect and notFound errors, server functions can throw any custom error. These errors will be serialized and sent to the client as a JSON response along with a 500 status code.\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const doStuff = createServerFn({ method: 'GET' }).handler(async () => {\n  throw new Error('Something went wrong!')\n})\n\n// Usage\nfunction Test() {\n  try {\n    await doStuff()\n  } catch (error) {\n    console.error(error)\n    // {\n    //   message: \"Something went wrong!\",\n    //   stack: \"Error: Something went wrong!\\n    at doStuff (file:///path/to/file.ts:3:3)\"\n    // }\n  }\n}\n\nCancellation\n\nOn the client, server function calls can be cancelled via an AbortSignal. On the server, an AbortSignal will notify if the request closed before execution finished.\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const abortableServerFn = createServerFn().handler(\n  async ({ signal }) => {\n    return new Promise<string>((resolve, reject) => {\n      if (signal.aborted) {\n        return reject(new Error('Aborted before start'))\n      }\n      const timerId = setTimeout(() => {\n        console.log('server function finished')\n        resolve('server function result')\n      }, 1000)\n      const onAbort = () => {\n        clearTimeout(timerId)\n        console.log('server function aborted')\n        reject(new Error('Aborted'))\n      }\n      signal.addEventListener('abort', onAbort, { once: true })\n    })\n  },\n)\n\n// Usage\nfunction Test() {\n  const controller = new AbortController()\n  const serverFnPromise = abortableServerFn({\n    signal: controller.signal,\n  })\n  await new Promise((resolve) => setTimeout(resolve, 500))\n  controller.abort()\n  try {\n    const serverFnResult = await serverFnPromise\n    console.log(serverFnResult) // should never get here\n  } catch (error) {\n    console.error(error) // \"signal is aborted without reason\"\n  }\n}\n\nCalling server functions from within route lifecycles\n\nServer functions can be called normally from route loaders, beforeLoads, or any other router-controlled APIs. These APIs are equipped to handle errors, redirects, and notFounds thrown by server functions automatically.\n\ntsx\nimport { getServerTime } from './getServerTime'\n\nexport const Route = createFileRoute('/time')({\n  loader: async () => {\n    const time = await getServerTime()\n\n    return {\n      time,\n    }\n  },\n})\n\nCalling server functions from hooks and components\n\nServer functions can throw redirects or notFounds and while not required, it is recommended to catch these errors and handle them appropriately. To make this easier, the @tanstack/react-start package exports a useServerFn hook that can be used to bind server functions to components and hooks:\n\ntsx\nimport { useServerFn } from '@tanstack/react-start'\nimport { useQuery } from '@tanstack/react-query'\nimport { getServerTime } from './getServerTime'\n\nexport function Time() {\n  const getTime = useServerFn(getServerTime)\n\n  const timeQuery = useQuery({\n    queryKey: 'time',\n    queryFn: () => getTime(),\n  })\n}\n\nCalling server functions anywhere else\n\nWhen using server functions, be aware that redirects and notFounds they throw will only be handled automatically when called from:\n\nRoute lifecycles\nComponents using the useServerFn hook\n\nFor other usage locations, you'll need to handle these cases manually.\n\nRedirects\n\nServer functions can throw a redirect error to redirect the user to a different URL. This is useful for handling authentication, authorization, or other scenarios where you need to redirect the user to a different page.\n\nDuring SSR, redirects are handled by sending a 302 response to the client with the new location\nOn the client, redirects are handled by the router automatically from within a route lifecycle or a component that uses the useServerFn hook. If you call a server function from anywhere else, redirects will not be handled automatically.\n\nTo throw a redirect, you can use the redirect function exported from the @tanstack/react-router package:\n\ntsx\nimport { redirect } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const doStuff = createServerFn({ method: 'GET' }).handler(async () => {\n  // Redirect the user to the home page\n  throw redirect({\n    to: '/',\n  })\n})\n\n\nRedirects can utilize all of the same options as router.navigate, useNavigate() and <Link> components. So feel free to also pass:\n\nPath Params\nSearch Params\nHash\n\nRedirects can also set the status code of the response by passing a status option:\n\ntsx\nimport { redirect } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const doStuff = createServerFn({ method: 'GET' }).handler(async () => {\n  // Redirect the user to the home page with a 301 status code\n  throw redirect({\n    to: '/',\n    status: 301,\n  })\n})\n\n\nYou can also redirect to an external target using href:\n\ntsx\nimport { redirect } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const auth = createServerFn({ method: 'GET' }).handler(async () => {\n  // Redirect the user to the auth provider\n  throw redirect({\n    href: 'https://authprovider.com/login',\n  })\n})\n\n\nâš ï¸ Do not use @tanstack/react-start/server's sendRedirect function to send soft redirects from within server functions. This will send the redirect using the Location header and will force a full page hard navigation on the client.\n\nRedirect Headers\n\nYou can also set custom headers on a redirect by passing a headers option:\n\ntsx\nimport { redirect } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const doStuff = createServerFn({ method: 'GET' }).handler(async () => {\n  // Redirect the user to the home page with a custom header\n  throw redirect({\n    to: '/',\n    headers: {\n      'X-Custom-Header': 'value',\n    },\n  })\n})\n\nNot Found\n\nWhile calling a server function from a loader or beforeLoad route lifecycle, a special notFound error can be thrown to indicate to the router that the requested resource was not found. This is more useful than a simple 404 status code, as it allows you to render a custom 404 page, or handle the error in a custom way. If notFound is thrown from a server function used outside of a route lifecycle, it will not be handled automatically.\n\nTo throw a notFound, you can use the notFound function exported from the @tanstack/react-router package:\n\ntsx\nimport { notFound } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nconst getStuff = createServerFn({ method: 'GET' }).handler(async () => {\n  // Randomly return a not found error\n  if (Math.random() < 0.5) {\n    throw notFound()\n  }\n\n  // Or return some stuff\n  return {\n    stuff: 'stuff',\n  }\n})\n\nexport const Route = createFileRoute('/stuff')({\n  loader: async () => {\n    const stuff = await getStuff()\n\n    return {\n      stuff,\n    }\n  },\n})\n\n\nNot found errors are a core feature of TanStack Router,\n\nHandling Errors\n\nIf a server function throws a (non-redirect/non-notFound) error, it will be serialized and sent to the client as a JSON response along with a 500 status code. This is useful for debugging, but you may want to handle these errors in a more user-friendly way. You can do this by catching the error and handling it in your route lifecycle, component, or hook as you normally would.\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nexport const doStuff = createServerFn({ method: 'GET' }).handler(async () => {\n  undefined.foo()\n})\n\nexport const Route = createFileRoute('/stuff')({\n  loader: async () => {\n    try {\n      await doStuff()\n    } catch (error) {\n      // Handle the error:\n      // error === {\n      //   message: \"Cannot read property 'foo' of undefined\",\n      //   stack: \"TypeError: Cannot read property 'foo' of undefined\\n    at doStuff (file:///path/to/file.ts:3:3)\"\n    }\n  },\n})\n\nNo-JS Server Functions\n\nWithout JavaScript enabled, there's only one way to execute server functions: by submitting a form.\n\nThis is done by adding a form element to the page with the HTML attribute action.\n\nNotice that we mentioned the HTML attribute action. This attribute only accepts a string in HTML, just like all other attributes.\n\nWhile React 19 added support for passing a function to action, it's a React-specific feature and not part of the HTML standard.\n\nThe action attribute tells the browser where to send the form data when the form is submitted. In this case, we want to send the form data to the server function.\n\nTo do this, we can utilize the url property of the server function:\n\nts\nconst yourFn = createServerFn({ method: 'POST' })\n  .validator((formData) => {\n    if (!(formData instanceof FormData)) {\n      throw new Error('Invalid form data')\n    }\n\n    const name = formData.get('name')\n\n    if (!name) {\n      throw new Error('Name is required')\n    }\n\n    return name\n  })\n  .handler(async ({ data: name }) => {\n    console.log(name) // 'John'\n  })\n\nconsole.info(yourFn.url)\n\n\nAnd pass this to the action attribute of the form:\n\ntsx\nfunction Component() {\n  return (\n    <form action={yourFn.url} method=\"POST\">\n      <input name=\"name\" defaultValue=\"John\" />\n      <button type=\"submit\">Click me!</button>\n    </form>\n  )\n}\n\n\nWhen the form is submitted, the server function will be executed.\n\nNo-JS Server Function Arguments\n\nTo pass arguments to a server function when submitting a form, you can use the input element with the name attribute to attach the argument to the FormData passed to your server function:\n\ntsx\nconst yourFn = createServerFn({ method: 'POST' })\n  .validator((formData) => {\n    if (!(formData instanceof FormData)) {\n      throw new Error('Invalid form data')\n    }\n\n    const age = formData.get('age')\n\n    if (!age) {\n      throw new Error('age is required')\n    }\n\n    return age.toString()\n  })\n  .handler(async ({ data: formData }) => {\n    // `age` will be '123'\n    const age = formData.get('age')\n    // ...\n  })\n\nfunction Component() {\n  return (\n    //  We need to tell the server that our data type is `multipart/form-data` by setting the `encType` attribute on the form.\n    <form action={yourFn.url} method=\"POST\" encType=\"multipart/form-data\">\n      <input name=\"age\" defaultValue=\"34\" />\n      <button type=\"submit\">Click me!</button>\n    </form>\n  )\n}\n\n\nWhen the form is submitted, the server function will be executed with the form's data as an argument.\n\nNo-JS Server Function Return Value\n\nRegardless of whether JavaScript is enabled, the server function will return a response to the HTTP request made from the client.\n\nWhen JavaScript is enabled, this response can be accessed as the return value of the server function in the client's JavaScript code.\n\nts\nconst yourFn = createServerFn().handler(async () => {\n  return 'Hello, world!'\n})\n\n// `.then` is not available when JavaScript is disabled\nyourFn().then(console.log)\n\n\nHowever, when JavaScript is disabled, there is no way to access the return value of the server function in the client's JavaScript code.\n\nInstead, the server function can provide a response to the client, telling the browser to navigate in a certain way.\n\nWhen combined with a loader from TanStack Router, we're able to provide an experience similar to a single-page application, even when JavaScript is disabled; all by telling the browser to reload the current page with new data piped through the loader:\n\ntsx\nimport * as fs from 'fs'\nimport { createFileRoute } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nconst filePath = 'count.txt'\n\nasync function readCount() {\n  return parseInt(\n    await fs.promises.readFile(filePath, 'utf-8').catch(() => '0'),\n  )\n}\n\nconst getCount = createServerFn({\n  method: 'GET',\n}).handler(() => {\n  return readCount()\n})\n\nconst updateCount = createServerFn({ method: 'POST' })\n  .validator((formData) => {\n    if (!(formData instanceof FormData)) {\n      throw new Error('Invalid form data')\n    }\n\n    const addBy = formData.get('addBy')\n\n    if (!addBy) {\n      throw new Error('addBy is required')\n    }\n\n    return parseInt(addBy.toString())\n  })\n  .handler(async ({ data: addByAmount }) => {\n    const count = await readCount()\n    await fs.promises.writeFile(filePath, `${count + addByAmount}`)\n    // Reload the page to trigger the loader again\n    return new Response('ok', { status: 301, headers: { Location: '/' } })\n  })\n\nexport const Route = createFileRoute('/')({\n  component: Home,\n  loader: async () => await getCount(),\n})\n\nfunction Home() {\n  const state = Route.useLoaderData()\n\n  return (\n    <div>\n      <form\n        action={updateCount.url}\n        method=\"POST\"\n        encType=\"multipart/form-data\"\n      >\n        <input type=\"number\" name=\"addBy\" defaultValue=\"1\" />\n        <button type=\"submit\">Add</button>\n      </form>\n      <pre>{state}</pre>\n    </div>\n  )\n}\n\nStatic Server Functions\n\nWhen using prerendering/static-generation, server functions can also be \"static\", which enables their results to be cached at build time and served as static assets.\n\nLearn all about this pattern on the Static Server Functions page.\n\nHow are server functions compiled?\n\nUnder the hood, server functions are extracted out of the client bundle and into a separate server bundle. On the server, they are executed as-is, and the result is sent back to the client. On the client, server functions proxy the request to the server, which executes the function and sends the result back to the client, all via fetch.\n\nThe process looks like this:\n\nWhen createServerFn is found in a file, the inner function is checked for a use server directive\nIf the use server directive is missing, it is added to the top of the function\nOn the client, the inner function is extracted out of the client bundle and into a separate server bundle\nThe client-side server function is replaced with a proxy function that sends a request to the server to execute the function that was extracted\nOn the server, the server function is not extracted, and is executed as-is\nAfter extraction occurs, each bundle applies a dead-code elimination process to remove any unused code from each bundle.\nEdit on GitHub\nLearn the Basics\nStatic Server Functions\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "React TanStack Start Start Convex Trellaux Example | TanStack Start Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/examples/start-convex-trellaux",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nReact Example: Start Convex Trellaux\nGithub\nStackBlitz\nCodeSandbox\nCode Explorer\nInteractive Sandbox\n.vscode\nconvex\npublic\nsrc\ncomponents\ndb\nhooks\nicons\nroutes\n__root.tsx\nboards.$boardId.tsx\nindex.tsx\nstyles\nutils\nclient.tsx\nqueries.ts\nrouteTree.gen.ts\nrouter.tsx\nssr.tsx\ntypes.ts\n.env.local.example\n.gitignore\n.prettierignore\n.stackblitzrc\nREADME.md\napp.config.ts\npackage.json\npostcss.config.mjs\ntailwind.config.mjs\ntsconfig.json\ntsx\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools/production'\nimport {\n  Link,\n  Outlet,\n  createRootRouteWithContext,\n  useRouterState,\n  HeadContent,\n  Scripts,\n} from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\nimport * as React from 'react'\nimport { Toaster } from 'react-hot-toast'\nimport type { QueryClient } from '@tanstack/react-query'\nimport { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary'\nimport { IconLink } from '~/components/IconLink'\nimport { NotFound } from '~/components/NotFound'\nimport appCss from '~/styles/app.css?url'\nimport { seo } from '~/utils/seo'\nimport { Loader } from '~/components/Loader'\n\nexport const Route = createRootRouteWithContext<{\n  queryClient: QueryClient\n}>()({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      ...seo({\n        title:\n          'TanStack Start | Type-Safe, Client-First, Full-Stack React Framework',\n        description: `TanStack Start is a type-safe, client-first, full-stack React framework. `,\n      }),\n    ],\n    links: [\n      { rel: 'stylesheet', href: appCss },\n      {\n        rel: 'apple-touch-icon',\n        sizes: '180x180',\n        href: '/apple-touch-icon.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '32x32',\n        href: '/favicon-32x32.png',\n      },\n      {\n        rel: 'icon',\n        type: 'image/png',\n        sizes: '16x16',\n        href: '/favicon-16x16.png',\n      },\n      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },\n      { rel: 'icon', href: '/favicon.ico' },\n    ],\n  }),\n  errorComponent: (props) => {\n    return (\n      <RootDocument>\n        <DefaultCatchBoundary {...props} />\n      </RootDocument>\n    )\n  },\n  notFoundComponent: () => <NotFound />,\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <div className=\"h-screen flex flex-col min-h-0\">\n          <div className=\"bg-slate-900 border-b border-slate-800 flex items-center justify-between py-4 px-8 box-border\">\n            <div className=\"flex items-center gap-4\">\n              <div>\n                <Link to=\"/\" className=\"block leading-tight\">\n                  <div className=\"font-black text-2xl text-white\">Trellaux</div>\n                  <div className=\"text-slate-500\">a TanStack Demo</div>\n                </Link>\n              </div>\n              <LoadingIndicator />\n            </div>\n            <div className=\"flex items-center gap-6\">\n              {/* <label\n                htmlFor=\"countries\"\n                className=\"block text-sm font-medium text-gray-900 dark:text-white\"\n              >\n                Delay\n              </label>\n              <select\n                className=\"border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500\"\n                onChange={(event) => {\n                  // setExtraDelay(Number(event.currentTarget.value))\n                }}\n                defaultValue=\"0\"\n              >\n                <option value=\"0\">None</option>\n                <option value=\"100\">100</option>\n                <option value=\"500\">500</option>\n                <option value=\"2000\">2000</option>\n              </select> */}\n              <IconLink\n                href=\"https://github.com/TanStack/router/tree/main/examples/react/start-trellaux\"\n                label=\"Source\"\n                icon=\"/github-mark-white.png\"\n              />\n              <IconLink\n                href=\"https://tanstack.com\"\n                icon=\"/tanstack.png\"\n                label=\"TanStack\"\n              />\n            </div>\n          </div>\n\n          <div className=\"flex-grow min-h-0 h-full flex flex-col\">\n            {children}\n            <Toaster />\n          </div>\n        </div>\n        <ReactQueryDevtools />\n        <TanStackRouterDevtools position=\"bottom-right\" />\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nfunction LoadingIndicator() {\n  const isLoading = useRouterState({ select: (s) => s.isLoading })\n  return (\n    <div\n      className={`h-12 transition-all duration-300 ${\n        isLoading ? `opacity-100 delay-300` : `opacity-0 delay-0`\n      }`}\n    >\n      <Loader />\n    </div>\n  )\n}\n\nBasic + Supabase Auth\nTrellaux\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Path Aliases | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/path-aliases",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nPath Aliases\n\nPath aliases are a useful feature of TypeScript that allows you to define a shortcut for a path that could be distant in your project's directory structure. This can help you avoid long relative imports in your code and make it easier to refactor your project's structure. This is especially useful for avoiding long relative imports in your code.\n\nBy default, TanStack Start does not include path aliases. However, you can easily add them to your project by updating your tsconfig.json file in the root of your project and adding the following configuration:\n\njson\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"~/*\": [\"./src/*\"]\n    }\n  }\n}\n\n\nIn this example, we've defined the path alias ~/* that maps to the ./src/* directory. This means that you can now import files from the src directory using the ~ prefix.\n\nAfter updating your tsconfig.json file, you'll need to install the vite-tsconfig-paths plugin to enable path aliases in your TanStack Start project. You can do this by running the following command:\n\nsh\nnpm install -D vite-tsconfig-paths\n\n\nNow, you'll need to update your app.config.ts file to include the following:\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\nimport viteTsConfigPaths from 'vite-tsconfig-paths'\n\nexport default defineConfig({\n  vite: {\n    plugins: [\n      // this is the plugin that enables path aliases\n      viteTsConfigPaths({\n        projects: ['./tsconfig.json'],\n      }),\n    ],\n  },\n})\n\n\nOnce this configuration has completed, you'll now be able to import files using the path alias like so:\n\nts\n// app/routes/posts/$postId/edit.tsx\nimport { Input } from '~/components/ui/input'\n\n// instead of\n\nimport { Input } from '../../../components/ui/input'\n\nEdit on GitHub\nStatic Prerendering\nBasic\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Static Prerendering | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/static-prerendering",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nStatic Prerendering\n\nStatic Prerendering is a feature of Nitro, and while it is available in TanStack Start, we are still exploring the best practices for using it. Tread lightly!\n\nStatic prerendering is the process of generating static HTML files for your application. This can be useful for either improving the performance of your application, as it allows you to serve pre-rendered HTML files to users without having to generate them on the fly or for deploying static sites to platforms that do not support server-side rendering.\n\nPrerendering, powered by Nitro\n\nTanStack Start is built on Nitro, which means we can take advantage of Nitro's prerendering capabilities. Nitro can prerender your application to static HTML files, which can then be served to users without having to generate them on the fly. To prerender your application, you can add the server.prerender option to your app.config.js file:\n\njs\n// app.config.js\n\nimport { defineConfig } from '@tanstack/react-start/config'\n\nexport default defineConfig({\n  server: {\n    prerender: {\n      routes: ['/'],\n      crawlLinks: true,\n    },\n  },\n})\n\n\nMany of the options available for prerendering are documented in the Nitro config prerender documentation.\n\nPrerendering dynamic routes with Nitro\n\nNitro ships with some prebuilt hooks that let you customize the prerendering process among other things. One of these hooks is the prerender:routes hook. This hook allows you to fetch async data and add routes to a Set of routes to be prerendered.\n\nFor this example, let's pretend we have a blog with a list of posts. We want to prerender each post page. Our post route looks like /posts/$postId. We can use the prerender:routes hook to fetch the all of our posts and add each post path to the routes set.\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\n\nexport default defineConfig({\n  server: {\n    hooks: {\n      'prerender:routes': async (routes) => {\n        // fetch the pages you want to render\n        const posts = await fetch('https://api.example.com/posts')\n        const postsData = await posts.json()\n\n        // add each post path to the routes set\n        postsData.forEach((post) => {\n          routes.add(`/posts/${post.id}`)\n        })\n      },\n    },\n    prerender: {\n      routes: ['/'],\n      crawlLinks: true,\n    },\n  },\n})\n\n\nAs of writing, the Nitro hooks documentation does not include any information on the provided hooks.\n\nEdit on GitHub\nOn this page\nPrerendering, powered by Nitro\nPrerendering dynamic routes with Nitro\nObservability\nPath Aliases\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Observability | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/observability",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nObservability\n\nObservability is a critical aspect of modern web development, enabling you to monitor, trace, and debug your applicationâ€™s performance and errors. TanStack Start integrates seamlessly with observability tools to provide comprehensive insights into how your application behaves in production, helping you ensure that everything runs smoothly.\n\nWhat should I use?\n\nTanStack Start is designed to work with any observability tool, so you can integrate your preferred solution using the full-stack APIs provided by TanStack Start. Whether you need logging, tracing, or error monitoring, TanStack Start is flexible enough to meet your observability needs.\n\nHowever, for the best observability experience, we highly recommend using Sentry. Sentry is a powerful, full-featured observability platform that provides real-time insights into your application's performance and error tracking.\n\nWhat is Sentry?\n\nSentry is a leading observability platform that helps developers monitor and fix crashes in real-time. With Sentry, you can track errors, performance issues, and trends across your entire stack, from the frontend to the backend. Sentry integrates seamlessly with TanStack Start, enabling you to identify and resolve issues faster, maintain a high level of performance, and deliver a better experience to your users.\n\nSentryâ€™s comprehensive dashboards, alerting capabilities, and in-depth error analysis tools make it an invaluable resource for any development team looking to maintain control over their applicationâ€™s health in production.\n\nTo learn more about Sentry, visit the Sentry website\nTo sign up, visit the Sentry dashboard\nDocumentation & APIs\n\nDocumentation for integrating different observability tools with TanStack Start is coming soon! Stay tuned for more examples and guides on how to use Sentry effectively with your TanStack Start projects.\n\nEdit on GitHub\nOn this page\nWhat should I use?\nWhat is Sentry?\nDocumentation & APIs\nDatabases\nStatic Prerendering\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Databases | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/databases",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nDatabases\n\nDatabases are at the core of any dynamic application, providing the necessary infrastructure to store, retrieve, and manage data. TanStack Start makes it easy to integrate with a variety of databases, offering a flexible approach to managing your application's data layer.\n\nWhat should I use?\n\nTanStack Start is designed to work with any database provider, so if you already have a preferred database system, you can integrate it with TanStack Start using the provided full-stack APIs. Whether you're working with SQL, NoSQL, or other types of databases, TanStack Start can handle your needs.\n\nHow simple is it to use a database with TanStack Start?\n\nUsing a database with TanStack Start is as simple as calling into your database's adapter/client/driver/service from a TanStack Start server function or server route.\n\nHere's an abstract example of how you might connect with a database and read/write to it:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\n\nconst db = createMyDatabaseClient()\n\nexport const getUser = createServerFn(async ({ ctx }) => {\n  const user = await db.getUser(ctx.userId)\n  return user\n})\n\nexport const createUser = createServerFn(async ({ ctx, input }) => {\n  const user = await db.createUser(input)\n  return user\n})\n\n\nThis is obviously contrived, but it demonstrates that you can use literally any database provider with TanStack Start as long as you can call into it from a server function or server route.\n\nRecommended Database Providers\n\nWhile TanStack Start is designed to work with any database provider, we highly recommend considering one of our vetted partner database providers Neon or Convex. They have been vetted by TanStack to match our quality, openness, and performance standards and are both excellent choices for your database needs.\n\nWhat is Neon?\n\nNeon is a fully managed serverless PostgreSQL with a generous free tier. It separates storage and compute to offer autoscaling, branching, and bottomless storage. With Neon, you get all the power and reliability of PostgreSQL combined with modern cloud capabilities, making it perfect for TanStack Start applications.\n\nKey features that make Neon stand out:\n\nServerless PostgreSQL that scales automatically\nDatabase branching for development and testing\nBuilt-in connection pooling\nPoint-in-time restore\nWeb-based SQL editor\nBottomless storage\n\n\nTo learn more about Neon, visit the Neon website\nTo sign up, visit the Neon dashboard\nWhat is Convex?\n\nConvex is a powerful, serverless database platform that simplifies the process of managing your application's data. With Convex, you can build full-stack applications without the need to manually manage database servers or write complex queries. Convex provides a real-time, scalable, and transactional data backend that seamlessly integrates with TanStack Start, making it an excellent choice for modern web applications.\n\nConvex's declarative data model and automatic conflict resolution ensure that your application remains consistent and responsive, even at scale. It's designed to be developer-friendly, with a focus on simplicity and productivity.\n\nTo learn more about Convex, visit the Convex website\nTo sign up, visit the Convex dashboard\nDocumentation & APIs\n\nDocumentation for integrating different databases with TanStack Start is coming soon! In the meantime, keep an eye on our examples and guide to learn how to fully leverage your data layer across your TanStack Start application.\n\nEdit on GitHub\nOn this page\nWhat should I use?\nHow simple is it to use a database with TanStack Start?\nRecommended Database Providers\nWhat is Neon?\nWhat is Convex?\nDocumentation & APIs\nAuthentication\nObservability\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Hosting | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/hosting",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nHosting\n\nHosting is the process of deploying your application to the internet so that users can access it. This is a critical part of any web development project, ensuring your application is available to the world. TanStack Start is built on Nitro, a powerful server toolkit for deploying web applications anywhere. Nitro allows TanStack Start to provide a unified API for SSR, streaming, and hydration on any hosting provider.\n\nWhat should I use?\n\nTanStack Start is designed to work with any hosting provider, so if you already have a hosting provider in mind, you can deploy your application there using the full-stack APIs provided by TanStack Start.\n\nHowever, since hosting is one of the most crucial aspects of your application's performance, reliability, and scalability, we highly recommend using our Official Hosting Partner Netlify.\n\nWhat is Netlify?\n\nNetlify is a leading hosting platform that provides a fast, secure, and reliable environment for deploying your web applications. With Netlify, you can deploy your TanStack Start application in just a few clicks and benefit from features like a global edge network, automatic scaling, and seamless integrations with GitHub and GitLab. Netlify is designed to make your development process as smooth as possible, from local development to production deployment.\n\nTo learn more about Netlify, visit the Netlify website\nTo sign up, visit the Netlify dashboard\nDeployment\n\nWarning\n\nThe page is still a work in progress. We'll keep updating this page with guides on deployment to different hosting providers soon!\n\nWhen a TanStack Start application is being deployed, the server.preset value in the app.config.ts file determines the deployment target. The deployment target can be set to one of the following values:\n\nnetlify: Deploy to Netlify\nvercel: Deploy to Vercel\ncloudflare-pages: Deploy to Cloudflare Pages\nnode-server: Deploy to a Node.js server\nbun: Deploy to a Bun server\n... and more to come!\n\nOnce you've chosen a deployment target, you can follow the deployment guidelines below to deploy your TanStack Start application to the hosting provider of your choice.\n\nNetlify\n\nSet the server.preset value to netlify in your app.config.ts file.\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\n\nexport default defineConfig({\n  server: {\n    preset: 'netlify',\n  },\n})\n\n\nOr you can use the --preset flag with the build command to specify the deployment target when building the application:\n\nsh\nnpm run build --preset netlify\n\n\nDeploy your application to Netlify using their one-click deployment process, and you're ready to go!\n\nVercel\n\nDeploying your TanStack Start application to Vercel is easy and straightforward. Just set the server.preset value to vercel in your app.config.ts file, and you're ready to deploy your application to Vercel.\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\n\nexport default defineConfig({\n  server: {\n    preset: 'vercel',\n  },\n})\n\n\nOr you can use the --preset flag with the build command to specify the deployment target when building the application:\n\nsh\nnpm run build --preset vercel\n\n\nDeploy your application to Vercel using their one-click deployment process, and you're ready to go!\n\nCloudflare Pages\n\nWhen deploying to Cloudflare Pages, you'll need to complete a few extra steps before your users can start using your app.\n\nInstallation\n\nFirst you will need to install unenv\n\nsh\nnpm install unenv\n\nUpdate app.config.ts\n\nSet the server.preset value to cloudflare-pages and the server.unenv value to the cloudflare from unenv in your app.config.ts file.\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\nimport { cloudflare } from 'unenv'\n\nexport default defineConfig({\n  server: {\n    preset: 'cloudflare-pages',\n    unenv: cloudflare,\n  },\n})\n\nAdd a wrangler.toml config file\ntoml\n# wrangler.toml\nname = \"your-cloudflare-project-name\"\npages_build_output_dir = \"./dist\"\ncompatibility_flags = [\"nodejs_compat\"]\ncompatibility_date = \"2024-11-13\"\n\n\nDeploy your application to Cloudflare Pages using their one-click deployment process, and you're ready to go!\n\nNode.js\n\nSet the server.preset value to node-server in your app.config.ts file.\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\n\nexport default defineConfig({\n  server: {\n    preset: 'node-server',\n  },\n})\n\n// Or you can use the --preset flag with the build command\n// to specify the deployment target when building the application:\n// npm run build --preset node-server\n\n\nThen you can run the following command to build and start your application:\n\nsh\nnpm run build\n\n\nYou're now ready to deploy your application to a Node.js server. You can start your application by running:\n\nsh\nnode .output/server/index.mjs\n\nBun\n\nImportant\n\nCurrently, the Bun specific deployment guidelines only work with React 19. If you are using React 18, please refer to the Node.js deployment guidelines.\n\nMake sure that your react and react-dom packages are set to version 19.0.0 or higher in your package.json file. If not, run the following command to upgrade the packages:\n\nsh\nnpm install react@rc react-dom@rc\n\n\nSet the server.preset value to bun in your app.config.ts file.\n\nts\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\n\nexport default defineConfig({\n  server: {\n    preset: 'bun',\n  },\n})\n\n// Or you can use the --preset flag with the build command\n// to specify the deployment target when building the application:\n// npm run build --preset bun\n\n\nThen you can run the following command to build and start your application:\n\nsh\nbun run build\n\n\nYou're now ready to deploy your application to a Bun server. You can start your application by running:\n\nsh\nbun run .output/server/index.mjs\n\nEdit on GitHub\nOn this page\nWhat should I use?\nWhat is Netlify?\nDeployment\nNetlify\nVercel\nCloudflare Pages\nNode.js\nBun\nSSR\nAuthentication\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Authentication | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/authentication",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nAuthentication\n\nAuthentication is the process of verifying the identity of a user. This is a critical part of any application that requires users to log in or access protected resources. TanStack Start provides the necessary full-stack APIs to implement authentication in your application.\n\nWhat should I use?\n\nTanStack Start is designed to work with any authentication provider, so if you already have an authentication provider or strategy in mind, you can use either find an existing example or implement your own authentication logic using the full-stack APIs provided by TanStack Start.\n\nThat said, authentication is not something to be taken lightly. After much vetting, usage and reviewing on our end, we highly recommend using Clerk for the best possible authentication experience. Clerk provides a full suite of authentication APIs and UI components that make it easy to implement authentication in your application and provide a seamless user experience.\n\nWhat is Clerk?\n\nClerk is a modern authentication platform that provides a full suite of authentication APIs and UI components to help you implement authentication in your application. Clerk is designed to be easy to use and provides a seamless user experience. With Clerk, you can implement authentication in your application in minutes and provide your users with a secure and reliable authentication experience.\n\nTo learn more about Clerk, visit the Clerk website\nTo sign up, visit the Clerk dashboard\nTo get started with Clerk, check out our official Start + Clerk examples!\nDocumentation & APIs\n\nDocumentation for implementing your own authentication logic with TanStack Start is coming soon! In the meantime, you can check out any of the -auth prefixed examples for a starting point.\n\nEdit on GitHub\nOn this page\nWhat should I use?\nWhat is Clerk?\nDocumentation & APIs\nHosting\nDatabases\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Middleware | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/middleware",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nMiddleware\nWhat is Server Function Middleware?\n\nMiddleware allows you to customize the behavior of server functions created with createServerFn with things like shared validation, context, and much more. Middleware can even depend on other middleware to create a chain of operations that are executed hierarchically and in order.\n\nWhat kinds of things can I do with Middleware in my Server Functions?\nAuthentication: Verify a user's identity before executing a server function.\nAuthorization: Check if a user has the necessary permissions to execute a server function.\nLogging: Log requests, responses, and errors.\nObservability: Collect metrics, traces, and logs.\nProvide Context: Attach data to the request object for use in other middleware or server functions.\nError Handling: Handle errors in a consistent way.\nAnd many more! The possibilities are up to you!\nDefining Middleware for Server Functions\n\nMiddleware is defined using the createMiddleware function. This function returns a Middleware object that can be used to continue customizing the middleware with methods like middleware, validator, server, and client.\n\ntsx\nimport { createMiddleware } from '@tanstack/react-start'\n\nconst loggingMiddleware = createMiddleware().server(async ({ next, data }) => {\n  console.log('Request received:', data)\n  const result = await next()\n  console.log('Response processed:', result)\n  return result\n})\n\nUsing Middleware in Your Server Functions\n\nOnce you've defined your middleware, you can use it in combination with the createServerFn function to customize the behavior of your server functions.\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { loggingMiddleware } from './middleware'\n\nconst fn = createServerFn()\n  .middleware([loggingMiddleware])\n  .handler(async () => {\n    // ...\n  })\n\nMiddleware Methods\n\nSeveral methods are available to customize the middleware. If you are (hopefully) using TypeScript, the order of these methods is enforced by the type system to ensure maximum inference and type safety.\n\nmiddleware: Add a middleware to the chain.\nvalidator: Modify the data object before it is passed to this middleware and any nested middleware.\nserver: Define server-side logic that the middleware will execute before any nested middleware and ultimately a server function, and also provide the result to the next middleware.\nclient: Define client-side logic that the middleware will execute before any nested middleware and ultimately the client-side RPC function (or the server-side function), and also provide the result to the next middleware.\nThe middleware method\n\nThe middleware method is used to dependency middleware to the chain that will executed before the current middleware. Just call the middleware method with an array of middleware objects.\n\ntsx\nimport { createMiddleware } from '@tanstack/react-start'\n\nconst loggingMiddleware = createMiddleware().middleware([\n  authMiddleware,\n  loggingMiddleware,\n])\n\n\nType-safe context and payload validation are also inherited from parent middlewares!\n\nThe validator method\n\nThe validator method is used to modify the data object before it is passed to this middleware, nested middleware, and ultimately the server function. This method should receive a function that takes the data object and returns a validated (and optionally modified) data object. It's common to use a validation library like zod to do this. Here is an example:\n\ntsx\nimport { createMiddleware } from '@tanstack/react-start'\nimport { zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst mySchema = z.object({\n  workspaceId: z.string(),\n})\n\nconst workspaceMiddleware = createMiddleware()\n  .validator(zodValidator(mySchema))\n  .server(({ next, data }) => {\n    console.log('Workspace ID:', data.workspaceId)\n    return next()\n  })\n\nThe server method\n\nThe server method is used to define server-side logic that the middleware will execute both before and after any nested middleware and ultimately a server function. This method receives an object with the following properties:\n\nnext: A function that, when called, will execute the next middleware in the chain.\ndata: The data object that was passed to the server function.\ncontext: An object that stores data from parent middleware. It can be extended with additional data that will be passed to child middleware.\nReturning the required result from next\n\nThe next function is used to execute the next middleware in the chain. You must await and return (or return directly) the result of the next function provided to you for the chain to continue executing.\n\ntsx\nimport { createMiddleware } from '@tanstack/react-start'\n\nconst loggingMiddleware = createMiddleware().server(async ({ next }) => {\n  console.log('Request received')\n  const result = await next()\n  console.log('Response processed')\n  return result\n})\n\nProviding context to the next middleware via next\n\nThe next function can be optionally called with an object that has a context property with an object value. Whatever properties you pass to this context value will be merged into the parent context and provided to the next middleware.\n\ntsx\nimport { createMiddleware } from '@tanstack/react-start'\n\nconst awesomeMiddleware = createMiddleware().server(({ next }) => {\n  return next({\n    context: {\n      isAwesome: Math.random() > 0.5,\n    },\n  })\n})\n\nconst loggingMiddleware = createMiddleware().server(\n  async ({ next, context }) => {\n    console.log('Is awesome?', context.isAwesome)\n    return next()\n  },\n)\n\nClient-Side Logic\n\nDespite server functions being mostly server-side bound operations, there is still plenty of client-side logic surrounding the outgoing RPC request from the client. This means that we can also define client-side logic in middleware that will execute on the client side around any nested middleware and ultimately the RPC function and its response to the client.\n\nClient-side Payload Validation\n\nBy default, middleware validation is only performed on the server to keep the client bundle size small. However, you may also choose to validate data on the client side by passing the validateClient: true option to the createMiddleware function. This will cause the data to be validated on the client side before being sent to the server, potentially saving a round trip.\n\nWhy can't I pass a different validation schema for the client?\n\nThe client-side validation schema is derived from the server-side schema. This is because the client-side validation schema is used to validate the data before it is sent to the server. If the client-side schema were different from the server-side schema, the server would receive data that it did not expect, which could lead to unexpected behavior.\n\ntsx\nimport { createMiddleware } from '@tanstack/react-start'\nimport { zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst workspaceMiddleware = createMiddleware({ validateClient: true })\n  .validator(zodValidator(mySchema))\n  .server(({ next, data }) => {\n    console.log('Workspace ID:', data.workspaceId)\n    return next()\n  })\n\nThe client method\n\nClient middleware logic is defined using the client method on a Middleware object. This method is used to define client-side logic that the middleware will execute both before and after any nested middleware and ultimately the client-side RPC function (or the server-side function if you're doing SSR or calling this function from another server function).\n\nClient-side middleware logic shares much of the same API as logic created with the server method, but it is executed on the client side. This includes:\n\nRequiring the next function to be called to continue the chain.\nThe ability to provide context to the next client middleware via the next function.\nThe ability to modify the data object before it is passed to the next client middleware.\n\nSimilar to the server function, it also receives an object with the following properties:\n\nnext: A function that, when called, will execute the next client middleware in the chain.\ndata: The data object that was passed to the client function.\ncontext: An object that stores data from parent middleware. It can be extended with additional data that will be passed to child middleware.\ntsx\nconst loggingMiddleware = createMiddleware().client(async ({ next }) => {\n  console.log('Request sent')\n  const result = await next()\n  console.log('Response received')\n  return result\n})\n\nSending client context to the server\n\nClient context is NOT sent to the server by default since this could end up unintentionally sending large payloads to the server. If you need to send client context to the server, you must call the next function with a sendContext property and object to transmit any data to the server. Any properties passed to sendContext will be merged, serialized and sent to the server along with the data and will be available on the normal context object of any nested server middleware.\n\ntsx\nconst requestLogger = createMiddleware()\n  .client(async ({ next, context }) => {\n    return next({\n      sendContext: {\n        // Send the workspace ID to the server\n        workspaceId: context.workspaceId,\n      },\n    })\n  })\n  .server(async ({ next, data, context }) => {\n    // Woah! We have the workspace ID from the client!\n    console.log('Workspace ID:', context.workspaceId)\n    return next()\n  })\n\nClient-Sent Context Security\n\nYou may have noticed that in the example above that while client-sent context is type-safe, it is is not required to be validated at runtime. If you pass dynamic user-generated data via context, that could pose a security concern, so if you are sending dynamic data from the client to the server via context, you should validate it in the server-side middleware before using it. Here's an example:\n\ntsx\nimport { zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst requestLogger = createMiddleware()\n  .client(async ({ next, context }) => {\n    return next({\n      sendContext: {\n        workspaceId: context.workspaceId,\n      },\n    })\n  })\n  .server(async ({ next, data, context }) => {\n    // Validate the workspace ID before using it\n    const workspaceId = zodValidator(z.number()).parse(context.workspaceId)\n    console.log('Workspace ID:', workspaceId)\n    return next()\n  })\n\nSending server context to the client\n\nSimilar to sending client context to the server, you can also send server context to the client by calling the next function with a sendContext property and object to transmit any data to the client. Any properties passed to sendContext will be merged, serialized and sent to the client along with the response and will be available on the normal context object of any nested client middleware. The returned object of calling next in client contains the context sent from server to the client and is type-safe. Middleware is able to infer the context sent from the server to the client from previous middleware chained from the middleware function.\n\nWarning\n\nThe return type of next in client can only be inferred from middleware known in the current middleware chain. Therefore the most accurate return type of next is in middleware at the end of the middleware chain\n\ntsx\nconst serverTimer = createMiddleware().server(async ({ next }) => {\n  return next({\n    sendContext: {\n      // Send the current time to the client\n      timeFromServer: new Date(),\n    },\n  })\n})\n\nconst requestLogger = createMiddleware()\n  .middleware([serverTimer])\n  .client(async ({ next }) => {\n    const result = await next()\n    // Woah! We have the time from the server!\n    console.log('Time from the server:', result.context.timeFromServer)\n\n    return result\n  })\n\nReading/Modifying the Server Response\n\nMiddleware that uses the server method executes in the same context as server functions, so you can follow the exact same Server Function Context Utilities to read and modify anything about the request headers, status codes, etc.\n\nModifying the Client Request\n\nMiddleware that uses the client method executes in a completely different client-side context than server functions, so you can't use the same utilities to read and modify the request. However, you can still modify the request returning additional properties when calling the next function. Currently supported properties are:\n\nheaders: An object containing headers to be added to the request.\n\nHere's an example of adding an Authorization header any request using this middleware:\n\ntsx\nimport { getToken } from 'my-auth-library'\n\nconst authMiddleware = createMiddleware().client(async ({ next }) => {\n  return next({\n    headers: {\n      Authorization: `Bearer ${getToken()}`,\n    },\n  })\n})\n\nUsing Middleware\n\nMiddleware can be used in two different ways:\n\nGlobal Middleware: Middleware that should be executed for every request.\nServer Function Middleware: Middleware that should be executed for a specific server function.\nGlobal Middleware\n\nGlobal middleware runs automatically for every server function in your application. This is useful for functionality like authentication, logging, and monitoring that should apply to all requests.\n\nTo use global middleware, create a global-middleware.ts file in your project (typically at app/global-middleware.ts). This file runs in both client and server environments and is where you register global middleware.\n\nHere's how to register global middleware:\n\ntsx\n// app/global-middleware.ts\nimport { registerGlobalMiddleware } from '@tanstack/react-start'\nimport { authMiddleware } from './middleware'\n\nregisterGlobalMiddleware({\n  middleware: [authMiddleware],\n})\n\nGlobal Middleware Type Safety\n\nGlobal middleware types are inherently detached from server functions themselves. This means that if a global middleware supplies additional context to server functions or other server function specific middleware, the types will not be automatically passed through to the server function or other server function specific middleware.\n\ntsx\n// app/global-middleware.ts\nregisterGlobalMiddleware({\n  middleware: [authMiddleware],\n})\n\ntsx\n// authMiddleware.ts\nconst authMiddleware = createMiddleware().server(({ next, context }) => {\n  console.log(context.user) // <-- This will not be typed!\n  // ...\n})\n\n\nTo solve this, add the global middleware you are trying to reference to the server function's middleware array. The global middleware will be deduped to a single entry (the global instance), and your server function will receive the correct types.\n\nHere's an example of how this works:\n\ntsx\nimport { authMiddleware } from './authMiddleware'\n\nconst fn = createServerFn()\n  .middleware([authMiddleware])\n  .handler(async ({ context }) => {\n    console.log(context.user)\n    // ...\n  })\n\nMiddleware Execution Order\n\nMiddleware is executed dependency-first, starting with global middleware, followed by server function middleware. The following example will log the following in this order:\n\nglobalMiddleware1\nglobalMiddleware2\na\nb\nc\nd\ntsx\nconst globalMiddleware1 = createMiddleware().server(async ({ next }) => {\n  console.log('globalMiddleware1')\n  return next()\n})\n\nconst globalMiddleware2 = createMiddleware().server(async ({ next }) => {\n  console.log('globalMiddleware2')\n  return next()\n})\n\nregisterGlobalMiddleware({\n  middleware: [globalMiddleware1, globalMiddleware2],\n})\n\nconst a = createMiddleware().server(async ({ next }) => {\n  console.log('a')\n  return next()\n})\n\nconst b = createMiddleware()\n  .middleware([a])\n  .server(async ({ next }) => {\n    console.log('b')\n    return next()\n  })\n\nconst c = createMiddleware()\n  .middleware()\n  .server(async ({ next }) => {\n    console.log('c')\n    return next()\n  })\n\nconst d = createMiddleware()\n  .middleware([b, c])\n  .server(async () => {\n    console.log('d')\n  })\n\nconst fn = createServerFn()\n  .middleware([d])\n  .server(async () => {\n    console.log('fn')\n  })\n\nEnvironment Tree Shaking\n\nMiddleware functionality is tree-shaken based on the environment for each bundle produced.\n\nOn the server, nothing is tree-shaken, so all code used in middleware will be included in the server bundle.\nOn the client, all server-specific code is removed from the client bundle. This means any code used in the server method is always removed from the client bundle. If validateClient is set to true, the client-side validation code will be included in the client bundle, otherwise data validation code will also be removed.\nEdit on GitHub\nStatic Server Functions\nAPI Routes\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Static Server Functions | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/static-server-functions",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nStatic Server Functions\nWhat are Static Server Functions?\n\nStatic server functions are server functions that are executed at build time and cached as static assets when using prerendering/static-generation. They can be set to \"static\" mode by passing the type: 'static' option to createServerFn:\n\ntsx\nconst myServerFn = createServerFn({ type: 'static' }).handler(async () => {\n  return 'Hello, world!'\n})\n\n\nThis pattern goes as follows:\n\nBuild-time\nDuring build-time prerendering, a server function with type: 'static' is executed\nThe result is cached with your build output as a static JSON file under a derived key (function ID + params/payload hash)\nThe result is returned as normal during prerendering/static-generation and used to prerender the page\nRuntime\nInitially, the prerendered page's html is served and the server function data is embedded in the html\nWhen the client mounts, the embedded server function data is hydrated\nFor future client-side invocations, the server function is replaced with a fetch call to the static JSON file\nCustomizing the Server Functions Static Cache\n\nBy default, the static server function cache implementation stores and retrieves static data in the build output directory via node's fs module and likewise fetches the data at runtime using a fetch call to the same static file.\n\nThis interface can be customized by importing and calling the createServerFnStaticCache function to create a custom cache implementation and then calling setServerFnStaticCache to set it:\n\ntsx\nimport {\n  createServerFnStaticCache,\n  setServerFnStaticCache,\n} from '@tanstack/react-start/client'\n\nconst myCustomStaticCache = createServerFnStaticCache({\n  setItem: async (ctx, data) => {\n    // Store the static data in your custom cache\n  },\n  getItem: async (ctx) => {\n    // Retrieve the static data from your custom cache\n  },\n  fetchItem: async (ctx) => {\n    // During runtime, fetch the static data from your custom cache\n  },\n})\n\nsetServerFnStaticCache(myCustomStaticCache)\n\nEdit on GitHub\nServer Functions\nMiddleware\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Build a Project from Scratch | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/build-from-scratch",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nBuild a Project from Scratch\n\nNote\n\nIf you chose to quick start with an example or cloned project, you can skip this guide and move on to the Learn the Basics guide.\n\nSo you want to build a TanStack Start project from scratch?\n\nThis guide will help you build a very basic TanStack Start web application. Together, we will use TanStack Start to:\n\nServe an index page...\nWhich displays a counter...\nWith a button to increment the counter persistently.\n\nHere is what that will look like\n\nLet's create a new project directory and initialize it.\n\nshell\nmkdir myApp\ncd myApp\nnpm init -y\n\n\nNote\n\n> We use npm in all of these examples, but you can use your package manager of choice instead.\n\nTypeScript Configuration\n\nWe highly recommend using TypeScript with TanStack Start. Create a tsconfig.json file with at least the following settings:\n\njson\n{\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"moduleResolution\": \"Bundler\",\n    \"module\": \"ESNext\",\n    \"target\": \"ES2022\",\n    \"skipLibCheck\": true,\n    \"strictNullChecks\": true\n  }\n}\n\n\nNote\n\n> Enabling verbatimModuleSyntax can result in server bundles leaking into client bundles. It is recommended to keep this option disabled.\n\nInstall Dependencies\n\nTanStack Start is (currently*) powered by Vinxi and TanStack Router and requires them as dependencies.\n\nNote\n\n> *Vinxi will be removed before version 1.0.0 is released and TanStack will rely only on Vite and Nitro. The commands and APIs that use Vinxi will likely be replaced with a Vite plugin or dedicated TanStack Start CLI.\n\nTo install them, run:\n\nshell\nnpm i @tanstack/react-start @tanstack/react-router vinxi\n\n\nYou'll also need React and the Vite React plugin, so install them too:\n\nshell\nnpm i react react-dom\nnpm i -D @vitejs/plugin-react vite-tsconfig-paths\n\n\nand some TypeScript:\n\nshell\nnpm i -D typescript @types/react @types/react-dom\n\nUpdate Configuration Files\n\nWe'll then update our package.json to use Vinxi's CLI and set \"type\": \"module\":\n\njson\n{\n  // ...\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vinxi dev\",\n    \"build\": \"vinxi build\",\n    \"start\": \"vinxi start\"\n  }\n}\n\n\nThen configure TanStack Start's app.config.ts file:\n\ntypescript\n// app.config.ts\nimport { defineConfig } from '@tanstack/react-start/config'\nimport tsConfigPaths from 'vite-tsconfig-paths'\n\nexport default defineConfig({\n  vite: {\n    plugins: [\n      tsConfigPaths({\n        projects: ['./tsconfig.json'],\n      }),\n    ],\n  },\n})\n\nAdd the Basic Templating\n\nThere are four required files for TanStack Start usage:\n\nThe router configuration\nThe server entry point\nThe client entry point\nThe root of your application\n\nOnce configuration is done, we'll have a file tree that looks like the following:\n\n.\nâ”œâ”€â”€ app/\nâ”‚   â”œâ”€â”€ routes/\nâ”‚   â”‚   â””â”€â”€ `__root.tsx`\nâ”‚   â”œâ”€â”€ `client.tsx`\nâ”‚   â”œâ”€â”€ `router.tsx`\nâ”‚   â”œâ”€â”€ `routeTree.gen.ts`\nâ”‚   â””â”€â”€ `ssr.tsx`\nâ”œâ”€â”€ `.gitignore`\nâ”œâ”€â”€ `app.config.ts`\nâ”œâ”€â”€ `package.json`\nâ””â”€â”€ `tsconfig.json`\n\nThe Router Configuration\n\nThis is the file that will dictate the behavior of TanStack Router used within Start. Here, you can configure everything from the default preloading functionality to caching staleness.\n\nNote\n\nYou won't have a routeTree.gen.ts file yet. This file will be generated when you run TanStack Start for the first time.\n\ntsx\n// app/router.tsx\nimport { createRouter as createTanStackRouter } from '@tanstack/react-router'\nimport { routeTree } from './routeTree.gen'\n\nexport function createRouter() {\n  const router = createTanStackRouter({\n    routeTree,\n    scrollRestoration: true,\n  })\n\n  return router\n}\n\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: ReturnType<typeof createRouter>\n  }\n}\n\nThe Server Entry Point\n\nAs TanStack Start is an SSR framework, we need to pipe this router information to our server entry point:\n\ntsx\n// app/ssr.tsx\nimport {\n  createStartHandler,\n  defaultStreamHandler,\n} from '@tanstack/react-start/server'\nimport { getRouterManifest } from '@tanstack/react-start/router-manifest'\n\nimport { createRouter } from './router'\n\nexport default createStartHandler({\n  createRouter,\n  getRouterManifest,\n})(defaultStreamHandler)\n\n\nThis allows us to know what routes and loaders we need to execute when the user hits a given route.\n\nThe Client Entry Point\n\nNow we need a way to hydrate our client-side JavaScript once the route resolves to the client. We do this by piping the same router information to our client entry point:\n\ntsx\n// app/client.tsx\n/// <reference types=\"vinxi/types/client\" />\nimport { hydrateRoot } from 'react-dom/client'\nimport { StartClient } from '@tanstack/react-start'\nimport { createRouter } from './router'\n\nconst router = createRouter()\n\nhydrateRoot(document, <StartClient router={router} />)\n\n\nThis enables us to kick off client-side routing once the user's initial server request has fulfilled.\n\nThe Root of Your Application\n\nFinally, we need to create the root of our application. This is the entry point for all other routes. The code in this file will wrap all other routes in the application.\n\ntsx\n// app/routes/__root.tsx\nimport type { ReactNode } from 'react'\nimport {\n  Outlet,\n  createRootRoute,\n  HeadContent,\n  Scripts,\n} from '@tanstack/react-router'\n\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      {\n        title: 'TanStack Start Starter',\n      },\n    ],\n  }),\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: Readonly<{ children: ReactNode }>) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        {children}\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nWriting Your First Route\n\nNow that we have the basic templating setup, we can write our first route. This is done by creating a new file in the app/routes directory.\n\ntsx\n// app/routes/index.tsx\nimport * as fs from 'node:fs'\nimport { createFileRoute, useRouter } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nconst filePath = 'count.txt'\n\nasync function readCount() {\n  return parseInt(\n    await fs.promises.readFile(filePath, 'utf-8').catch(() => '0'),\n  )\n}\n\nconst getCount = createServerFn({\n  method: 'GET',\n}).handler(() => {\n  return readCount()\n})\n\nconst updateCount = createServerFn({ method: 'POST' })\n  .validator((d: number) => d)\n  .handler(async ({ data }) => {\n    const count = await readCount()\n    await fs.promises.writeFile(filePath, `${count + data}`)\n  })\n\nexport const Route = createFileRoute('/')({\n  component: Home,\n  loader: async () => await getCount(),\n})\n\nfunction Home() {\n  const router = useRouter()\n  const state = Route.useLoaderData()\n\n  return (\n    <button\n      type=\"button\"\n      onClick={() => {\n        updateCount({ data: 1 }).then(() => {\n          router.invalidate()\n        })\n      }}\n    >\n      Add 1 to {state}?\n    </button>\n  )\n}\n\n\nThat's it! ðŸ¤¯ You've now set up a TanStack Start project and written your first route. ðŸŽ‰\n\nYou can now run npm run dev to start your server and navigate to http://localhost:3000 to see your route in action.\n\nYou want to deploy your application? Check out the hosting guide.\n\nEdit on GitHub\nQuick Start\nLearn the Basics\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Learn the Basics | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/learn-the-basics",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nLearn the Basics\n\nThis guide will help you learn the basics behind how TanStack Start works, regardless of how you set up your project.\n\nDependencies\n\nTanStack Start is (currently*) powered by Vinxi, Nitro and TanStack Router.\n\nTanStack Router: A router for building web applications.\nNitro: A framework for building server applications.\nVinxi: A server framework for building web applications.\n\nNote\n\nVinxi will be removed before version 1.0.0 is released and TanStack will rely only on Vite and Nitro. The commands and APIs that use Vinxi will likely be replaced with a Vite plugin.\n\nIt all \"Starts\" with the Router\n\nThis is the file that will dictate the behavior of TanStack Router used within Start. Here, you can configure everything from the default preloading functionality to caching staleness.\n\ntsx\n// app/router.tsx\nimport { createRouter as createTanStackRouter } from '@tanstack/react-router'\nimport { routeTree } from './routeTree.gen'\n\nexport function createRouter() {\n  const router = createTanStackRouter({\n    routeTree,\n    scrollRestoration: true,\n  })\n\n  return router\n}\n\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: ReturnType<typeof createRouter>\n  }\n}\n\nNotice the scrollRestoration property. This is used to restore the scroll position of the page when navigating between routes.\nRoute Generation\n\nThe routeTree.gen.ts file is generated when you run TanStack Start (via npm run dev or npm run start) for the first time. This file contains the generated route tree and a handful of TS utilities that make TanStack Start fully type-safe.\n\nThe Server Entry Point\n\nAlthough TanStack Start is designed with client-first APIs, it is by and large, a full-stack framework. This means that all use cases, including both dynamic and static rely on a server or build-time entry to render our application's initial HTML payload.\n\nThis is done via the app/ssr.tsx file:\n\ntsx\n// app/ssr.tsx\nimport {\n  createStartHandler,\n  defaultStreamHandler,\n} from '@tanstack/react-start/server'\nimport { getRouterManifest } from '@tanstack/react-start/router-manifest'\n\nimport { createRouter } from './router'\n\nexport default createStartHandler({\n  createRouter,\n  getRouterManifest,\n})(defaultStreamHandler)\n\n\nWhether we are statically generating our app or serving it dynamically, the ssr.tsx file is the entry point for doing all SSR-related work.\n\nIt's important that a new router is created for each request. This ensures that any data handled by the router is unique to the request.\nThe getRouterManifest function is used to generate the router manifest, which is used to determine many aspects of asset management and preloading for our application.\nThe defaultStreamHandler function is used to render our application to a stream, allowing us to take advantage of streaming HTML to the client. (This is the default handler, but you can also use other handlers like defaultRenderHandler, or even build your own)\nThe Client Entry Point\n\nGetting our html to the client is only half the battle. Once there, we need to hydrate our client-side JavaScript once the route resolves to the client. We do this by hydrating the root of our application with the StartClient component:\n\ntsx\n// app/client.tsx\nimport { hydrateRoot } from 'react-dom/client'\nimport { StartClient } from '@tanstack/react-start'\nimport { createRouter } from './router'\n\nconst router = createRouter()\n\nhydrateRoot(document, <StartClient router={router} />)\n\n\nThis enables us to kick off client-side routing once the user's initial server request has fulfilled.\n\nThe Root of Your Application\n\nOther than the client entry point, the __root route of your application is the entry point for your application. The code in this file will wrap all other routes in the app, including your home page. It behaves like a pathless layout route for your whole application.\n\nBecause it is always rendered, it is the perfect place to construct your application shell and take care of any global logic.\n\ntsx\n// app/routes/__root.tsx\nimport {\n  Outlet,\n  createRootRoute,\n  HeadContent,\n  Scripts,\n} from '@tanstack/react-router'\nimport type { ReactNode } from 'react'\n\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        charSet: 'utf-8',\n      },\n      {\n        name: 'viewport',\n        content: 'width=device-width, initial-scale=1',\n      },\n      {\n        title: 'TanStack Start Starter',\n      },\n    ],\n  }),\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <RootDocument>\n      <Outlet />\n    </RootDocument>\n  )\n}\n\nfunction RootDocument({ children }: Readonly<{ children: ReactNode }>) {\n  return (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        {children}\n        <Scripts />\n      </body>\n    </html>\n  )\n}\n\nThis layout may change in the future as we roll out SPA mode, which allows the root route to render the SPA shell without any page-specific content.\nNotice the Scripts component. This is used to load all of the client-side JavaScript for the application.\nRoutes\n\nRoutes are an extensive feature of TanStack Router, and are covered thoroughly in the Routing Guide. As a summary:\n\nRoutes are defined using the createFileRoute function.\nRoutes are automatically code-split and lazy-loaded.\nCritical data fetching is coordinated from a Route's loader\nMuch more!\ntsx\n// app/routes/index.tsx\nimport * as fs from 'node:fs'\nimport { createFileRoute, useRouter } from '@tanstack/react-router'\nimport { createServerFn } from '@tanstack/react-start'\n\nconst filePath = 'count.txt'\n\nasync function readCount() {\n  return parseInt(\n    await fs.promises.readFile(filePath, 'utf-8').catch(() => '0'),\n  )\n}\n\nconst getCount = createServerFn({\n  method: 'GET',\n}).handler(() => {\n  return readCount()\n})\n\nconst updateCount = createServerFn({ method: 'POST' })\n  .validator((d: number) => d)\n  .handler(async ({ data }) => {\n    const count = await readCount()\n    await fs.promises.writeFile(filePath, `${count + data}`)\n  })\n\nexport const Route = createFileRoute('/')({\n  component: Home,\n  loader: async () => await getCount(),\n})\n\nfunction Home() {\n  const router = useRouter()\n  const state = Route.useLoaderData()\n\n  return (\n    <button\n      type=\"button\"\n      onClick={() => {\n        updateCount({ data: 1 }).then(() => {\n          router.invalidate()\n        })\n      }}\n    >\n      Add 1 to {state}?\n    </button>\n  )\n}\n\nNavigation\n\nTanStack Start builds 100% on top of TanStack Router, so all of the navigation features of TanStack Router are available to you. In summary:\n\nUse the Link component to navigate to a new route.\nUse the useNavigate hook to navigate imperatively.\nUse the useRouter hook anywhere in your application to access the router instance and perform invalidations.\nEvery router hook that returns state is reactive, meaning it will automatically re-run when the appropriate state changes.\n\nHere's a quick example of how you can use the Link component to navigate to a new route:\n\ntsx\nimport { Link } from '@tanstack/react-router'\n\nfunction Home() {\n  return <Link to=\"/about\">About</Link>\n}\n\n\nFor more in-depth information on navigation, check out the navigation guide.\n\nServer Functions (RPCs)\n\nYou may have noticed the server function we created above using createServerFn. This is one of TanStack's most powerful features, allowing you to create server-side functions that can be called from both the server during SSR and the client!\n\nHere's a quick overview of how server functions work:\n\nServer functions are created using the createServerFn function.\nThey can be called from both the server during SSR and the client.\nThey can be used to fetch data from the server, or to perform other server-side actions.\n\nHere's a quick example of how you can use server functions to fetch and return data from the server:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport * as fs from 'node:fs'\nimport { z } from 'zod'\n\nconst getUserById = createServerFn({ method: 'GET' })\n  // Always validate data sent to the function, here we use Zod\n  .validator(z.string())\n  // The handler function is where you perform the server-side logic\n  .handler(async ({ data }) => {\n    return db.query.users.findFirst({ where: eq(users.id, data) })\n  })\n\n// Somewhere else in your application\nconst user = await getUserById({ data: '1' })\n\n\nTo learn more about server functions, check out the server functions guide.\n\nMutations\n\nServer Functions can also be used to perform mutations on the server. This is also done using the same createServerFn function, but with the additional requirement that you invalidate any data on the client that was affected by the mutation.\n\nIf you're using TanStack Router only, you can use the router.invalidate() method to invalidate all router data and re-fetch it.\nIf you're using TanStack Query, you can use the queryClient.invalidateQueries() method to invalidate data, among other more specific methods to target specific queries.\n\nHere's a quick example of how you can use server functions to perform a mutation on the server and invalidate the data on the client:\n\ntsx\nimport { createServerFn } from '@tanstack/react-start'\nimport { z } from 'zod'\nimport { dbUpdateUser } from '...'\n\nconst UserSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n})\nexport type User = z.infer<typeof UserSchema>\n\nexport const updateUser = createServerFn({ method: 'POST' })\n  .validator(UserSchema)\n  .handler(({ data }) => dbUpdateUser(data))\n\n// Somewhere else in your application\nimport { useQueryClient } from '@tanstack/react-query'\nimport { useRouter } from '@tanstack/react-router'\nimport { useServerFunction } from '@tanstack/react-start'\nimport { updateUser, type User } from '...'\n\nexport function useUpdateUser() {\n  const router = useRouter()\n  const queryClient = useQueryClient()\n  const _updateUser = useServerFunction(updateUser)\n\n  return useCallback(\n    async (user: User) => {\n      const result = await _updateUser({ data: user })\n\n      router.invalidate()\n      queryClient.invalidateQueries({\n        queryKey: ['users', 'updateUser', user.id],\n      })\n\n      return result\n    },\n    [router, queryClient, _updateUser],\n  )\n}\n\n// Somewhere else in your application\nimport { useUpdateUser } from '...'\n\nfunction MyComponent() {\n  const updateUser = useUpdateUser()\n  const onClick = useCallback(async () => {\n    await updateUser({ id: '1', name: 'John' })\n    console.log('Updated user')\n  }, [updateUser])\n\n  return <button onClick={onClick}>Click Me</button>\n}\n\n\nTo learn more about mutations, check out the mutations guide.\n\nData Loading\n\nAnother powerful feature of TanStack Router is data loading. This allows you to fetch data for SSR and preload route data before it is rendered. This is done using the loader function of a route.\n\nHere's a quick overview of how data loading works:\n\nData loading is done using the loader function of a route.\nData loaders are isomorphic, meaning they are executed on both the server and the client.\nFor performing server-only logic, call a server function from within the loader.\nSimilar to TanStack Query, data loaders are cached on the client and are re-used and even re-fetched in the background when the data is stale.\n\nTo learn more about data loading, check out the data loading guide.\n\nEdit on GitHub\nBuild from Scratch\nServer Functions\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Quick Start | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/quick-start",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nQuick Start\nImpatient?\n\nIf you're impatient, you can clone and run the Basic example right away with the following commands:\n\nbash\nnpx gitpick TanStack/router/tree/main/examples/react/start-basic start-basic\ncd start-basic\nnpm install\nnpm run dev\n\n\nIf you'd like to use a different example, you can replace start-basic above with the slug of the example you'd like to use from the list below.\n\nOnce you've cloned the example you want, head back to the Learn the Basics guide to learn how to use TanStack Start!\n\nExamples\n\nTanStack Start has load of examples to get you started. Pick one of the examples below to get started!\n\nBasic (start-basic)\nBasic + Auth (start-basic-auth)\nCounter (start-counter)\nBasic + React Query (start-basic-react-query)\nClerk Auth (start-clerk-basic)\nConvex + Trellaux (start-convex-trellaux)\nSupabase (start-supabase-basic)\nTrellaux (start-trellaux)\nWorkOS (start-workos)\nMaterial UI (start-material-ui)\nStackblitz\n\nEach example above has an embedded stackblitz preview to find the one that feels like a good starting point\n\nQuick Deploy\n\nTo quickly deploy an example, click the Deploy to Netlify button on an example's page to both clone and deploy the example to Netlify.\n\nManual Deploy\n\nTo manually clone and deploy the example to anywhere else you'd like, use the following commands replacing EXAMPLE_SLUG with the slug of the example you'd like to use from above:\n\nbash\nnpx gitpick TanStack/router/tree/main/examples/react/EXAMPLE_SLUG my-new-project\ncd my-new-project\nnpm install\nnpm run dev\n\n\nOnce you've clone or deployed an example, head back to the Learn the Basics guide to learn how to use TanStack Start!\n\nOther Router Examples\n\nWhile not Start-specific examples, these may help you understand more about how TanStack Router works:\n\nQuickstart (file-based)\nBasic (file-based)\nKitchen Sink (file-based)\nKitchen Sink + React Query (file-based)\nLocation Masking\nAuthenticated Routes\nScroll Restoration\nDeferred Data\nNavigation Blocking\nView Transitions\nWith tRPC\nWith tRPC + React Query\nEdit on GitHub\nGetting Started\nBuild from Scratch\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Getting Started | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/getting-started",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nGetting Started\n\nTo set up a TanStack Start project, you can:\n\nUse the Quick Start Examples to rapidly learn as you go\nBuild a project from scratch to learn how TanStack Start works from the ground up\nEdit on GitHub\nOverview\nQuick Start\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "TanStack Start Overview | TanStack Start React Docs",
    "url": "https://tanstack.com/start/latest/docs/framework/react/overview",
    "html": "TanStack\nStart v0\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nGetting Started\nreact\nQuick Start\nreact\nBuild from Scratch\nreact\nLearn the Basics\nreact\nServer Functions\nreact\nStatic Server Functions\nreact\nMiddleware\nreact\nAPI Routes\nreact\nSSR\nreact\nHosting\nreact\nAuthentication\nreact\nDatabases\nreact\nObservability\nreact\nStatic Prerendering\nreact\nPath Aliases\nreact\nEXAMPLES\nBasic\nreact\nBasic + React Query\nreact\nBasic + Clerk Auth\nreact\nBasic + DIY Auth\nreact\nBasic + Supabase Auth\nreact\nTrellaux + Convex\nreact\nTrellaux\nreact\nWorkOS\nreact\nMaterial UI\nreact\nTUTORIALS\nReading and Writing a File\nreact\nTanStack Start Overview\n\nTanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite. It is ready to deploy to your favorite hosting provider!\n\nRouter or Start?\n\nTanStack Router is a powerful, type-safe, and full-featured routing system for React applications. It is designed to handle the beefiest of full-stack routing requirements with ease. TanStack Start builds on top of Router's type system to provide type-safe full-stack APIs that keep you in the fast lane.\n\nWhat you get with TanStack Router:\n\n100% inferred TypeScript support\nTypesafe navigation\nNested Routing and pathless layout routes\nBuilt-in Route Loaders w/ SWR Caching\nDesigned for client-side data caches (TanStack Query, SWR, etc.)\nAutomatic route prefetching\nAsynchronous route elements and error boundaries\nFile-based Route Generation\nTypesafe JSON-first Search Params state management APIs\nPath and Search Parameter Schema Validation\nSearch Param Navigation APIs\nCustom Search Param parser/serializer support\nSearch param middleware\nRoute matching/loading middleware\n\nWhat you get with TanStack Start:\n\nFull-document SSR\nStreaming\nServer Functions / RPCs\nBundling\nDeployment\nFull-Stack Type Safety\n\nIn summary, use TanStack Router for client-side routing and TanStack Start for full-stack routing.\n\nHow does it work?\n\nTanStack Start uses Nitro and Vite to bundle and deploy your application. In fact, these are the same tools that power Solid Start! With these tools, we can do a few things we couldn't do before:\n\nProvide a unified API for SSR, streaming, and hydration\nExtract server-only code from your client-side code (e.g. server functions)\nBundle your application for deployment to any hosting provider\nWhen should I use it?\n\nTanStack Start is perfect for you if you want to build a full-stack React application with the following requirements:\n\nFull-document SSR & Hydration\nStreaming\nServer Functions / RPCs\nFull-Stack Type Safety\nRobust Routing\nRich Client-Side Interactivity\nWhen might I not want to use it?\n\nTanStack Start is not for you if:\n\nYour site will be 100% static\nYour goal is a server-rendered site with zero JS or minimal client-side interactivity\nYou're looking for a React-Server-Component-first framework. (We'll support RSCs soon in our own awesome flavor!)\nHow is TanStack Start funded?\n\nTanStack works closely with our partners to provide the best possible developer experience while also providing solutions that work anywhere and are vetted by industry experts. Each of our partners plays a unique role in the TanStack ecosystem:\n\nClerk\nThe best possible authentication experience for modern web applications, including TanStack Start applications. Clerk provides TanStack Start users with first-class integrations and solutions to auth and collaborates closely with the TanStack team to ensure that TanStack Start provides APIs that are up to date with the latest in auth best practices.\nNetlify\nThe leading hosting platform for web applications that provides a fast, secure, and reliable environment for deploying your web applications. We work closely with Netlify to ensure that TanStack Start applications not only deploy seamlessly to their platform, but also implement best practices for performance, security, and reliability regardless of where you end up deploying.\nNeon\nA serverless, autoscaling Postgres solution purpose-built for modern full-stack apps. Neon offers rich integration opportunities with TanStack Start, including server functions and database-backed routing. Together, weâ€™re simplifying the database experience for developers using TanStack.\nConvex\nA serverless database platform that integrates seamlessly with TanStack Start. Convex is designed to simplify the process of managing your application's data and provides a real-time, scalable, and transactional data backend that works well with TanStack Start applications. Convex also collaborates closely with the TanStack team to ensure that TanStack Start provides APIs that are up to date with the latest in database best practices.\nSentry\nA powerful, full-featured observability platform that integrates seamlessly with TanStack Start. Sentry helps developers monitor and fix crashes in real-time and provides insights into your application's performance and error tracking. Sentry collaborates closely with the TanStack team to ensure that TanStack Start provides APIs that are up to date with the latest in observability best practices.\nReady to get started?\n\nProceed to the next page to learn how to install TanStack Start and create your first app!\n\nEdit on GitHub\nDiscord\nGetting Started\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nTABLE\nSupercharge your tables or build a datagrid from scratch for TS/JS, React, Vue, Solid, Svelte, Qwik, Angular, and Lit while retaining 100% control over markup and styles.\nLEARN MORE\nTANSTACK\nCONFIG\nThe build and publish utilities used by all of our projects. Use it if you dare!\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  }
]