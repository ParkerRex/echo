[
  {
    "title": "ToMaskOptions type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/ToMaskOptionsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nToMaskOptions type\n\nThe ToMaskOptions type extends the ToOptions type and describes additional options available when using route masks.\n\ntsx\ntype ToMaskOptions = ToOptions & {\n  unmaskOnReload?: boolean\n}\n\nToOptions\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "FileRoute class | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/FileRouteClass",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nFileRoute class\n\nCaution\n\nThis class has been deprecated and will be removed in the next major version of TanStack Router. Please use the createFileRoute function instead.\n\nThe FileRoute class is a factory that can be used to create a file-based route instance. This route instance can then be used to automatically generate a route tree with the tsr generate and tsr watch commands.\n\nFileRoute constructor\n\nThe FileRoute constructor accepts a single argument: the path of the file that the route will be generated for.\n\nConstructor options\nType: string literal\nRequired, but automatically inserted and updated by the tsr generate and tsr watch commands.\nThe full path of the file that the route will be generated from.\nConstructor returns\nAn instance of the FileRoute class that can be used to create a route.\nFileRoute methods\n\nThe FileRoute class implements the following method(s):\n\n.createRoute method\n\nThe createRoute method is a method that can be used to configure the file route instance. It accepts a single argument: the options that will be used to configure the file route instance.\n\n.createRoute options\nType: Omit<RouteOptions, 'getParentRoute' | 'path' | 'id'>\nRouteOptions\nOptional\nThe same options that are available to the Route class, but with the getParentRoute, path, and id options omitted since they are unnecessary for file-based routing.\n.createRoute returns\n\nA Route instance that can be used to configure the route to be inserted into the route-tree.\n\n‚ö†Ô∏è Note: For tsr generate and tsr watch to work properly, the file route instance must be exported from the file using the Route identifier.\n\nExamples\ntsx\nimport { FileRoute } from '@tanstack/react-router'\n\nexport const Route = new FileRoute('/').createRoute({\n  loader: () => {\n    return 'Hello World'\n  },\n  component: IndexComponent,\n})\n\nfunction IndexComponent() {\n  const data = Route.useLoaderData()\n  return <div>{data}</div>\n}\n\nEdit on GitHub\nOn this page\nFileRoute constructor\nConstructor options\nConstructor returns\nFileRoute methods\n.createRoute method\n.createRoute options\n.createRoute returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "ViewTransitionOptions type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/ViewTransitionOptionsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nViewTransitionOptions type\n\nThe ViewTransitionOptions type is used to define a viewTransition type.\n\ntsx\ninterface ViewTransitionOptions {\n  types: Array<string>\n}\n\nViewTransitionOptions properties\n\nThe ViewTransitionOptions type accepts an object with a single property:\n\ntypes property\nType: Array<string>\nRequired\nThe types array that will be passed to the document.startViewTransition({update, types}) call;\nEdit on GitHub\nOn this page\nViewTransitionOptions properties\ntypes property\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "UseMatchRouteOptions type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/UseMatchRouteOptionsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nUseMatchRouteOptions type\n\nThe UseMatchRouteOptions type extends the ToOptions type and describes additional options available when using the useMatchRoute hook.\n\ntsx\nexport type UseMatchRouteOptions = ToOptions & MatchRouteOptions\n\nToOptions\nMatchRouteOptions\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Router type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouter type\n\nThe Router type is used to describe a router instance.\n\nRouter properties and methods\n\nAn instance of the Router has the following properties and methods:\n\n.update method\nType: (newOptions: RouterOptions) => void\nUpdates the router instance with new options.\nstate property\nType: RouterState\nThe current state of the router.\n\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è router.state is always up to date, but NOT REACTIVE. If you use router.state in a component, the component will not re-render when the router state changes. To get a reactive version of the router state, use the useRouterState hook.\n\n.subscribe method\nType: (eventType: TType, fn: ListenerFn<RouterEvents[TType]>) => (event: RouterEvent) => void\nSubscribes to a RouterEvent.\nReturns a function that can be used to unsubscribe from the event.\nThe callback provided to the returned function will be called with the event that was emitted.\n.matchRoutes method\nType: (pathname: string, locationSearch: Record<string, any>, opts?: { throwOnError?: boolean; }) => RouteMatch[]\nMatches a pathname and search params against the router's route tree and returns an array of route matches.\nIf opts.throwOnError is true, any errors that occur during the matching process will be thrown (in addition to being returned in the route match's error property).\n.cancelMatch method\nType: (matchId: string) => void\nCancels a route match that is currently pending by calling match.abortController.abort().\n.cancelMatches method\nType: () => void\nCancels all route matches that are currently pending by calling match.abortController.abort() on each one.\n.buildLocation method\n\nBuilds a new parsed location object that can be used later to navigate to a new location.\n\nType: (opts: BuildNextOptions) => ParsedLocation\nProperties\nfrom\nType: string\nOptional\nThe path to navigate from. If not provided, the current path will be used.\nto\nType: string | number | null\nOptional\nThe path to navigate to. If null, the current path will be used.\nparams\nType: true | Updater<unknown>\nOptional\nIf true, the current params will be used. If a function is provided, it will be called with the current params and the return value will be used.\nsearch\nType: true | Updater<unknown>\nOptional\nIf true, the current search params will be used. If a function is provided, it will be called with the current search params and the return value will be used.\nhash\nType: true | Updater<string>\nOptional\nIf true, the current hash will be used. If a function is provided, it will be called with the current hash and the return value will be used.\nstate\nType: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\nOptional\nIf true, the current state will be used. If a function is provided, it will be called with the current state and the return value will be used.\nmask\nType: object\nOptional\nContains all of the same BuildNextOptions, with the addition of unmaskOnReload.\nunmaskOnReload\nType: boolean\nOptional\nIf true, the route mask will be removed when the page is reloaded. This can be overridden on a per-navigation basis by setting the unmaskOnReload option in the Navigate options.\n.commitLocation method\n\nCommits a new location object to the browser history.\n\nType\ntsx\ntype commitLocation = (\n  location: ParsedLocation & {\n    replace?: boolean\n    resetScroll?: boolean\n    hashScrollIntoView?: boolean | ScrollIntoViewOptions\n    ignoreBlocker?: boolean\n  },\n) => Promise<void>\n\nProperties\nlocation\nType: ParsedLocation\nRequired\nThe location to commit to the browser history.\nreplace\nType: boolean\nOptional\nDefaults to false.\nIf true, the location will be committed to the browser history using history.replace instead of history.push.\nresetScroll\nType: boolean\nOptional\nDefaults to true so that the scroll position will be reset to 0,0 after the location is committed to the browser history.\nIf false, the scroll position will not be reset to 0,0 after the location is committed to history.\nhashScrollIntoView\nType: boolean | ScrollIntoViewOptions\nOptional\nDefaults to true so the element with an id matching the hash will be scrolled into view after the location is committed to history.\nIf false, the element with an id matching the hash will not be scrolled into view after the location is committed to history.\nIf an object is provided, it will be passed to the scrollIntoView method as options.\nSee MDN for more information on ScrollIntoViewOptions.\nignoreBlocker\nType: boolean\nOptional\nDefaults to false.\nIf true, navigation will ignore any blockers that might prevent it.\n.navigate method\n\nNavigates to a new location.\n\nType\ntsx\ntype navigate = (options: NavigateOptions) => Promise<void>\n\n.invalidate method\n\nInvalidates route matches by forcing their beforeLoad and load functions to be called again.\n\nType: (opts?: {filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean, sync?: boolean}) => Promise<void>\nThis is useful any time your loader data might be out of date or stale. For example, if you have a route that displays a list of posts, and you have a loader function that fetches the list of posts from an API, you might want to invalidate the route matches for that route any time a new post is created so that the list of posts is always up-to-date.\nif filter is not supplied, all matches will be invalidated\nif filter is supplied, only matches for which filter returns true will be invalidated.\nif sync is true, the promise returned by this function will only resolve once all loaders have finished.\nYou might also want to invalidate the Router if you imperatively reset the router's CatchBoundary to trigger loaders again.\n.clearCache method\n\nRemove cached route matches.\n\nType: (opts?: {filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean}) => void\nif filter is not supplied, all cached matches will be removed\nif filter is supplied, only matches for which filter returns true will be removed.\n.load method\n\nLoads all of the currently matched route matches and resolves when they are all loaded and ready to be rendered.\n\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è router.load() respects route.staleTime and will not forcefully reload a route match if it is still fresh. If you need to forcefully reload a route match, use router.invalidate() instead.\n\nType: (opts?: {sync?: boolean}) => Promise<void>\nif sync is true, the promise returned by this function will only resolve once all loaders have finished.\nThe most common use case for this method is to call it when doing SSR to ensure that all of the critical data for the current route is loaded before attempting to stream or render the application to the client.\n.preloadRoute method\n\nPreloads all of the matches that match the provided NavigateOptions.\n\n‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Preloaded route matches are not stored long-term in the router state. They are only stored until the next attempted navigation action.\n\nType: (opts?: NavigateOptions) => Promise<RouteMatch[]>\nProperties\nopts\nType: NavigateOptions\nOptional, defaults to the current location.\nThe options that will be used to determine which route matches to preload.\nReturns\nA promise that resolves with an array of all of the route matches that were preloaded.\n.loadRouteChunk method\n\nLoads the JS chunk of the route.\n\nType: (route: AnyRoute) => Promise<void>\n.matchRoute method\n\nMatches a pathname and search params against the router's route tree and returns a route match's params or false if no match was found.\n\nType: (dest: ToOptions, matchOpts?: MatchRouteOptions) => RouteMatch['params'] | false\nProperties\ndest\nType: ToOptions\nRequired\nThe destination to match against.\nmatchOpts\nType: MatchRouteOptions\nOptional\nOptions that will be used to match the destination.\nReturns\nA route match's params if a match was found.\nfalse if no match was found.\n.dehydrate method\n\nDehydrates the router's critical state into a serializable object that can be sent to the client in an initial request.\n\nType: () => DehydratedRouter\nReturns\nA serializable object that contains the router's critical state.\n.hydrate method\n\nHydrates the router's critical state from a serializable object that was sent from the server in an initial request.\n\nType: (dehydrated: DehydratedRouter) => void\nProperties\ndehydrated\nType: DehydratedRouter\nRequired\nThe dehydrated router state that was sent from the server.\nEdit on GitHub\nOn this page\nRouter properties and methods\n.update method\nstate property\n.subscribe method\n.matchRoutes method\n.cancelMatch method\n.cancelMatches method\n.buildLocation method\n.commitLocation method\n.navigate method\n.invalidate method\n.clearCache method\n.load method\n.preloadRoute method\n.loadRouteChunk method\n.matchRoute method\n.dehydrate method\n.hydrate method\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouterState type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouterStateType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouterState type\n\nThe RouterState type represents shape of the internal state of the router. The Router's internal state is useful, if you need to access certain internals of the router, such as any pending matches, is the router in its loading state, etc.\n\ntsx\ntype RouterState = {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<RouteMatch>\n  pendingMatches: Array<RouteMatch>\n  location: ParsedLocation\n  resolvedLocation: ParsedLocation\n}\n\nRouterState properties\n\nThe RouterState type contains all of the properties that are available on the router state.\n\nstatus property\nType: 'pending' | 'idle'\nThe current status of the router. If the router is pending, it means that it is currently loading a route or the router is still transitioning to the new route.\nisLoading property\nType: boolean\ntrue if the router is currently loading a route or waiting for a route to finish loading.\nisTransitioning property\nType: boolean\ntrue if the router is currently transitioning to a new route.\nmatches property\nType: Array<RouteMatch>\nAn array of all of the route matches that have been resolved and are currently active.\npendingMatches property\nType: Array<RouteMatch>\nAn array of all of the route matches that are currently pending.\nlocation property\nType: ParsedLocation\nThe latest location that the router has parsed from the browser history. This location may not be resolved and loaded yet.\nresolvedLocation property\nType: ParsedLocation\nThe location that the router has resolved and loaded.\nEdit on GitHub\nOn this page\nRouterState properties\nstatus property\nisLoading property\nisTransitioning property\nmatches property\npendingMatches property\nlocation property\nresolvedLocation property\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouteOptions type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouteOptionsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouteOptions type\n\nThe RouteOptions type is used to describe the options that can be used when creating a route.\n\nRouteOptions properties\n\nThe RouteOptions type accepts an object with the following properties:\n\ngetParentRoute method\nType: () => TParentRoute\nRequired\nA function that returns the parent route of the route being created. This is required to provide full type safety to child route configurations and to ensure that the route tree is built correctly.\npath property\nType: string\nRequired, unless an id is provided to configure the route as a pathless layout route\nThe path segment that will be used to match the route.\nid property\nType: string\nOptional, but required if a path is not provided\nThe unique identifier for the route if it is to be configured as a pathless layout route. If provided, the route will not match against the location pathname and its routes will be flattened into its parent route for matching.\ncomponent property\nType: RouteComponent or LazyRouteComponent\nOptional - Defaults to <Outlet />\nThe content to be rendered when the route is matched.\nerrorComponent property\nType: RouteComponent or LazyRouteComponent\nOptional - Defaults to routerOptions.defaultErrorComponent\nThe content to be rendered when the route encounters an error.\npendingComponent property\nType: RouteComponent or LazyRouteComponent\nOptional - Defaults to routerOptions.defaultPendingComponent\nThe content to be rendered if and when the route is pending and has reached its pendingMs threshold.\nnotFoundComponent property\nType: NotFoundRouteComponent or LazyRouteComponent\nOptional - Defaults to routerOptions.defaultNotFoundComponent\nThe content to be rendered when the route is not found.\nvalidateSearch method\nType: (rawSearchParams: unknown) => TSearchSchema\nOptional\nA function that will be called when this route is matched and passed the raw search params from the current location and return valid parsed search params. If this function throws, the route will be put into an error state and the error will be thrown during render. If this function does not throw, its return value will be used as the route's search params and the return type will be inferred into the rest of the router.\nOptionally, the parameter type can be tagged with the SearchSchemaInput type like this: (searchParams: TSearchSchemaInput & SearchSchemaInput) => TSearchSchema. If this tag is present, TSearchSchemaInput will be used to type the search property of <Link /> and navigate() instead of TSearchSchema. The difference between TSearchSchemaInput and TSearchSchema can be useful, for example, to express optional search parameters.\nsearch.middlewares property\nType: (({search: TSearchSchema, next: (newSearch: TSearchSchema) => TSearchSchema}) => TSearchSchema)[]\nOptional\nSearch middlewares are functions that transform the search parameters when generating new links for a route or its descendants.\nA search middleware is passed in the current search (if it is the first middleware to run) or is invoked by the previous middleware calling next.\nparseParams method (‚ö†Ô∏è deprecated, use params.parse instead)\nType: (rawParams: Record<string, string>) => TParams\nOptional\nA function that will be called when this route is matched and passed the raw params from the current location and return valid parsed params. If this function throws, the route will be put into an error state and the error will be thrown during render. If this function does not throw, its return value will be used as the route's params and the return type will be inferred into the rest of the router.\nstringifyParams method (‚ö†Ô∏è deprecated, use params.stringify instead)\nType: (params: TParams) => Record<string, string>\nRequired if parseParams is provided\nA function that will be called when this route's parsed params are being used to build a location. This function should return a valid object of Record<string, string> mapping.\nparams.parse method\nType: (rawParams: Record<string, string>) => TParams\nOptional\nA function that will be called when this route is matched and passed the raw params from the current location and return valid parsed params. If this function throws, the route will be put into an error state and the error will be thrown during render. If this function does not throw, its return value will be used as the route's params and the return type will be inferred into the rest of the router.\nparams.stringify method\nType: (params: TParams) => Record<string, string>\nA function that will be called when this route's parsed params are being used to build a location. This function should return a valid object of Record<string, string> mapping.\nbeforeLoad method\nType:\ntsx\ntype beforeLoad = (\n  opts: RouteMatch & {\n    search: TFullSearchSchema\n    abortController: AbortController\n    preload: boolean\n    params: TAllParams\n    context: TParentContext\n    location: ParsedLocation\n    navigate: NavigateFn<AnyRoute> // @deprecated\n    buildLocation: BuildLocationFn<AnyRoute>\n    cause: 'enter' | 'stay'\n  },\n) => Promise<TRouteContext> | TRouteContext | void\n\nOptional\nParsedLocation\nThis async function is called before a route is loaded. If an error is thrown here, the route's loader will not be called and the route will not render. If thrown during a navigation, the navigation will be canceled and the error will be passed to the onError function. If thrown during a preload event, the error will be logged to the console and the preload will fail.\nIf this function returns a promise, the route will be put into a pending state and cause rendering to suspend until the promise resolves. If this route's pendingMs threshold is reached, the pendingComponent will be shown until it resolves. If the promise rejects, the route will be put into an error state and the error will be thrown during render.\nIf this function returns a TRouteContext object, that object will be merged into the route's context and be made available in the loader and other related route components/methods.\nIt's common to use this function to check if a user is authenticated and redirect them to a login page if they are not. To do this, you can either return or throw a redirect object from this function.\n\nüöß opts.navigate has been deprecated and will be removed in the next major release. Use throw redirect({ to: '/somewhere' }) instead. Read more about the redirect function here.\n\nloader method\nType:\ntsx\ntype loader = (\n  opts: RouteMatch & {\n    search: TFullSearchSchema\n    abortController: AbortController\n    preload: boolean\n    params: TAllParams\n    context: TAllContext\n    location: ParsedLocation\n    navigate: NavigateFn<AnyRoute> // @deprecated\n    buildLocation: BuildLocationFn<AnyRoute>\n    cause: 'enter' | 'stay'\n  },\n) => Promise<TLoaderData> | TLoaderData | void\n\nOptional\nParsedLocation\nThis async function is called when a route is matched and passed the route's match object. If an error is thrown here, the route will be put into an error state and the error will be thrown during render. If thrown during a navigation, the navigation will be canceled and the error will be passed to the onError function. If thrown during a preload event, the error will be logged to the console and the preload will fail.\nIf this function returns a promise, the route will be put into a pending state and cause rendering to suspend until the promise resolves. If this route's pendingMs threshold is reached, the pendingComponent will be shown until it resolves. If the promise rejects, the route will be put into an error state and the error will be thrown during render.\nIf this function returns a TLoaderData object, that object will be stored on the route match until the route match is no longer active. It can be accessed using the useLoaderData hook in any component that is a child of the route match before another <Outlet /> is rendered.\n\nüöß opts.navigate has been deprecated and will be removed in the next major release. Use throw redirect({ to: '/somewhere' }) instead. Read more about the redirect function here.\n\nloaderDeps method\nType:\ntsx\ntype loaderDeps = (opts: { search: TFullSearchSchema }) => Record<string, any>\n\nOptional\nA function that will be called before this route is matched to provide additional unique identification to the route match and serve as a dependency tracker for when the match should be reloaded. It should return any serializable value that can uniquely identify the route match from navigation to navigation.\nBy default, path params are already used to uniquely identify a route match, so it's unnecessary to return these here.\nIf your route match relies on search params for unique identification, it's required that you return them here so they can be made available in the loader's deps argument.\nstaleTime property\nType: number\nOptional\nDefaults to routerOptions.defaultStaleTime, which defaults to 0\nThe amount of time in milliseconds that a route match's loader data will be considered fresh. If a route match is matched again within this time frame, its loader data will not be reloaded.\npreloadStaleTime property\nType: number\nOptional\nDefaults to routerOptions.defaultPreloadStaleTime, which defaults to 30_000 ms (30 seconds)\nThe amount of time in milliseconds that a route match's loader data will be considered fresh when preloading. If a route match is preloaded again within this time frame, its loader data will not be reloaded. If a route match is loaded (for navigation) within this time frame, the normal staleTime is used instead.\ngcTime property\nType: number\nOptional\nDefaults to routerOptions.defaultGcTime, which defaults to 30 minutes.\nThe amount of time in milliseconds that a route match's loader data will be kept in memory after a preload or it is no longer in use.\nshouldReload property\nType: boolean | ((args: LoaderArgs) => boolean)\nOptional\nIf false or returns false, the route match's loader data will not be reloaded on subsequent matches.\nIf true or returns true, the route match's loader data will be reloaded on subsequent matches.\nIf undefined or returns undefined, the route match's loader data will adhere to the default stale-while-revalidate behavior.\ncaseSensitive property\nType: boolean\nOptional\nIf true, this route will be matched as case-sensitive.\nwrapInSuspense property\nType: boolean\nOptional\nIf true, this route will be forcefully wrapped in a suspense boundary, regardless if a reason is found to do so from inspecting its provided components.\npendingMs property\nType: number\nOptional\nDefaults to routerOptions.defaultPendingMs, which defaults to 1000\nThe threshold in milliseconds that a route must be pending before its pendingComponent is shown.\npendingMinMs property\nType: number\nOptional\nDefaults to routerOptions.defaultPendingMinMs which defaults to 500\nThe minimum amount of time in milliseconds that the pending component will be shown for if it is shown. This is useful to prevent the pending component from flashing on the screen for a split second.\npreloadMaxAge property\nType: number\nOptional\nDefaults to 30_000 ms (30 seconds)\nThe maximum amount of time in milliseconds that a route's preloaded route data will be cached for. If a route is not matched within this time frame, its loader data will be discarded.\npreSearchFilters property (‚ö†Ô∏è deprecated, use search.middlewares instead)\nType: ((search: TFullSearchSchema) => TFullSearchSchema)[]\nOptional\nAn array of functions that will be called when generating any new links to this route or its grandchildren.\nEach function will be called with the current search params and should return a new search params object that will be used to generate the link.\nIt has a pre prefix because it is called before the user-provided function that is passed to navigate/Link etc has a chance to modify the search params.\npostSearchFilters property (‚ö†Ô∏è deprecated, use search.middlewares instead)\nType: ((search: TFullSearchSchema) => TFullSearchSchema)[]\nOptional\nAn array of functions that will be called when generating any new links to this route or its grandchildren.\nEach function will be called with the current search params and should return a new search params object that will be used to generate the link.\nIt has a post prefix because it is called after the user-provided function that is passed to navigate/Link etc has modified the search params.\nonError property\nType: (error: any) => void\nOptional\nA function that will be called when an error is thrown during a navigation or preload event.\nIf this function throws a redirect, then the router will process and apply the redirect immediately.\nonEnter property\nType: (match: RouteMatch) => void\nOptional\nA function that will be called when a route is matched and loaded after not being matched in the previous location.\nonStay property\nType: (match: RouteMatch) => void\nOptional\nA function that will be called when a route is matched and loaded after being matched in the previous location.\nonLeave property\nType: (match: RouteMatch) => void\nOptional\nA function that will be called when a route is no longer matched after being matched in the previous location.\nonCatch property\nType: (error: Error, errorInfo: ErrorInfo) => void\nOptional - Defaults to routerOptions.defaultOnCatch\nA function that will be called when errors are caught when the route encounters an error.\nremountDeps method\nType:\ntsx\ntype remountDeps = (opts: RemountDepsOptions) => any\n\ninterface RemountDepsOptions<\n  in out TRouteId,\n  in out TFullSearchSchema,\n  in out TAllParams,\n  in out TLoaderDeps,\n> {\n  routeId: TRouteId\n  search: TFullSearchSchema\n  params: TAllParams\n  loaderDeps: TLoaderDeps\n}\n\nOptional\nA function that will be called to determine whether a route component shall be remounted after navigation. If this function returns a different value than previously, it will remount.\nThe return value needs to be JSON serializable.\nBy default, a route component will not be remounted if it stays active after a navigation.\n\nExample:\nIf you want to configure to remount a route component upon params change, use:\n\ntsx\nremountDeps: ({ params }) => params\n\nEdit on GitHub\nOn this page\nRouteOptions properties\ngetParentRoute method\npath property\nid property\ncomponent property\nerrorComponent property\npendingComponent property\nnotFoundComponent property\nvalidateSearch method\nsearch.middlewares property\nparseParams method (‚ö†Ô∏è deprecated, use params.parse instead)\nstringifyParams method (‚ö†Ô∏è deprecated, use params.stringify instead)\nparams.parse method\nparams.stringify method\nbeforeLoad method\nloader method\nloaderDeps method\nstaleTime property\npreloadStaleTime property\ngcTime property\nshouldReload property\ncaseSensitive property\nwrapInSuspense property\npendingMs property\npendingMinMs property\npreloadMaxAge property\npreSearchFilters property (‚ö†Ô∏è deprecated, use search.middlewares instead)\npostSearchFilters property (‚ö†Ô∏è deprecated, use search.middlewares instead)\nonError property\nonEnter property\nonStay property\nonLeave property\nonCatch property\nremountDeps method\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouterEvents type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouterEventsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouterEvents type\n\nThe RouterEvents type contains all of the events that the router can emit. Each top-level key of this type, represents the name of an event that the router can emit. The values of the keys are the event payloads.\n\ntsx\ntype RouterEvents = {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n    fromLocation?: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n    hrefChanged: boolean\n  }\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation?: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n    hrefChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation?: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n    hrefChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation?: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n    hrefChanged: boolean\n  }\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n    fromLocation?: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n    hrefChanged: boolean\n  }\n  onInjectedHtml: {\n    type: 'onInjectedHtml'\n    promise: Promise<string>\n  }\n  onRendered: {\n    type: 'onRendered'\n    fromLocation?: ParsedLocation\n    toLocation: ParsedLocation\n  }\n}\n\nRouterEvents properties\n\nOnce an event is emitted, the following properties will be present on the event payload.\n\ntype property\nType: onBeforeNavigate | onBeforeLoad | onLoad | onBeforeRouteMount | onResolved\nThe type of the event\nThis is useful for discriminating between events in a listener function.\nfromLocation property\nType: ParsedLocation\nThe location that the router is transitioning from.\ntoLocation property\nType: ParsedLocation\nThe location that the router is transitioning to.\npathChanged property\nType: boolean\ntrue if the path has changed between the fromLocation and toLocation.\nhrefChanged property\nType: boolean\ntrue if the href has changed between the fromLocation and toLocation.\nExample\ntsx\nimport { createRouter } from '@tanstack/react-router'\nimport { routeTree } from './routeTree.gen'\n\nconst router = createRouter({ routeTree })\n\nconst unsub = router.subscribe('onResolved', (evt) => {\n  // ...\n})\n\nEdit on GitHub\nOn this page\nRouterEvents properties\ntype property\nfromLocation property\ntoLocation property\npathChanged property\nhrefChanged property\nExample\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "ToOptions type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/ToOptionsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nToOptions type\n\nThe ToOptions type contains several properties that can be used to describe a router destination.\n\ntsx\ntype ToOptions = {\n  from?: ValidRoutePath | string\n  to?: ValidRoutePath | string\n  hash?: true | string | ((prev?: string) => string)\n  state?: true | HistoryState | ((prev: HistoryState) => HistoryState)\n} & SearchParamOptions &\n  PathParamOptions\n\ntype SearchParamOptions = {\n  search?: true | TToSearch | ((prev: TFromSearch) => TToSearch)\n}\n\ntype PathParamOptions = {\n  path?: true | Record<string, TPathParam> | ((prev: TFromParams) => TToParams)\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouteMatch type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouteMatchType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouteMatch type\n\nThe RouteMatch type represents a route match in TanStack Router.\n\ntsx\ninterface RouteMatch {\n  id: string\n  routeId: string\n  pathname: string\n  params: Route['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  showPending: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: Route['loaderData']\n  context: Route['allContext']\n  search: Route['fullSearchSchema']\n  fetchedAt: number\n  abortController: AbortController\n  cause: 'enter' | 'stay'\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Register type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RegisterType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRegister type\n\nThis type is used to register a route tree with a router instance. Doing so unlocks the full type safety of TanStack Router, including top-level exports from the @tanstack/react-router package.\n\ntsx\nexport type Register = {\n  // router: [Your router type here]\n}\n\n\nTo register a route tree with a router instance, use declaration merging to add the type of your router instance to the Register interface under the router property:\n\nExamples\ntsx\nconst router = createRouter({\n  // ...\n})\n\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: typeof router\n  }\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouteMask type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouteMaskType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouteMask type\n\nThe RouteMask type extends the ToOptions type and has other the necessary properties to create a route mask.\n\nRouteMask properties\n\nThe RouteMask type accepts an object with the following properties:\n\n...ToOptions\nType: ToOptions\nRequired\nThe options that will be used to configure the route mask\noptions.routeTree\nType: TRouteTree\nRequired\nThe route tree that this route mask will support\noptions.unmaskOnReload\nType: boolean\nOptional\nIf true, the route mask will be removed when the page is reloaded\nEdit on GitHub\nOn this page\nRouteMask properties\n...ToOptions\noptions.routeTree\noptions.unmaskOnReload\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Redirect type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRedirect type\n\nThe Redirect type is used to represent a redirect action in TanStack Router.\n\ntsx\nexport type Redirect = {\n  statusCode?: number\n  throw?: any\n  headers?: HeadersInit\n} & NavigateOptions\n\nNavigateOptions\nRedirect properties\n\nThe Redirect object accepts/contains the following properties:\n\nstatusCode property\nType: number\nOptional\nThe HTTP status code to use when redirecting\nthrow property\nType: any\nOptional\nIf provided, will throw the redirect object instead of returning it. This can be useful in places where throwing in a function might cause it to have a return type of never. In that case, you can use redirect({ throw: true }) to throw the redirect object instead of returning it.\nheaders property\nType: HeadersInit\nOptional\nThe HTTP headers to use when redirecting.\nEdit on GitHub\nOn this page\nRedirect properties\nstatusCode property\nthrow property\nheaders property\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouteApi Type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouteApiType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouteApi Type\n\nThe RouteApi describes an instance that provides type-safe versions of common hooks like useParams, useSearch, useRouteContext, useNavigate, useLoaderData, and useLoaderDeps that are pre-bound to a specific route ID and corresponding registered route types.\n\nRouteApi properties and methods\n\nThe RouteApi has the following properties and methods:\n\nuseMatch method\ntsx\n  useMatch<TSelected = TAllContext>(opts?: {\n    select?: (match: TAllContext) => TSelected\n  }): TSelected\n\nA type-safe version of the useMatch hook that is pre-bound to the route ID that the RouteApi instance was created with.\nOptions\nopts.select\nOptional\n(match: RouteMatch) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useMatch. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing\nOptional\nboolean\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nReturns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the RouteMatch object or a loosened version of the RouteMatch object if opts.strict is false.\nuseRouteContext method\ntsx\n  useRouteContext<TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected\n\nA type-safe version of the useRouteContext hook that is pre-bound to the route ID that the RouteApi instance was created with.\nOptions\nopts.select\nOptional\n(match: RouteContext) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useRouteContext. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nReturns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the RouteContext object or a loosened version of the RouteContext object if opts.strict is false.\nuseSearch method\ntsx\n  useSearch<TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected\n\nA type-safe version of the useSearch hook that is pre-bound to the route ID that the RouteApi instance was created with.\nOptions\nopts.select\nOptional\n(match: TFullSearchSchema) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useSearch. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing\nOptional\nboolean\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nReturns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the TFullSearchSchema object or a loosened version of the TFullSearchSchema object if opts.strict is false.\nuseParams method\ntsx\n  useParams<TSelected = TAllParams>(opts?: {\n    select?: (params: TAllParams) => TSelected\n  }): TSelected\n\nA type-safe version of the useParams hook that is pre-bound to the route ID that the RouteApi instance was created with.\nOptions\nopts.select\nOptional\n(match: TAllParams) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useParams. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing\nOptional\nboolean\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nReturns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the TAllParams object or a loosened version of the TAllParams object if opts.strict is false.\nuseLoaderData method\ntsx\n  useLoaderData<TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected\n\nA type-safe version of the useLoaderData hook that is pre-bound to the route ID that the RouteApi instance was created with.\nOptions\nopts.select\nOptional\n(match: TLoaderData) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useLoaderData. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing\nOptional\nboolean\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nReturns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the TLoaderData object or a loosened version of the TLoaderData object if opts.strict is false.\nuseLoaderDeps method\ntsx\n  useLoaderDeps<TSelected = TLoaderDeps>(opts?: {\n    select?: (search: TLoaderDeps) => TSelected\n  }): TSelected\n\nA type-safe version of the useLoaderDeps hook that is pre-bound to the route ID that the RouteApi instance was created with.\nOptions\nopts.select\nOptional\n(match: TLoaderDeps) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useLoaderDeps.\nopts.structuralSharing\nOptional\nboolean\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nReturns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the TLoaderDeps object.\nuseNavigate method\ntsx\n  useNavigate(): // navigate function\n\nA type-safe version of useNavigate that is pre-bound to the route ID that the RouteApi instance was created with.\nEdit on GitHub\nOn this page\nRouteApi properties and methods\nuseMatch method\nuseRouteContext method\nuseSearch method\nuseParams method\nuseLoaderData method\nuseLoaderDeps method\nuseNavigate method\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Route type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouteType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRoute type\n\nThe Route type is used to describe a route instance.\n\nRoute properties and methods\n\nAn instance of the Route has the following properties and methods:\n\n.addChildren method\nType: (children: Route[]) => this\nAdds child routes to the route instance and returns the route instance (but with updated types to reflect the new children).\n.update method\nType: (options: Partial<UpdatableRouteOptions>) => this\nUpdates the route instance with new options and returns the route instance (but with updated types to reflect the new options).\nIn some circumstances, it can be useful to update a route instance's options after it has been created to avoid circular type references.\n...RouteApi methods\n.lazy method\nType: (lazyImporter: () => Promise<Partial<UpdatableRouteOptions>>) => this\nUpdates the route instance with a new lazy importer which will be resolved lazily when loading the route. This can be useful for code splitting.\n...RouteApi methods\nAll of the methods from RouteApi are available.\nEdit on GitHub\nOn this page\nRoute properties and methods\n.addChildren method\n.update method\n.lazy method\n...RouteApi methods\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "ParsedLocation type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/ParsedLocationType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nParsedLocation type\n\nThe ParsedLocation type represents a parsed location in TanStack Router. It contains a lot of useful information about the current location, including the pathname, search params, hash, location state, and route masking information.\n\ntsx\ninterface ParsedLocation {\n  href: string\n  pathname: string\n  search: TFullSearchSchema\n  searchStr: string\n  state: ParsedHistoryState\n  hash: string\n  maskedLocation?: ParsedLocation\n  unmaskOnReload?: boolean\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "ParsedHistoryState type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/ParsedHistoryStateType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nParsedHistoryState type\n\nThe ParsedHistoryState type represents a parsed state object. Additionally to HistoryState, it contains the index and the unique key of the route.\n\ntsx\nexport type ParsedHistoryState = HistoryState & {\n  key?: string\n  __TSR_index: number\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useRouterState hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useRouterStateHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseRouterState hook\n\nThe useRouterState method is a hook that returns the current internal state of the router. This hook is useful for accessing the current state of the router in a component.\n\nTip\n\nIf you want to access the current location or the current matches, you should try out the useLocation and useMatches hooks first. These hooks are designed to be more ergonomic and easier to use than accessing the router state directly.\n\nuseRouterState options\n\nThe useRouterState hook accepts an optional options object.\n\nopts.select option\nType: (state: RouterState) => TSelected\nOptional\nIf supplied, this function will be called with the RouterState object and the return value will be returned from useRouterState.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nuseRouterState returns\nThe current RouterState object or TSelected if a select function is provided.\nExamples\ntsx\nimport { useRouterState } from '@tanstack/react-router'\n\nfunction Component() {\n  const state = useRouterState()\n  //    ^ RouterState\n\n  // OR\n\n  const selected = useRouterState({\n    select: (state) => state.location,\n  })\n  //    ^ ParsedLocation\n\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseRouterState options\nopts.select option\nopts.structuralSharing option\nuseRouterState returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "HistoryState interface | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/historyStateInterface",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nHistoryState interface\n\nThe HistoryState interface is an interface exported by the history package that describes the shape of the state object that can be used in conjunction with the history package and the window.location API.\n\nYou can extend this interface to add additional properties to the state object across your application.\n\ntsx\n// src/main.tsx\ndeclare module '@tanstack/react-router' {\n  // ...\n\n  interface HistoryState {\n    additionalRequiredProperty: number\n    additionalProperty?: string\n  }\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "AsyncRouteComponent type | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/AsyncRouteComponentType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nAsyncRouteComponent type\n\nThe AsyncRouteComponent type is used to describe a code-split route component that can be preloaded using a component.preload() method.\n\ntsx\ntype AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useRouteContext hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useRouteContextHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseRouteContext hook\n\nThe useRouteContext method is a hook that returns the current context for the current route. This hook is useful for accessing the current route context in a component.\n\nuseRouteContext options\n\nThe useRouteContext hook accepts an options object.\n\nopts.from option\nType: string\nRequired\nThe RouteID to match the route context from.\nopts.select option\nType: (context: RouteContext) => TSelected\nOptional\nIf supplied, this function will be called with the route context object and the return value will be returned from useRouteContext.\nuseRouteContext returns\nThe current context for the current route or TSelected if a select function is provided.\nExamples\ntsx\nimport { useRouteContext } from '@tanstack/react-router'\n\nfunction Component() {\n  const context = useRouteContext({ from: '/posts/$postId' })\n  //    ^ RouteContext\n\n  // OR\n\n  const selected = useRouteContext({\n    from: '/posts/$postId',\n    select: (context) => context.postId,\n  })\n  //    ^ string\n\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseRouteContext options\nopts.from option\nopts.select option\nuseRouteContext returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useParentMatches hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useParentMatchesHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseParentMatches hook\n\nThe useParentMatches hook returns all of the parent RouteMatch objects from the root down to the immediate parent of the current match in context. It does not include the current match, which can be obtained using the useMatch hook.\n\nImportant\n\nIf the router has pending matches and they are showing their pending component fallbacks, router.state.pendingMatches will used instead of router.state.matches.\n\nuseParentMatches options\n\nThe useParentMatches hook accepts an optional options object.\n\nopts.select option\nOptional\n(matches: RouteMatch[]) => TSelected\nIf supplied, this function will be called with the route matches and the return value will be returned from useParentMatches. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nuseParentMatches returns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, an array of RouteMatch objects.\nExamples\ntsx\nimport { useParentMatches } from '@tanstack/react-router'\n\nfunction Component() {\n  const parentMatches = useParentMatches()\n  //    ^ [RouteMatch, RouteMatch, ...]\n}\n\nEdit on GitHub\nOn this page\nuseParentMatches options\nopts.select option\nopts.structuralSharing option\nuseParentMatches returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useNavigate hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useNavigateHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseNavigate hook\n\nThe useNavigate hook is a hook that returns a navigate function that can be used to navigate to a new location. This includes changes to the pathname, search params, hash, and location state.\n\nuseNavigate options\n\nThe useNavigate hook accepts a single argument, an options object.\n\nopts.from option\nType: string\nOptional\nDescription: The location to navigate from. This is useful when you want to navigate to a new location from a specific location, rather than the current location.\nuseNavigate returns\nA navigate function that can be used to navigate to a new location.\nnavigate function\n\nThe navigate function is a function that can be used to navigate to a new location.\n\nnavigate function options\n\nThe navigate function accepts a single argument, an options object.\n\nType: NavigateOptions\nnavigate function returns\nA Promise that resolves when the navigation is complete\nExamples\ntsx\nimport { useNavigate } from '@tanstack/react-router'\n\nfunction PostsPage() {\n  const navigate = useNavigate({ from: '/posts' })\n  const handleClick = () => navigate({ search: { page: 2 } })\n  // ...\n}\n\nfunction Component() {\n  const navigate = useNavigate()\n  return (\n    <div>\n      <button\n        onClick={() =>\n          navigate({\n            to: '/posts',\n          })\n        }\n      >\n        Posts\n      </button>\n      <button\n        onClick={() =>\n          navigate({\n            to: '/posts',\n            search: { page: 2 },\n          })\n        }\n      >\n        Posts (Page 2)\n      </button>\n      <button\n        onClick={() =>\n          navigate({\n            to: '/posts',\n            hash: 'my-hash',\n          })\n        }\n      >\n        Posts (Hash)\n      </button>\n      <button\n        onClick={() =>\n          navigate({\n            to: '/posts',\n            state: { from: 'home' },\n          })\n        }\n      >\n        Posts (State)\n      </button>\n    </div>\n  )\n}\n\nEdit on GitHub\nOn this page\nuseNavigate options\nopts.from option\nuseNavigate returns\nnavigate function\nnavigate function options\nnavigate function returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useLoaderDeps hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useLoaderDepsHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseLoaderDeps hook\n\nThe useLoaderDeps hook is a hook that returns an object with the dependencies that are used to trigger the loader for a given route.\n\nuseLoaderDepsHook options\n\nThe useLoaderDepsHook hook accepts an options object.\n\nopts.from option\nType: string\nRequired\nThe RouteID or path to get the loader dependencies from.\nopts.select option\nType: (deps: TLoaderDeps) => TSelected\nOptional\nIf supplied, this function will be called with the loader dependencies object and the return value will be returned from useLoaderDeps.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nuseLoaderDeps returns\nAn object of the loader dependencies or TSelected if a select function is provided.\nExamples\ntsx\nimport { useLoaderDeps } from '@tanstack/react-router'\n\nconst routeApi = getRouteApi('/posts/$postId')\n\nfunction Component() {\n  const deps = useLoaderDeps({ from: '/posts/$postId' })\n\n  // OR\n\n  const routeDeps = routeApi.useLoaderDeps()\n\n  // OR\n\n  const postId = useLoaderDeps({\n    from: '/posts',\n    select: (deps) => deps.view,\n  })\n\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseLoaderDepsHook options\nopts.from option\nopts.select option\nopts.structuralSharing option\nuseLoaderDeps returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useMatches hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchesHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseMatches hook\n\nThe useMatches hook returns all of the RouteMatch objects from the router regardless of its callers position in the React component tree.\n\nTip\n\nIf you only want the parent or child matches, then you can use the useParentMatches or the useChildMatches based on the selection you need.\n\nuseMatches options\n\nThe useMatches hook accepts a single optional argument, an options object.\n\nopts.select option\nOptional\n(matches: RouteMatch[]) => TSelected\nIf supplied, this function will be called with the route matches and the return value will be returned from useMatches. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nuseMatches returns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, an array of RouteMatch objects.\nExamples\ntsx\nimport { useMatches } from '@tanstack/react-router'\n\nfunction Component() {\n  const matches = useMatches()\n  //     ^? [RouteMatch, RouteMatch, ...]\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseMatches options\nopts.select option\nopts.structuralSharing option\nuseMatches returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useLocation hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useLocationHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseLocation hook\n\nThe useLocation method is a hook that returns the current location object. This hook is useful for when you want to perform some side effect whenever the current location changes.\n\nuseLocation options\n\nThe useLocation hook accepts an optional options object.\n\nopts.select option\nType: (state: ParsedLocationType) => TSelected\nOptional\nIf supplied, this function will be called with the location object and the return value will be returned from useLocation.\nuseLocation returns\nThe current location object or TSelected if a select function is provided.\nExamples\ntsx\nimport { useLocation } from '@tanstack/react-router'\n\nfunction Component() {\n  const location = useLocation()\n  //    ^ ParsedLocation\n\n  // OR\n\n  const pathname = useLocation({\n    select: (location) => location.pathname,\n  })\n  //    ^ string\n\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseLocation options\nopts.select option\nuseLocation returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useMatch hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseMatch hook\n\nThe useMatch hook returns a RouteMatch in the component tree. The raw route match contains all of the information about a route match in the router and also powers many other hooks under the hood like useParams, useLoaderData, useRouteContext, and useSearch.\n\nuseMatch options\n\nThe useMatch hook accepts a single argument, an options object.\n\nopts.from option\nType: string\nThe route id of a match\nOptional, but recommended for full type safety.\nIf opts.strict is true, from is required and TypeScript will warn for this option if it is not provided.\nIf opts.strict is false, from must not be set and TypeScript will provided loosened types for the returned RouteMatch.\nopts.strict option\nType: boolean\nOptional\ndefault: true\nIf false, the opts.from must not be set and types will be loosened to Partial<RouteMatch> to reflect the shared types of all matches.\nopts.select option\nOptional\n(match: RouteMatch) => TSelected\nIf supplied, this function will be called with the route match and the return value will be returned from useMatch. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nopts.shouldThrow option\nType: boolean\nOptional\ndefault: true\nIf false,useMatch will not throw an invariant exception in case a match was not found in the currently rendered matches; in this case, it will return undefined.\nuseMatch returns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the RouteMatch object or a loosened version of the RouteMatch object if opts.strict is false.\nExamples Accessing a route match\ntsx\nimport { useMatch } from '@tanstack/react-router'\n\nfunction Component() {\n  const match = useMatch({ from: '/posts/$postId' })\n  //     ^? strict match for RouteMatch\n  // ...\n}\n\nAccessing the root route's match\ntsx\nimport {\n  useMatch,\n  rootRouteId, // <<<< use this token!\n} from '@tanstack/react-router'\n\nfunction Component() {\n  const match = useMatch({ from: rootRouteId })\n  //     ^? strict match for RouteMatch\n  // ...\n}\n\nChecking if a specific route is currently rendered\ntsx\nimport { useMatch } from '@tanstack/react-router'\n\nfunction Component() {\n  const match = useMatch({ from: '/posts', shouldThrow: false })\n  //     ^? RouteMatch | undefined\n  if (match !== undefined) {\n    // ...\n  }\n}\n\nEdit on GitHub\nOn this page\nuseMatch options\nopts.from option\nopts.strict option\nopts.select option\nopts.structuralSharing option\nopts.shouldThrow option\nuseMatch returns\nExamples\nAccessing a route match\nAccessing the root route's match\nChecking if a specific route is currently rendered\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useLoaderData hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useLoaderDataHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseLoaderData hook\n\nThe useLoaderData hook returns the loader data from the closest RouteMatch in the component tree.\n\nuseLoaderData options\n\nThe useLoaderData hook accepts an options object.\n\nopts.from option\nType: string\nThe route id of the closest parent match\nOptional, but recommended for full type safety.\nIf opts.strict is true, TypeScript will warn for this option if it is not provided.\nIf opts.strict is false, TypeScript will provided loosened types for the returned loader data.\nopts.strict option\nType: boolean\nOptional - default: true\nIf false, the opts.from option will be ignored and types will be loosened to to reflect the shared types of all possible loader data.\nopts.select option\nOptional\n(loaderData: TLoaderData) => TSelected\nIf supplied, this function will be called with the loader data and the return value will be returned from useLoaderData. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nuseLoaderData returns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, the loader data or a loosened version of the loader data if opts.strict is false.\nExamples\ntsx\nimport { useLoaderData } from '@tanstack/react-router'\n\nfunction Component() {\n  const loaderData = useLoaderData({ from: '/posts/$postId' })\n  //     ^? { postId: string, body: string, ... }\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseLoaderData options\nopts.from option\nopts.strict option\nopts.select option\nopts.structuralSharing option\nuseLoaderData returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useMatchRoute hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useMatchRouteHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseMatchRoute hook\n\nThe useMatchRoute hook is a hook that returns a matchRoute function that can be used to match a route against either the current or pending location.\n\nuseMatchRoute returns\nA matchRoute function that can be used to match a route against either the current or pending location.\nmatchRoute function\n\nThe matchRoute function is a function that can be used to match a route against either the current or pending location.\n\nmatchRoute function options\n\nThe matchRoute function accepts a single argument, an options object.\n\nType: UseMatchRouteOptions\nmatchRoute function returns\nThe matched route's params or false if no route was matched\nExamples\ntsx\nimport { useMatchRoute } from '@tanstack/react-router'\n\n// Current location: /posts/123\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({ to: '/posts/$postId' })\n  //    ^ { postId: '123' }\n}\n\n// Current location: /posts/123\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({ to: '/posts' })\n  //    ^ false\n}\n\n// Current location: /posts/123\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({ to: '/posts', fuzzy: true })\n  //    ^ {}\n}\n\n// Current location: /posts\n// Pending location: /posts/123\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({ to: '/posts/$postId', pending: true })\n  //    ^ { postId: '123' }\n}\n\n// Current location: /posts/123/foo/456\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({ to: '/posts/$postId/foo/$fooId' })\n  //    ^ { postId: '123', fooId: '456' }\n}\n\n// Current location: /posts/123/foo/456\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({\n    to: '/posts/$postId/foo/$fooId',\n    params: { postId: '123' },\n  })\n  //    ^ { postId: '123', fooId: '456' }\n}\n\n// Current location: /posts/123/foo/456\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({\n    to: '/posts/$postId/foo/$fooId',\n    params: { postId: '789' },\n  })\n  //    ^ false\n}\n\n// Current location: /posts/123/foo/456\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({\n    to: '/posts/$postId/foo/$fooId',\n    params: { fooId: '456' },\n  })\n  //    ^ { postId: '123', fooId: '456' }\n}\n\n// Current location: /posts/123/foo/456\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({\n    to: '/posts/$postId/foo/$fooId',\n    params: { postId: '123', fooId: '456' },\n  })\n  //    ^ { postId: '123', fooId: '456' }\n}\n\n// Current location: /posts/123/foo/456\nfunction Component() {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute({\n    to: '/posts/$postId/foo/$fooId',\n    params: { postId: '789', fooId: '456' },\n  })\n  //    ^ false\n}\n\nEdit on GitHub\nOn this page\nuseMatchRoute returns\nmatchRoute function\nmatchRoute function options\nmatchRoute function returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useChildMatches hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useChildMatchesHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseChildMatches hook\n\nThe useChildMatches hook returns all of the child RouteMatch objects from the closest match down to the leaf-most match. It does not include the current match, which can be obtained using the useMatch hook.\n\nImportant\n\nIf the router has pending matches and they are showing their pending component fallbacks, router.state.pendingMatches will used instead of router.state.matches.\n\nuseChildMatches options\n\nThe useChildMatches hook accepts a single optional argument, an options object.\n\nopts.select option\nOptional\n(matches: RouteMatch[]) => TSelected\nIf supplied, this function will be called with the route matches and the return value will be returned from useChildMatches. This value will also be used to determine if the hook should re-render its parent component using shallow equality checks.\nopts.structuralSharing option\nType: boolean\nOptional\nConfigures whether structural sharing is enabled for the value returned by select.\nSee the Render Optimizations guide for more information.\nuseChildMatches returns\nIf a select function is provided, the return value of the select function.\nIf no select function is provided, an array of RouteMatch objects.\nExamples\ntsx\nimport { useChildMatches } from '@tanstack/react-router'\n\nfunction Component() {\n  const childMatches = useChildMatches()\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseChildMatches options\nopts.select option\nopts.structuralSharing option\nuseChildMatches returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useLinkProps hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useLinkPropsHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseLinkProps hook\n\nThe useLinkProps hook that takes an object as its argument and returns a React.AnchorHTMLAttributes<HTMLAnchorElement> props object. These props can then be safely applied to an anchor element to create a link that can be used to navigate to the new location. This includes changes to the pathname, search params, hash, and location state.\n\nuseLinkProps options\ntsx\ntype UseLinkPropsOptions = ActiveLinkOptions &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nActiveLinkOptions\nThe useLinkProps options are used to build a LinkProps object.\nIt also extends the React.AnchorHTMLAttributes<HTMLAnchorElement> type, so that any additional props that are passed to the useLinkProps hook will be merged with the LinkProps object.\nuseLinkProps returns\nA React.AnchorHTMLAttributes<HTMLAnchorElement> object that can be applied to an anchor element to create a link that can be used to navigate to the new location\nEdit on GitHub\nOn this page\nuseLinkProps options\nuseLinkProps returns\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useAwaited hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useAwaitedHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseAwaited hook\n\nThe useAwaited method is a hook that suspends until the provided promise is resolved or rejected.\n\nuseAwaited options\n\nThe useAwaited hook accepts a single argument, an options object.\n\noptions.promise option\nType: Promise<T>\nRequired\nThe deferred promise to await.\nuseAwaited returns\nThrows an error if the promise is rejected.\nSuspends (throws a promise) if the promise is pending.\nReturns the resolved value of a deferred promise if the promise is resolved.\nExamples\ntsx\nimport { useAwaited } from '@tanstack/react-router'\n\nfunction Component() {\n  const { deferredPromise } = route.useLoaderData()\n\n  const data = useAwaited({ promise: myDeferredPromise })\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseAwaited options\noptions.promise option\nuseAwaited returns\nExamples\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useCanGoBack hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useCanGoBack",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseCanGoBack hook\n\nThe useCanGoBack hook returns a boolean representing if the router history can safely go back without exiting the application.\n\n‚ö†Ô∏è The following new useCanGoBack API is currently experimental.\n\nuseCanGoBack returns\nIf the router history is not at index 0, true.\nIf the router history is at index 0, false.\nLimitations\n\nThe router history index is reset after a navigation with reloadDocument set as true. This causes the router history to consider the new location as the initial one and will cause useCanGoBack to return false.\n\nExamples Showing a back button\ntsx\nimport { useRouter, useCanGoBack } from '@tanstack/react-router'\n\nfunction Component() {\n  const router = useRouter()\n  const canGoBack = useCanGoBack()\n\n  return (\n    <div>\n      {canGoBack ? (\n        <button onClick={() => router.history.back()}>Go back</button>\n      ) : null}\n\n      {/* ... */}\n    </div>\n  )\n}\n\nEdit on GitHub\nOn this page\nuseCanGoBack returns\nLimitations\nExamples\nShowing a back button\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "useBlocker hook | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/useBlockerHook",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nuseBlocker hook\n\nThe useBlocker method is a hook that blocks navigation when a condition is met.\n\n‚ö†Ô∏è The following new useBlocker API is currently experimental.\n\nuseBlocker options\n\nThe useBlocker hook accepts a single required argument, an option object:\n\noptions.shouldBlockFn option\nRequired\nType: ShouldBlockFn\nThis function should return a boolean or a Promise<boolean> that tells the blocker if it should block the current navigation\nThe function has the argument of type ShouldBlockFnArgs passed to it, which tells you information about the current and next route and the action performed\nThink of this function as telling the router if it should block the navigation, so returning true mean that it should block the navigation and false meaning that it should be allowed\nts\ninterface ShouldBlockFnLocation<...> {\n  routeId: TRouteId\n  fullPath: TFullPath\n  pathname: string\n  params: TAllParams\n  search: TFullSearchSchema\n}\n\ntype ShouldBlockFnArgs = {\n  current: ShouldBlockFnLocation\n  next: ShouldBlockFnLocation\n  action: HistoryAction\n}\n\noptions.disabled option\nOptional - defaults to false\nType: boolean\nSpecifies if the blocker should be entirely disabled or not\noptions.enableBeforeUnload option\nOptional - defaults to true\nType: boolean | (() => boolean)\nTell the blocker to sometimes or always block the browser beforeUnload event or not\noptions.withResolver option\nOptional - defaults to false\nType: boolean\nSpecify if the resolver returned by the hook should be used or whether your shouldBlockFn function itself resolves the blocking\noptions.blockerFn option (‚ö†Ô∏è deprecated)\nOptional\nType: BlockerFn\nThe function that returns a boolean or Promise<boolean> indicating whether to allow navigation.\noptions.condition option (‚ö†Ô∏è deprecated)\nOptional - defaults to true\nType: boolean\nA navigation attempt is blocked when this condition is true.\nuseBlocker returns\n\nAn object with the controls to allow manual blocking and unblocking of navigation.\n\nstatus - A string literal that can be either 'blocked' or 'idle'\nnext - When status is blocked, a type narrrowable object that contains information about the next location\ncurrent - When status is blocked, a type narrrowable object that contains information about the current location\naction - When status is blocked, a HistoryAction string that shows the action that triggered the navigation\nproceed - When status is blocked, a function that allows navigation to continue\nreset - When status is blocked, a function that cancels navigation (status will be reset to 'idle')\n\nor\n\nvoid when withResolver is false\n\nExamples\n\nTwo common use cases for the useBlocker hook are:\n\nBasic usage\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  useBlocker({\n    shouldBlockFn: () => formIsDirty,\n  })\n\n  // ...\n}\n\nCustom UI\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  const { proceed, reset, status, next } = useBlocker({\n    shouldBlockFn: () => formIsDirty,\n    withResolver: true,\n  })\n\n  // ...\n\n  return (\n    <>\n      {/* ... */}\n      {status === 'blocked' && (\n        <div>\n          <p>You are navigating to {next.pathname}</p>\n          <p>Are you sure you want to leave?</p>\n          <button onClick={proceed}>Yes</button>\n          <button onClick={reset}>No</button>\n        </div>\n      )}\n    </>\n}\n\nConditional blocking\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const { proceed, reset, status } = useBlocker({\n    shouldBlockFn: ({ next }) => {\n      return !next.pathname.includes('step/')\n    },\n    withResolver: true,\n  })\n\n  // ...\n\n  return (\n    <>\n      {/* ... */}\n      {status === 'blocked' && (\n        <div>\n          <p>Are you sure you want to leave?</p>\n          <button onClick={proceed}>Yes</button>\n          <button onClick={reset}>No</button>\n        </div>\n      )}\n    </>\n  )\n}\n\nWithout resolver\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  useBlocker({\n    shouldBlockFn: ({ next }) => {\n      if (next.pathname.includes('step/')) {\n        return false\n      }\n\n      const shouldLeave = confirm('Are you sure you want to leave?')\n      return !shouldLeave\n    },\n  })\n\n  // ...\n}\n\nType narrowing\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  // block going from editor-1 to /foo/123?hello=world\n  const { proceed, reset, status } = useBlocker({\n    shouldBlockFn: ({ current, next }) => {\n      if (\n        current.routeId === '/editor-1' &&\n        next.fullPath === '/foo/$id' &&\n        next.params.id === '123' &&\n        next.search.hello === 'world'\n      ) {\n        return true\n      }\n      return false\n    },\n    enableBeforeUnload: false,\n    withResolver: true,\n  })\n\n  // ...\n}\n\nEdit on GitHub\nOn this page\nuseBlocker options\noptions.shouldBlockFn option\noptions.disabled option\noptions.enableBeforeUnload option\noptions.withResolver option\noptions.blockerFn option (‚ö†Ô∏è deprecated)\noptions.condition option (‚ö†Ô∏è deprecated)\nuseBlocker returns\nExamples\nBasic usage\nCustom UI\nConditional blocking\nWithout resolver\nType narrowing\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Navigate component | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/navigateComponent",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nNavigate component\n\nThe Navigate component is a component that can be used to navigate to a new location when rendered. This includes changes to the pathname, search params, hash, and location state. The underlying navigation will happen inside of a useEffect hook when successfully rendered.\n\nNavigate props\n\nThe Navigate component accepts the following props:\n\n...options\nType: NavigateOptions\nNavigate returns\nnull\nEdit on GitHub\nOn this page\nNavigate props\n...options\nNavigate returns\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Outlet component | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/outletComponent",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nOutlet component\n\nThe Outlet component is a component that can be used to render the next child route of a parent route.\n\nOutlet props\n\nThe Outlet component does not accept any props.\n\nOutlet returns\nIf matched, the child route match's component/errorComponent/pendingComponent/notFoundComponent.\nIf not matched, null.\nEdit on GitHub\nOn this page\nOutlet props\nOutlet returns\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "CatchBoundary component | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/catchBoundaryComponent",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nCatchBoundary component\n\nThe CatchBoundary component is a component that catches errors thrown by its children, renders an error component and optionally calls the onCatch callback. It also accepts a getResetKey function that can be used to declaratively reset the component's state when the key changes.\n\nCatchBoundary props\n\nThe CatchBoundary component accepts the following props:\n\nprops.getResetKey prop\nType: () => string\nRequired\nA function that returns a string that will be used to reset the component's state when the key changes.\nprops.children prop\nType: React.ReactNode\nRequired\nThe component's children to render when there is no error\nprops.errorComponent prop\nType: React.ReactNode\nOptional - default: ErrorComponent\nThe component to render when there is an error.\nprops.onCatch prop\nType: (error: any) => void\nOptional\nA callback that will be called with the error that was thrown by the component's children.\nCatchBoundary returns\nReturns the component's children if there is no error.\nReturns the errorComponent if there is an error.\nExamples\ntsx\nimport { CatchBoundary } from '@tanstack/react-router'\n\nfunction Component() {\n  return (\n    <CatchBoundary\n      getResetKey={() => 'reset'}\n      onCatch={(error) => console.error(error)}\n    >\n      <div>My Component</div>\n    </CatchBoundary>\n  )\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Link options | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/linkOptions",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nLink options\n\nlinkOptions is a function which type checks an object literal with the intention of being used for Link, navigate or redirect\n\nlinkOptions props\n\nThe linkOptions accepts the following option:\n\n...props\nType: LinkProps & React.RefAttributes<HTMLAnchorElement>\nLinkProps\nlinkOptions returns\n\nAn object literal with the exact type inferred from the input\n\nExamples\ntsx\nconst userLinkOptions = linkOptions({\n  to: '/dashboard/users/user',\n  search: {\n    usersView: {\n      sortBy: 'email',\n      filterBy: 'filter',\n    },\n    userId: 0,\n  },\n})\n\nfunction DashboardComponent() {\n  return <Link {...userLinkOptions} />\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Search middleware to strip search params | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/stripSearchParamsFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nSearch middleware to strip search params\n\nstripSearchParams is a search middleware that allows to remove search params.\n\nstripSearchParams props\n\nstripSearchParams accepts one of the following inputs:\n\ntrue: if the search schema has no required params, true can be used to strip all search params\na list of keys of those search params that shall be removed; only keys of optional search params are allowed.\nan object that conforms to the partial input search schema. The search params are compared against the values of this object; if the value is deeply equal, it will be removed. This is especially useful to strip out default search params.\nExamples\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, stripSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = {\n  one: 'abc',\n  two: 'xyz',\n}\n\nconst searchSchema = z.object({\n  one: z.string().default(defaultValues.one),\n  two: z.string().default(defaultValues.two),\n})\n\nexport const Route = createFileRoute('/hello')({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    // strip default values\n    middlewares: [stripSearchParams(defaultValues)],\n  },\n})\n\ntsx\nimport { z } from 'zod'\nimport { createRootRoute, stripSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  hello: z.string().default('world'),\n  requiredParam: z.string(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    // always remove `hello`\n    middlewares: [stripSearchParams(['hello'])],\n  },\n})\n\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, stripSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  one: z.string().default('abc'),\n  two: z.string().default('xyz'),\n})\n\nexport const Route = createFileRoute('/hello')({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    // remove all search params\n    middlewares: [stripSearchParams(true)],\n  },\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Search middleware to retain search params | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/retainSearchParamsFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nSearch middleware to retain search params\n\nretainSearchParams is a search middleware that allows to keep search params.\n\nretainSearchParams props\n\nThe retainSearchParams either accepts true or a list of keys of those search params that shall be retained. If true is passed in, all search params will be retained.\n\nExamples\ntsx\nimport { z } from 'zod'\nimport { createRootRoute, retainSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [retainSearchParams(['rootValue'])],\n  },\n})\n\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, retainSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  one: z.string().optional(),\n  two: z.string().optional(),\n})\n\nexport const Route = createFileRoute('/hello')({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [retainSearchParams(true)],\n  },\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "isNotFound function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/isNotFoundFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nisNotFound function\n\nThe isNotFound function can be used to determine if an object is a NotFoundError object.\n\nisNotFound options\n\nThe isNotFound function accepts a single argument, an input.\n\ninput option\nType: unknown\nRequired\nAn object to check if it is a NotFoundError.\nisNotFound returns\nType: boolean\ntrue if the object is a NotFoundError.\nfalse if the object is not a NotFoundError.\nExamples\ntsx\nimport { isNotFound } from '@tanstack/react-router'\n\nfunction somewhere(obj: unknown) {\n  if (isNotFound(obj)) {\n    // ...\n  }\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "isRedirect function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/isRedirectFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nisRedirect function\n\nThe isRedirect function can be used to determine if an object is a redirect object.\n\nisRedirect options\n\nThe isRedirect function accepts a single argument, an input.\n\ninput\nType: unknown\nRequired\nAn object to check if it is a redirect object\nisRedirect returns\nType: boolean\ntrue if the object is a redirect object\nfalse if the object is not a redirect object\nExamples\ntsx\nimport { isRedirect } from '@tanstack/react-router'\n\nfunction somewhere(obj: unknown) {\n  if (isRedirect(obj)) {\n    // ...\n  }\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "notFound function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/notFoundFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nnotFound function\n\nThe notFound function returns a new NotFoundError object that can be either returned or thrown from places like a Route's beforeLoad or loader callbacks to trigger the notFoundComponent.\n\nnotFound options\n\nThe notFound function accepts a single optional argument, the options to create the not-found error object.\n\nType: Partial<NotFoundError>\nOptional\nnotFound returns\nIf the throw property is true in the options object, the NotFoundError object will be thrown from within the function call.\nIf the throw property is false | undefined in the options object, the NotFoundError object will be returned.\nExamples\ntsx\nimport { notFound, createFileRoute, rootRouteId } from '@tanstack/react-router'\n\nconst Route = new createFileRoute('/posts/$postId')({\n  // throwing a not-found object\n  loader: ({ context: { post } }) => {\n    if (!post) {\n      throw notFound()\n    }\n  },\n  // or if you want to show a not-found on the whole page\n  loader: ({ context: { team } }) => {\n    if (!team) {\n      throw notFound({ routeId: rootRouteId })\n    }\n  },\n  // ... other route options\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "lazyRouteComponent function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/lazyRouteComponentFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nlazyRouteComponent function\n\nImportant\n\nIf you are using file-based routing, it's recommended to use the createLazyFileRoute function instead.\n\nThe lazyRouteComponent function can be used to create a one-off code-split route component that can be preloaded using a component.preload() method.\n\nlazyRouteComponent options\n\nThe lazyRouteComponent function accepts two arguments:\n\nimporter option\nType: () => Promise<T>\nRequired\nA function that returns a promise that resolves to an object that contains the component to be loaded.\nexportName option\nType: string\nOptional\nThe name of the component to be loaded from the imported object. Defaults to 'default'.\nlazyRouteComponent returns\nA React.lazy component that can be preloaded using a component.preload() method.\nExamples\ntsx\nimport { lazyRouteComponent } from '@tanstack/react-router'\n\nconst route = createRoute({\n  path: '/posts/$postId',\n  component: lazyRouteComponent(() => import('./Post')), // default export\n})\n\n// or\n\nconst route = createRoute({\n  path: '/posts/$postId',\n  component: lazyRouteComponent(\n    () => import('./Post'),\n    'PostByIdPageComponent', // named export\n  ),\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "redirect function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/redirectFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nredirect function\n\nThe redirect function returns a new Redirect object that can be either returned or thrown from places like a Route's beforeLoad or loader callbacks to trigger redirect to a new location.\n\nredirect options\n\nThe redirect function accepts a single argument, the options to determine the redirect behavior.\n\nType: Redirect\nRequired\nredirect returns\nIf the throw property is true in the options object, the Redirect object will be thrown from within the function call.\nIf the throw property is false | undefined in the options object, the Redirect object will be returned.\nExamples\ntsx\nimport { redirect } from '@tanstack/react-router'\n\nconst route = createRoute({\n  // throwing a redirect object\n  loader: () => {\n    if (!user) {\n      throw redirect({\n        to: '/login',\n      })\n    }\n  },\n  // or forcing `redirect` to throw itself\n  loader: () => {\n    if (!user) {\n      redirect({\n        to: '/login',\n        throw: true,\n      })\n    }\n  },\n  // ... other route options\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "getRouteApi function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/getRouteApiFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ngetRouteApi function\n\nThe getRouteApi function provides type-safe version of common hooks like useParams, useSearch, useRouteContext, useNavigate, useLoaderData, and useLoaderDeps that are pre-bound to a specific route ID and corresponding registered route types.\n\ngetRouteApi options\n\nThe getRouteApi function accepts a single argument, a routeId string literal.\n\nrouteId option\nType: string\nRequired\nThe route ID to which the RouteApi instance will be bound\ngetRouteApi returns\nAn instance of the RouteApi that is pre-bound to the route ID that the getRouteApi function was called with.\nExamples\ntsx\nimport { getRouteApi } from '@tanstack/react-router'\n\nconst routeApi = getRouteApi('/posts')\n\nexport function PostsPage() {\n  const posts = routeApi.useLoaderData()\n  // ...\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "createRouter function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/createRouterFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ncreateRouter function\n\nThe createRouter function accepts a RouterOptions object and creates a new Router instance.\n\ncreateRouter options\nType: RouterOptions\nRequired\nThe options that will be used to configure the router instance.\ncreateRouter returns\nAn instance of the Router.\nExamples\ntsx\nimport { createRouter, RouterProvider } from '@tanstack/react-router'\nimport { routeTree } from './routeTree.gen'\n\nconst router = createRouter({\n  routeTree,\n  defaultPreload: 'intent',\n})\n\nexport default function App() {\n  return <RouterProvider router={router} />\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "createLazyRoute function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/createLazyRouteFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ncreateLazyRoute function\n\nThe createLazyRoute function is used for creating a partial code-based route route instance that is lazily loaded when matched. This route instance can only be used to configure the non-critical properties of the route, such as component, pendingComponent, errorComponent, and the notFoundComponent.\n\ncreateLazyRoute options\n\nThe createLazyRoute function accepts a single argument of type string that represents the id of the route.\n\nid\nType: string\nRequired\nThe route id of the route.\ncreateLazyRoute returns\n\nA new function that accepts a single argument of partial of the type RouteOptions that will be used to configure the file Route instance.\n\nType:\ntsx\nPick<\n  RouteOptions,\n  'component' | 'pendingComponent' | 'errorComponent' | 'notFoundComponent'\n>\n\nRouteOptions\n\n‚ö†Ô∏è Note: This route instance must be manually lazily loaded against its critical route instance using the lazy method returned by the createRoute function.\n\nExamples\ntsx\n// src/route-pages/index.tsx\nimport { createLazyRoute } from '@tanstack/react-router'\n\nexport const Route = createLazyRoute('/')({\n  component: IndexComponent,\n})\n\nfunction IndexComponent() {\n  const data = Route.useLoaderData()\n  return <div>{data}</div>\n}\n\n// src/routeTree.tsx\nimport {\n  createRootRouteWithContext,\n  createRoute,\n  Outlet,\n} from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  foo: string\n}\n\nconst rootRoute = createRootRouteWithContext<MyRouterContext>()({\n  component: () => <Outlet />,\n})\n\nconst indexRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/',\n}).lazy(() => import('./route-pages/index').then((d) => d.Route))\n\nexport const routeTree = rootRoute.addChildren([indexRoute])\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "defer function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/deferFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ndefer function\n\nCaution\n\nYou don't need to call defer manually anymore, Promises are handled automatically now.\n\nThe defer function wraps a promise with a deferred state object that can be used to inspect the promise's state. This deferred promise can then be passed to the useAwaited hook or the <Await> component for suspending until the promise is resolved or rejected.\n\nThe defer function accepts a single argument, the promise to wrap with a deferred state object.\n\ndefer options\nType: Promise<T>\nRequired\nThe promise to wrap with a deferred state object.\ndefer returns\nA promise that can be passed to the useAwaited hook or the <Await> component.\nExamples\ntsx\nimport { defer } from '@tanstack/react-router'\n\nconst route = createRoute({\n  loader: () => {\n    const deferredPromise = defer(fetch('/api/data'))\n    return { deferredPromise }\n  },\n  component: MyComponent,\n})\n\nfunction MyComponent() {\n  const { deferredPromise } = Route.useLoaderData()\n\n  const data = useAwaited({ promise: deferredPromise })\n\n  // or\n\n  return (\n    <Await promise={deferredPromise}>\n      {(data) => <div>{JSON.stringify(data)}</div>}\n    </Await>\n  )\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "createRootRoute function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ncreateRootRoute function\n\nThe createRootRoute function returns a new root route instance. A root route instance can then be used to create a route-tree.\n\ncreateRootRoute options\n\nThe options that will be used to configure the root route instance.\n\nType:\ntsx\nOmit<\n  RouteOptions,\n  | 'path'\n  | 'id'\n  | 'getParentRoute'\n  | 'caseSensitive'\n  | 'parseParams'\n  | 'stringifyParams'\n>\n\nRouteOptions\nOptional\ncreateRootRoute returns\n\nA new Route instance.\n\nExamples\ntsx\nimport { createRootRoute, createRouter, Outlet } from '@tanstack/react-router'\n\nconst rootRoute = createRootRoute({\n  component: () => <Outlet />,\n  // ... root route options\n})\n\nconst routeTree = rootRoute.addChildren([\n  // ... other routes\n])\n\nconst router = createRouter({\n  routeTree,\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "createRouteMask function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/createRouteMaskFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ncreateRouteMask function\n\nThe createRouteMask function is a helper function that can be used to create a route mask configuration that can be passed to the RouterOptions.routeMasks option.\n\ncreateRouteMask options\nType: RouteMask\nRequired\nThe options that will be used to configure the route mask\ncreateRouteMask returns\nA object with the type signature of RouteMask that can be passed to the RouterOptions.routeMasks option.\nExamples\ntsx\nimport { createRouteMask, createRouter } from '@tanstack/react-router'\n\nconst photoModalToPhotoMask = createRouteMask({\n  routeTree,\n  from: '/photos/$photoId/modal',\n  to: '/photos/$photoId',\n  params: true,\n})\n\n// Set up a Router instance\nconst router = createRouter({\n  routeTree,\n  routeMasks: [photoModalToPhotoMask],\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "createRootRouteWithContext function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ncreateRootRouteWithContext function\n\nThe createRootRouteWithContext function is a helper function that can be used to create a root route instance that requires a context type to be fulfilled when the router is created.\n\ncreateRootRouteWithContext generics\n\nThe createRootRouteWithContext function accepts a single generic argument:\n\nTRouterContext generic\nType: TRouterContext\nOptional, but recommended.\nThe context type that will be required to be fulfilled when the router is created\ncreateRootRouteWithContext returns\nA factory function that can be used to create a new createRootRoute instance.\nIt accepts a single argument, the same as the createRootRoute function.\nExamples\ntsx\nimport {\n  createRootRouteWithContext,\n  createRouter,\n} from '@tanstack/react-router'\nimport { QueryClient } from '@tanstack/react-query'\n\ninterface MyRouterContext {\n  queryClient: QueryClient\n}\n\nconst rootRoute = createRootRouteWithContext<MyRouterContext>()({\n  component: () => <Outlet />,\n  // ... root route options\n})\n\nconst routeTree = rootRoute.addChildren([\n  // ... other routes\n])\n\nconst queryClient = new QueryClient()\n\nconst router = createRouter({\n  routeTree,\n  context: {\n    queryClient,\n  },\n})\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "createRoute function | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/createRouteFunction",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\ncreateRoute function\n\nThe createRoute function implements returns a Route instance. A route instance can then be passed to a root route's children to create a route tree, which is then passed to the router.\n\ncreateRoute options\nType: RouteOptions\nRequired\nThe options that will be used to configure the route instance\ncreateRoute returns\n\nA new Route instance.\n\nExamples\ntsx\nimport { createRoute } from '@tanstack/react-router'\nimport { rootRoute } from './__root'\n\nconst Route = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/',\n  loader: () => {\n    return 'Hello World'\n  },\n  component: IndexComponent,\n})\n\nfunction IndexComponent() {\n  const data = Route.useLoaderData()\n  return <div>{data}</div>\n}\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Router Context | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/router-context",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouter Context\n\nTanStack Router's router context is a very powerful tool that can be used for dependency injection among many other things. Aptly named, the router context is passed through the router and down through each matching route. At each route in the hierarchy, the context can be modified or added to. Here's a few ways you might use the router context practically:\n\nDependency Injection\nYou can supply dependencies (e.g. a loader function, a data fetching client, a mutation service) which the route and all child routes can access and use without importing or creating directly.\nBreadcrumbs\nWhile the main context object for each route is merged as it descends, each route's unique context is also stored making it possible to attach breadcrumbs or methods to each route's context.\nDynamic meta tag management\nYou can attach meta tags to each route's context and then use a meta tag manager to dynamically update the meta tags on the page as the user navigates the site.\n\nThese are just suggested uses of the router context. You can use it for whatever you want!\n\nTyped Router Context\n\nLike everything else, the root router context is strictly typed. This type can be augmented via any route's beforeLoad option as it is merged down the route match tree. To constrain the type of the root router context, you must use the createRootRouteWithContext<YourContextTypeHere>()(routeOptions) function to create a new router context instead of the createRootRoute() function to create your root route. Here's an example:\n\ntsx\nimport {\n  createRootRouteWithContext,\n  createRouter,\n} from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  user: User\n}\n\n// Use the routerContext to create your root route\nconst rootRoute = createRootRouteWithContext<MyRouterContext>()({\n  component: App,\n})\n\nconst routeTree = rootRoute.addChildren([\n  // ...\n])\n\n// Use the routerContext to create your router\nconst router = createRouter({\n  routeTree,\n})\n\nPassing the initial Router Context\n\nThe router context is passed to the router at instantiation time. You can pass the initial router context to the router via the context option:\n\nTip\n\nIf your context has any required properties, you will see a TypeScript error if you don't pass them in the initial router context. If all of your context properties are optional, you will not see a TypeScript error and passing the context will be optional. If you don't pass a router context, it defaults to {}.\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\n// Use the routerContext you created to create your router\nconst router = createRouter({\n  routeTree,\n  context: {\n    user: {\n      id: '123',\n      name: 'John Doe',\n    },\n  },\n})\n\nInvalidating the Router Context\n\nIf you need to invalidate the context state you are passing into the router, you can call the invalidate method to tell the router to recompute the context. This is useful when you need to update the context state and have the router recompute the context for all routes.\n\ntsx\nfunction useAuth() {\n  const router = useRouter()\n  const [user, setUser] = useState<User | null>(null)\n\n  useEffect(() => {\n    const unsubscribe = auth.onAuthStateChanged((user) => {\n      setUser(user)\n      router.invalidate()\n    })\n\n    return unsubscribe\n  }, [])\n\n  return user\n}\n\nUsing the Router Context\n\nOnce you have defined the router context type, you can use it in your route definitions:\n\ntsx\n// src/routes/todos.tsx\nexport const Route = createFileRoute('/todos')({\n  component: Todos,\n  loader: ({ context }) => fetchTodosByUserId(context.user.id),\n})\n\n\nYou can even inject data fetching and mutation implementations themselves! In fact, this is highly recommended üòú\n\nLet's try this with a simple function to fetch some todos:\n\ntsx\nconst fetchTodosByUserId = async ({ userId }) => {\n  const response = await fetch(`/api/todos?userId=${userId}`)\n  const data = await response.json()\n  return data\n}\n\nconst router = createRouter({\n  routeTree: rootRoute,\n  context: {\n    userId: '123',\n    fetchTodosByUserId,\n  },\n})\n\n\nThen, in your route:\n\ntsx\n// src/routes/todos.tsx\nexport const Route = createFileRoute('/todos')({\n  component: Todos,\n  loader: ({ context }) => context.fetchTodosByUserId(context.userId),\n})\n\nHow about an external data fetching library?\ntsx\nimport {\n  createRootRouteWithContext,\n  createRouter,\n} from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  queryClient: QueryClient\n}\n\nconst rootRoute = createRootRouteWithContext<MyRouterContext>()({\n  component: App,\n})\n\nconst queryClient = new QueryClient()\n\nconst router = createRouter({\n  routeTree: rootRoute,\n  context: {\n    queryClient,\n  },\n})\n\n\nThen, in your route:\n\ntsx\n// src/routes/todos.tsx\nexport const Route = createFileRoute('/todos')({\n  component: Todos,\n  loader: async ({ context }) => {\n    await context.queryClient.ensureQueryData({\n      queryKey: ['todos', { userId: user.id }],\n      queryFn: fetchTodos,\n    })\n  },\n})\n\nHow about using React Context/Hooks?\n\nWhen trying to use React Context or Hooks in your route's beforeLoad or loader functions, it's important to remember React's Rules of Hooks. You can't use hooks in a non-React function, so you can't use hooks in your beforeLoad or loader functions.\n\nSo, how do we use React Context or Hooks in our route's beforeLoad or loader functions? We can use the router context to pass down the React Context or Hooks to our route's beforeLoad or loader functions.\n\nLet's look at the setup for an example, where we pass down a useNetworkStrength hook to our route's loader function:\n\nsrc/routes/__root.tsx\ntsx\n// First, make sure the context for the root route is typed\nimport { createRootRouteWithContext } from '@tanstack/react-router'\nimport { useNetworkStrength } from '@/hooks/useNetworkStrength'\n\ninterface MyRouterContext {\n  networkStrength: ReturnType<typeof useNetworkStrength>\n}\n\nexport const Route = createRootRouteWithContext<MyRouterContext>()({\n  component: App,\n})\n\n\nIn this example, we'd instantiate the hook before rendering the router using the <RouterProvider />. This way, the hook would be called in React-land, therefore adhering to the Rules of Hooks.\n\nsrc/router.tsx\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nimport { routeTree } from './routeTree.gen'\n\nexport const router = createRouter({\n  routeTree,\n  context: {\n    networkStrength: undefined!, // We'll set this in React-land\n  },\n})\n\nsrc/main.tsx\ntsx\nimport { RouterProvider } from '@tanstack/react-router'\nimport { router } from './router'\n\nimport { useNetworkStrength } from '@/hooks/useNetworkStrength'\n\nfunction App() {\n  const networkStrength = useNetworkStrength()\n  // Inject the returned value from the hook into the router context\n  return <RouterProvider router={router} context={{ networkStrength }} />\n}\n\n// ...\n\n\nSo, now in our route's loader function, we can access the networkStrength hook from the router context:\n\nsrc/routes/posts.tsx\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  component: Posts,\n  loader: ({ context }) => {\n    if (context.networkStrength === 'STRONG') {\n      // Do something\n    }\n  },\n})\n\nModifying the Router Context\n\nThe router context is passed down the route tree and is merged at each route. This means that you can modify the context at each route and the modifications will be available to all child routes. Here's an example:\n\nsrc/routes/__root.tsx\ntsx\nimport { createRootRouteWithContext } from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  foo: boolean\n}\n\nexport const Route = createRootRouteWithContext<MyRouterContext>()({\n  component: App,\n})\n\nsrc/router.tsx\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nimport { routeTree } from './routeTree.gen'\n\nconst router = createRouter({\n  routeTree,\n  context: {\n    foo: true,\n  },\n})\n\nsrc/routes/todos.tsx\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/todos')({\n  component: Todos,\n  beforeLoad: () => {\n    return {\n      bar: true,\n    }\n  },\n  loader: ({ context }) => {\n    context.foo // true\n    context.bar // true\n  },\n})\n\nProcessing Accumulated Route Context\n\nContext, especially the isolated route context objects, make it trivial to accumulate and process the route context objects for all matched routes. Here's an example where we use all of the matched route contexts to generate a breadcrumb trail:\n\ntsx\n// src/routes/__root.tsx\nexport const Route = createRootRoute({\n  component: () => {\n    const matches = useRouterState({ select: (s) => s.matches })\n\n    const breadcrumbs = matches\n      .filter((match) => match.context.getTitle)\n      .map(({ pathname, context }) => {\n        return {\n          title: context.getTitle(),\n          path: pathname,\n        }\n      })\n\n    // ...\n  },\n})\n\n\nUsing that same route context, we could also generate a title tag for our page's <head>:\n\ntsx\n// src/routes/__root.tsx\nexport const Route = createRootRoute({\n  component: () => {\n    const matches = useRouterState({ select: (s) => s.matches })\n\n    const matchWithTitle = [...matches]\n      .reverse()\n      .find((d) => d.context.getTitle)\n\n    const title = matchWithTitle?.context.getTitle() || 'My App'\n\n    return (\n      <html>\n        <head>\n          <title>{title}</title>\n        </head>\n        <body>{/* ... */}</body>\n      </html>\n    )\n  },\n})\n\nEdit on GitHub\nOn this page\nTyped Router Context\nPassing the initial Router Context\nInvalidating the Router Context\nUsing the Router Context\nHow about an external data fetching library?\nHow about using React Context/Hooks?\nModifying the Router Context\nProcessing Accumulated Route Context\nHistory Types\nNot Found Errors\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "RouterOptions | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouterOptions\n\nThe RouterOptions type contains all of the options that can be used to configure a router instance.\n\nRouterOptions properties\n\nThe RouterOptions type accepts an object with the following properties and methods:\n\nrouteTree property\nType: AnyRoute\nRequired\nThe route tree that will be used to configure the router instance.\nhistory property\nType: RouterHistory\nOptional\nThe history object that will be used to manage the browser history. If not provided, a new createBrowserHistory instance will be created and used.\nstringifySearch method\nType: (search: Record<string, any>) => string\nOptional\nA function that will be used to stringify search params when generating links.\nDefaults to defaultStringifySearch.\nparseSearch method\nType: (search: string) => Record<string, any>\nOptional\nA function that will be used to parse search params when parsing the current location.\nDefaults to defaultParseSearch.\nsearch.strict property\nType: boolean\nOptional\nDefaults to false\nConfigures how unknown search params (= not returned by any validateSearch) are treated.\nIf false, unknown search params will be kept.\nIf true, unknown search params will be removed.\ndefaultPreload property\nType: undefined | false | 'intent' | 'viewport' | 'render'\nOptional\nDefaults to false\nIf false, routes will not be preloaded by default in any way.\nIf 'intent', routes will be preloaded by default when the user hovers over a link or a touchstart event is detected on a <Link>.\nIf 'viewport', routes will be preloaded by default when they are within the viewport of the browser.\nIf 'render', routes will be preloaded by default as soon as they are rendered in the DOM.\ndefaultPreloadDelay property\nType: number\nOptional\nDefaults to 50\nThe delay in milliseconds that a route must be hovered over or touched before it is preloaded.\ndefaultComponent property\nType: RouteComponent\nOptional\nDefaults to Outlet\nThe default component a route should use if no component is provided.\ndefaultErrorComponent property\nType: RouteComponent\nOptional\nDefaults to ErrorComponent\nThe default errorComponent a route should use if no error component is provided.\ndefaultNotFoundComponent property\nType: NotFoundRouteComponent\nOptional\nDefaults to NotFound\nThe default notFoundComponent a route should use if no notFound component is provided.\ndefaultPendingComponent property\nType: RouteComponent\nOptional\nThe default pendingComponent a route should use if no pending component is provided.\ndefaultPendingMs property\nType: number\nOptional\nDefaults to 1000\nThe default pendingMs a route should use if no pendingMs is provided.\ndefaultPendingMinMs property\nType: number\nOptional\nDefaults to 500\nThe default pendingMinMs a route should use if no pendingMinMs is provided.\ndefaultStaleTime property\nType: number\nOptional\nDefaults to 0\nThe default staleTime a route should use if no staleTime is provided.\ndefaultPreloadStaleTime property\nType: number\nOptional\nDefaults to 30_000 ms (30 seconds)\nThe default preloadStaleTime a route should use if no preloadStaleTime is provided.\ndefaultPreloadGcTime property\nType: number\nOptional\nDefaults to routerOptions.defaultGcTime, which defaults to 30 minutes.\nThe default preloadGcTime a route should use if no preloadGcTime is provided.\ndefaultGcTime property\nType: number\nOptional\nDefaults to 30 minutes.\nThe default gcTime a route should use if no gcTime is provided.\ndefaultOnCatch property\nType: (error: Error, errorInfo: ErrorInfo) => void\nOptional\nThe default onCatch handler for errors caught by the Router ErrorBoundary\ndefaultViewTransition property\nType: boolean | ViewTransitionOptions\nOptional\nIf true, route navigations will be called using document.startViewTransition().\nIf ViewTransitionOptions, route navigations will be called using document.startViewTransition({update, types}) where types will be the strings array passed with ViewTransitionOptions[\"types\"]. If the browser does not support viewTransition types, the navigation will fall back to normal document.startTransition(), same as if true was passed.\nIf the browser does not support this api, this option will be ignored.\nSee MDN for more information on how this function works.\nSee Google for more information on viewTransition types\ndefaultHashScrollIntoView property\nType: boolean | ScrollIntoViewOptions\nOptional\nDefaults to true so the element with an id matching the hash will be scrolled into view after the location is committed to history.\nIf false, the element with an id matching the hash will not be scrolled into view after the location is committed to history.\nIf an object is provided, it will be passed to the scrollIntoView method as options.\nSee MDN for more information on ScrollIntoViewOptions.\ncaseSensitive property\nType: boolean\nOptional\nDefaults to false\nIf true, all routes will be matched as case-sensitive.\nbasepath property\nType: string\nOptional\nDefaults to /\nThe basepath for then entire router. This is useful for mounting a router instance at a subpath.\ncontext property\nType: any\nOptional or required if the root route was created with createRootRouteWithContext().\nThe root context that will be provided to all routes in the route tree. This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\ndehydrate method\nType: () => TDehydrated\nOptional\nA function that will be called when the router is dehydrated. The return value of this function will be serialized and stored in the router's dehydrated state.\nhydrate method\nType: (dehydrated: TDehydrated) => void\nOptional\nA function that will be called when the router is hydrated. The return value of this function will be serialized and stored in the router's dehydrated state.\nrouteMasks property\nType: RouteMask[]\nOptional\nAn array of route masks that will be used to mask routes in the route tree. Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\nunmaskOnReload property\nType: boolean\nOptional\nDefaults to false\nIf true, route masks will, by default, be removed when the page is reloaded. This can be overridden on a per-mask basis by setting the unmaskOnReload option on the mask, or on a per-navigation basis by setting the unmaskOnReload option in the Navigate options.\nWrap property\nType: React.Component\nOptional\nA component that will be used to wrap the entire router. This is useful for providing a context to the entire router. Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n\nExample\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n  Wrap: ({ children }) => {\n    return <MyContext.Provider value={myContext}>{children}</MyContext>\n  },\n})\n\nInnerWrap property\nType: React.Component\nOptional\nA component that will be used to wrap the inner contents of the router. This is useful for providing a context to the inner contents of the router where you also need access to the router context and hooks. Only non-DOM-rendering components like providers should be used, anything else will cause a hydration error.\n\nExample\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n  InnerWrap: ({ children }) => {\n    const routerState = useRouterState()\n\n    return (\n      <MyContext.Provider value={myContext}>\n        {children}\n      </MyContext>\n    )\n  },\n})\n\nnotFoundMode property\nType: 'root' | 'fuzzy'\nOptional\nDefaults to 'fuzzy'\nThis property controls how TanStack Router will handle scenarios where it cannot find a route to match the current location. See the Not Found Errors guide for more information.\nnotFoundRoute property\nDeprecated\nType: NotFoundRoute\nOptional\nA route that will be used as the default not found route for every branch of the route tree. This can be overridden on a per-branch basis by providing a not found route to the NotFoundRoute option on the root route of the branch.\nerrorSerializer property\nType: [RouterErrorSerializer]\nOptional\nThe serializer object that will be used to determine how errors are serialized and deserialized between the server and the client.\nerrorSerializer.serialize method\nType: (err: unknown) => TSerializedError\nThis method is called to define how errors are serialized when they are stored in the router's dehydrated state.\nerrorSerializer.deserialize method\nType: (err: TSerializedError) => unknown\nThis method is called to define how errors are deserialized from the router's dehydrated state.\ntrailingSlash property\nType: 'always' | 'never' | 'preserve'\nOptional\nDefaults to never\nConfigures how trailing slashes are treated. 'always' will add a trailing slash if not present, 'never' will remove the trailing slash if present and 'preserve' will not modify the trailing slash.\npathParamsAllowedCharacters property\nType: Array<';' | ':' | '@' | '&' | '=' | '+' | '$' | ','>\nOptional\nConfigures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\ndefaultStructuralSharing property\nType: boolean\nOptional\nDefaults to false\nConfigures whether structural sharing is enabled by default for fine-grained selectors.\nSee the Render Optimizations guide for more information.\ndefaultRemountDeps property\nType:\ntsx\ntype defaultRemountDeps = (opts: RemountDepsOptions) => any\n\ninterface RemountDepsOptions<\n  in out TRouteId,\n  in out TFullSearchSchema,\n  in out TAllParams,\n  in out TLoaderDeps,\n> {\n  routeId: TRouteId\n  search: TFullSearchSchema\n  params: TAllParams\n  loaderDeps: TLoaderDeps\n}\n\nOptional\nA default function that will be called to determine whether a route component shall be remounted after navigation. If this function returns a different value than previously, it will remount.\nThe return value needs to be JSON serializable.\nBy default, a route component will not be remounted if it stays active after a navigation\n\nExample:\nIf you want to configure to remount all route components upon params change, use:\n\ntsx\nremountDeps: ({ params }) => params\n\nEdit on GitHub\nOn this page\nRouterOptions properties\nrouteTree property\nhistory property\nstringifySearch method\nparseSearch method\nsearch.strict property\ndefaultPreload property\ndefaultPreloadDelay property\ndefaultComponent property\ndefaultErrorComponent property\ndefaultNotFoundComponent property\ndefaultPendingComponent property\ndefaultPendingMs property\ndefaultPendingMinMs property\ndefaultStaleTime property\ndefaultPreloadStaleTime property\ndefaultPreloadGcTime property\ndefaultGcTime property\ndefaultOnCatch property\ndefaultViewTransition property\ndefaultHashScrollIntoView property\ncaseSensitive property\nbasepath property\ncontext property\ndehydrate method\nhydrate method\nrouteMasks property\nunmaskOnReload property\nWrap property\nInnerWrap property\nnotFoundMode property\nnotFoundRoute property\nerrorSerializer property\nerrorSerializer.serialize method\nerrorSerializer.deserialize method\ntrailingSlash property\npathParamsAllowedCharacters property\ndefaultStructuralSharing property\ndefaultRemountDeps property\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Navigation Blocking | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/navigation-blocking",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nNavigation Blocking\n\nNavigation blocking is a way to prevent navigation from happening. This is typical if a user attempts to navigate while they:\n\nHave unsaved changes\nAre in the middle of a form\nAre in the middle of a payment\n\nIn these situations, a prompt or custom UI should be shown to the user to confirm they want to navigate away.\n\nIf the user confirms, navigation will continue as normal\nIf the user cancels, all pending navigations will be blocked\nHow does navigation blocking work?\n\nNavigation blocking adds one or more layers of \"blockers\" to the entire underlying history API. If any blockers are present, navigation will be paused via one of the following ways:\n\nCustom UI\nIf the navigation is triggered by something we control at the router level, we can allow you to perform any task or show any UI you'd like to the user to confirm the action. Each blocker's blocker function will be asynchronously and sequentially executed. If any blocker function resolves or returns true, the navigation will be allowed and all other blockers will continue to do the same until all blockers have been allowed to proceed. If any single blocker resolves or returns false, the navigation will be canceled and the rest of the blocker functions will be ignored.\nThe onbeforeunload event\nFor page events that we cannot control directly, we rely on the browser's onbeforeunload event. If the user attempts to close the tab or window, refresh, or \"unload\" the page assets in any way, the browser's generic \"Are you sure you want to leave?\" dialog will be shown. If the user confirms, all blockers will be bypassed and the page will unload. If the user cancels, the unload will be cancelled, and the page will remain as is.\nHow do I use navigation blocking?\n\nThere are 2 ways to use navigation blocking:\n\nHook/logical-based blocking\nComponent-based blocking\nHook/logical-based blocking\n\nLet's imagine we want to prevent navigation if a form is dirty. We can do this by using the useBlocker hook:\n\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  useBlocker({\n    shouldBlockFn: () => {\n      if (!formIsDirty) return false\n\n      const shouldLeave = confirm('Are you sure you want to leave?')\n      return !shouldLeave\n    },\n  })\n\n  // ...\n}\n\n\nshouldBlockFn gives you type safe access to the current and next location:\n\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  // always block going from /foo to /bar/123?hello=world\n  const { proceed, reset, status } = useBlocker({\n    shouldBlockFn: ({ current, next }) => {\n      return (\n        current.routeId === '/foo' &&\n        next.fullPath === '/bar/$id' &&\n        next.params.id === 123 &&\n        next.search.hello === 'world'\n      )\n    },\n    withResolver: true,\n  })\n\n  // ...\n}\n\n\nYou can find more information about the useBlocker hook in the API reference.\n\nComponent-based blocking\n\nIn addition to logical/hook based blocking, can use the Block component to achieve similar results:\n\ntsx\nimport { Block } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  return (\n    <Block\n      shouldBlockFn={() => {\n        if (!formIsDirty) return false\n\n        const shouldLeave = confirm('Are you sure you want to leave?')\n        return !shouldLeave\n      }}\n    />\n  )\n\n  // OR\n\n  return (\n    <Block shouldBlockFn={() => !formIsDirty} withResolver>\n      {({ status, proceed, reset }) => <>{/* ... */}</>}\n    </Block>\n  )\n}\n\nHow can I show a custom UI?\n\nIn most cases, using window.confirm in the shouldBlockFn function with withResolver: false in the hook is enough since it will clearly show the user that the navigation is being blocked and resolve the blocking based on their response.\n\nHowever, in some situations, you might want to show a custom UI that is intentionally less disruptive and more integrated with your app's design.\n\nNote: The return value of shouldBlockFn does not resolve the blocking if withResolver is true.\n\nHook/logical-based custom UI with resolver\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  const { proceed, reset, status } = useBlocker({\n    shouldBlockFn: () => formIsDirty,\n    withResolver: true,\n  })\n\n  // ...\n\n  return (\n    <>\n      {/* ... */}\n      {status === 'blocked' && (\n        <div>\n          <p>Are you sure you want to leave?</p>\n          <button onClick={proceed}>Yes</button>\n          <button onClick={reset}>No</button>\n        </div>\n      )}\n    </>\n}\n\nHook/logical-based custom UI without resolver\ntsx\nimport { useBlocker } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  useBlocker({\n    shouldBlockFn: () => {\n      if (!formIsDirty) {\n        return false\n      }\n\n      const shouldBlock = new Promise<boolean>((resolve) => {\n        // Using a modal manager of your choice\n        modals.open({\n          title: 'Are you sure you want to leave?',\n          children: (\n            <SaveBlocker\n              confirm={() => {\n                modals.closeAll()\n                resolve(false)\n              }}\n              reject={() => {\n                modals.closeAll()\n                resolve(true)\n              }}\n            />\n          ),\n          onClose: () => resolve(true),\n        })\n      })\n      return shouldBlock\n    },\n  })\n\n  // ...\n}\n\nComponent-based custom UI\n\nSimilarly to the hook, the Block component returns the same state and functions as render props:\n\ntsx\nimport { Block } from '@tanstack/react-router'\n\nfunction MyComponent() {\n  const [formIsDirty, setFormIsDirty] = useState(false)\n\n  return (\n    <Block shouldBlockFn={() => formIsDirty} withResolver>\n      {({ status, proceed, reset }) => (\n        <>\n          {/* ... */}\n          {status === 'blocked' && (\n            <div>\n              <p>Are you sure you want to leave?</p>\n              <button onClick={proceed}>Yes</button>\n              <button onClick={reset}>No</button>\n            </div>\n          )}\n        </>\n      )}\n    </Block>\n  )\n}\n\nEdit on GitHub\nOn this page\nHow does navigation blocking work?\nHow do I use navigation blocking?\nHook/logical-based blocking\nComponent-based blocking\nHow can I show a custom UI?\nHook/logical-based custom UI with resolver\nHook/logical-based custom UI without resolver\nComponent-based custom UI\nRoute Masking\nCustom Search Param Serialization\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Parallel Routes | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/parallel-routes",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nParallel Routes\n\nWe haven't covered this yet. Stay tuned!\n\nEdit on GitHub\nHome\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Router API | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/api/router",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouter API\nFunctions\ncreateFileRoute\ncreateLazyFileRoute\ncreateRootRoute\ncreateRootRouteWithContext\ncreateRoute\ncreateLazyRoute\ncreateRouteMask\ncreateRouter\ndefer\ngetRouteApi\nisNotFound\nisRedirect\nlazyRouteComponent\nlinkOptions\nnotFound\nredirect\nretainSearchParams\nstripSearchParams\nComponents\n<Await>\n<CatchBoundary>\n<CatchNotFound>\n<ClientOnly>\n<DefaultGlobalNotFound>\n<ErrorComponent>\n<Link>\n<MatchRoute>\n<Navigate>\n<Outlet>\nHooks\nuseAwaited\nuseBlocker\nuseCanGoBack\nuseChildMatches\nuseLinkProps\nuseLoaderData\nuseLoaderDeps\nuseLocation\nuseMatch\nuseMatchRoute\nuseMatches\nuseNavigate\nuseParentMatches\nuseParams\nuseRouteContext\nuseRouter\nuseRouterState\nuseSearch\nTypes\nActiveLinkOptions Type\nAsyncRouteComponent Type\nHistoryState Interface\nLinkOptions Type\nLinkProps Type\nMatchRouteOptions Type\nNavigateOptions Type\nNotFoundError Type\nParsedHistoryState Type\nParsedLocation Type\nRedirect Type\nRegister Type\nRoute Type\nRouteApi Type\nRouteMask Type\nRouteMatch Type\nRouteOptions Type\nRouter Type\nRouterEvents Type\nRouterOptions Type\nRouterState Type\nToMaskOptions Type\nToOptions Type\nUseMatchRouteOptions Type\nViewTransitionOptions Type\n‚ö†Ô∏è Deprecated\nFileRoute Class\nRoute Class\nRouter Class\nRouteApi Class\nRootRoute Class\nNotFoundRoute Class\nrootRouteWithContext Function\nEdit on GitHub\nFile-Based Routing\nESLint Plugin Router\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "SSR | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/ssr",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nSSR\n\nServer Side Rendering (SSR) is the process of rendering a component on the server and sending the HTML markup to the client. The client then hydrates the markup into a fully interactive component.\n\nThere are usually two different flavors of SSR to be considered:\n\nNon-streaming SSR\nThe entire page is rendered on the server and sent to the client in one single HTML request, including the serialized data the application needs to hydrate on the client.\nStreaming SSR\nThe critical first paint of the page is rendered on the server and sent to the client in one single HTML request, including the serialized data the application needs to hydrate on the client\nThe rest of the page is then streamed to the client as it is rendered on the server.\n\nThis guide will explain how to implement both flavors of SSR with TanStack Router!\n\nNon-Streaming SSR\n\nNon-Streaming server-side rendering is the classic process of rendering the markup for your entire application page on the server and sending the completed HTML markup (and data) to the client. The client then hydrates the markup into a fully interactive application again.\n\nTo implement non-streaming SSR with TanStack Router, you will need the following utilities:\n\nStartServer from @tanstack/react-start/server\ne.g. <StartServer router={router} />\nRendering this component in your server entry will render your application and also automatically handle application-level hydration/dehydration and implement the Wrap component option on Router\nStartClient from @tanstack/react-start\ne.g. <StartClient router={router} />\nRendering this component in your client entry will render your application and also automatically implement the Wrap component option on Router\nRouter Creation\n\nSince your router will exist both on the server and the client, it's important that you create your router in a way that is consistent between both of these environments. The easiest way to do this is to expose a createRouter function in a shared file that can be imported and called by both your server and client entry files.\n\nsrc/router.tsx\ntsx\nimport * as React from 'react'\nimport { createRouter as createTanstackRouter } from '@tanstack/react-router'\nimport { routeTree } from './routeTree.gen'\n\nexport function createRouter() {\n  return createTanstackRouter({ routeTree })\n}\n\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: ReturnType<typeof createRouter>\n  }\n}\n\n\nNow you can import this function in both your server and client entry files and create your router.\n\nsrc/entry-server.tsx\ntsx\nimport { createRouter } from './router'\n\nexport async function render(req, res) {\n  const router = createRouter()\n}\n\nsrc/entry-client.tsx\ntsx\nimport { createRouter } from './router'\n\nconst router = createRouter()\n\nServer History\n\nOn the client, Router defaults to using an instance of createBrowserHistory, which is the preferred type of history to use on the client. On the server, however, you will want to use an instance of createMemoryHistory instead. This is because createBrowserHistory uses the window object, which does not exist on the server.\n\nüß† Make sure you initialize your memory history with the server URL that is being rendered.\n\nsrc/entry-server.tsx\ntsx\nconst router = createRouter()\n\nconst memoryHistory = createMemoryHistory({\n  initialEntries: [opts.url],\n})\n\n\nAfter creating the memory history instance, you can update the router to use it.\n\nsrc/entry-server.tsx\ntsx\nrouter.update({\n  history: memoryHistory,\n})\n\nLoading Critical Router Data on the Server\n\nIn order to render your application on the server, you will need to ensure that the router has loaded any critical data via it's route loaders. To do this, you can await router.load() before rendering your application. This will quite literally wait for each of the matching route matches found for this url to run their route's loader functions in parallel.\n\nsrc/entry-server.tsx\ntsx\nawait router.load()\n\nAutomatic Loader Dehydration/Hydration\n\nResolved loader data fetched by routes is automatically dehydrated and rehydrated by TanStack Router so long as you complete the standard SSR steps outlined in this guide.\n\n‚ö†Ô∏è If you are using deferred data streaming, you will also need to ensure that you have implemented the SSR Streaming & Stream Transform pattern near the end of this guide.\n\nFor more information on how to utilize data loading, see the Data Loading guide.\n\nRendering the Application on the Server\n\nNow that you have a router instance that has loaded all of the critical data for the current URL, you can render your application on the server:\n\ntsx\n// src/entry-server.tsx\n\nconst html = ReactDOMServer.renderToString(<StartServer router={router} />)\n\nHandling Not Found Errors\n\nrouter has a method hasNotFoundMatch to check if a not-found error has occurred during the rendering process. Use this method to check if a not-found error has occurred and set the response status code accordingly:\n\ntsx\n// src/entry-server.tsx\nif (router.hasNotFoundMatch()) statusCode = 404\n\nAll Together Now!\n\nHere is a complete example of a server entry file that uses all of the concepts discussed above.\n\ntsx\n// src/entry-server.tsx\nimport * as React from 'react'\nimport ReactDOMServer from 'react-dom/server'\nimport { createMemoryHistory } from '@tanstack/react-router'\nimport { StartServer } from '@tanstack/react-start/server'\nimport { createRouter } from './router'\n\nexport async function render(url, response) {\n  const router = createRouter()\n\n  const memoryHistory = createMemoryHistory({\n    initialEntries: [url],\n  })\n\n  router.update({\n    history: memoryHistory,\n  })\n\n  await router.load()\n\n  const appHtml = ReactDOMServer.renderToString(<StartServer router={router} />)\n\n  response.statusCode = router.hasNotFoundMatch() ? 404 : 200\n  response.setHeader('Content-Type', 'text/html')\n  response.end(`<!DOCTYPE html>${appHtml}`)\n}\n\nRendering the Application on the Client\n\nOn the client, things are much simpler.\n\nCreate your router instance\nRender your application using the <StartClient /> component\ntsx\n// src/entry-client.tsx\n\nimport * as React from 'react'\nimport ReactDOM from 'react-dom/client'\n\nimport { StartClient } from '@tanstack/react-start'\nimport { createRouter } from './router'\n\nconst router = createRouter()\n\nReactDOM.hydrateRoot(document, <StartClient router={router} />)\n\n\nWith this setup, your application will be rendered on the server and then hydrated on the client!\n\nStreaming SSR\n\nStreaming SSR is the most modern flavor of SSR and is the process of continuously and incrementally sending HTML markup to the client as it is rendered on the server. This is slightly different from traditional SSR in concept because beyond being able to dehydrate and rehydrate a critical first paint, markup and data with less priority or slower response times can be streamed to the client after the initial render, but in the same request.\n\nThis pattern can be useful for pages that have slow or high-latency data fetching requirements. For example, if you have a page that needs to fetch data from a third-party API, you can stream the critical initial markup and data to the client and then stream the less-critical third-party data to the client as it is resolved.\n\nThis streaming pattern is all automatic as long as you are using renderToPipeableStream.\n\nStreaming Dehydration/Hydration\n\nStreaming dehydration/hydration is an advanced pattern that goes beyond markup and allows you to dehydrate and stream any supporting data from the server to the client and rehydrate it on arrival. This is useful for applications that may need to further use/manage the underlying data that was used to render the initial markup on the server.\n\nData Serialization\n\nWhen using SSR, data passed between the server and the client must be serialized before it is sent across network-boundaries. TanStack Router handles this serialization using a very lightweight serializer that supports common data types beyond JSON.stringify/JSON.parse.\n\nOut of the box, the following types are supported:\n\nundefined\nDate\nError\nFormData\n\nIf you feel that there are other types that should be supported by default, please open an issue on the TanStack Router repository.\n\nIf you are using more complex data types like Map, Set, BigInt, etc, you may need to use a custom serializer to ensure that your type-definitions are accurate and your data is correctly serialized and deserialized. We are currently working on both a more robust serializer and a way to customize the serializer for your application. Open an issue if you are interested in helping out!\n\nThe Data Serialization API allows the usage of a custom serializer that can allow us to transparently use these data types when communicating across the network.\n\ntsx\nimport { SuperJSON } from 'superjson'\n\nconst router = createRouter({\n  serializer: SuperJSON,\n})\n\n\nJust like that, TanStack Router will now appropriately use SuperJSON to serialize data across the network.\n\nEdit on GitHub\nStatic Route Data\nRender Optimizations\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Render Optimizations | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/render-optimizations",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRender Optimizations\n\nTanStack Router includes several optimizations to ensure your components only re-render when necessary. These optimizations include:\n\nstructural sharing\n\nTanStack Router uses a technique called \"structural sharing\" to preserve as many references as possible between re-renders, which is particularly useful for state stored in the URL, such as search parameters.\n\nFor example, consider a details route with two search parameters, foo and bar, accessed like this:\n\ntsx\nconst search = Route.useSearch()\n\n\nWhen only bar is changed by navigating from /details?foo=f1&bar=b1 to /details?foo=f1&bar=b2, search.foo will be referentially stable and only search.bar will be replaced.\n\nfine-grained selectors\n\nYou can access and subscribe to the router state using various hooks like useRouterState, useSearch, and others. If you only want a specific component to re-render when a particular subset of the router state such as a subset of the search parameters changes, you can use partial subscriptions with the select property.\n\ntsx\n// component won't re-render when `bar` changes\nconst foo = Route.useSearch({ select: ({ foo }) => foo })\n\nstructural sharing with fine-grained selectors\n\nThe select function can perform various calculations on the router state, allowing you to return different types of values, such as objects. For example:\n\ntsx\nconst result = Route.useSearch({\n  select: (search) => {\n    return {\n      foo: search.foo,\n      hello: `hello ${search.foo}`,\n    }\n  },\n})\n\n\nAlthough this works, it will cause your component to re-render each time, since select is now returning a new object each time it‚Äôs called.\n\nYou can avoid this re-rendering issue by using \"structural sharing\" as described above. By default, structural sharing is turned off to maintain backward compatibility, but this may change in v2.\n\nTo enable structural sharing for fine grained selectors, you have two options:\n\nEnable it by default in the router options:\ntsx\nconst router = createRouter({\n  routeTree,\n  defaultStructuralSharing: true,\n})\n\nEnable it per hook usage as shown here:\ntsx\nconst result = Route.useSearch({\n  select: (search) => {\n    return {\n      foo: search.foo,\n      hello: `hello ${search.foo}`,\n    }\n  },\n  structuralSharing: true,\n})\n\n\nImportant\n\nStructural sharing only works with JSON-compatible data. This means you cannot use select to return items like class instances if structural sharing is enabled.\n\nIn line with TanStack Router's type-safe design, TypeScript will raise an error if you attempt the following:\n\ntsx\nconst result = Route.useSearch({\n  select: (search) => {\n    return {\n      date: new Date(),\n    }\n  },\n  structuralSharing: true,\n})\n\n\nIf structural sharing is enabled by default in the router options, you can prevent this error by setting structuralSharing: false.\n\nEdit on GitHub\nSSR\nFile-Based Routing\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Not Found Errors | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nNot Found Errors\n\n‚ö†Ô∏è This page covers the newer notFound function and notFoundComponent API for handling not found errors. The NotFoundRoute route is deprecated and will be removed in a future release. See Migrating from NotFoundRoute for more information.\n\nOverview\n\nThere are 2 uses for not-found errors in TanStack Router:\n\nNon-matching route paths: When a path does not match any known route matching pattern OR when it partially matches a route, but with extra path segments\nThe router will automatically throw a not-found error when a path does not match any known route matching pattern\nIf the router's notFoundMode is set to fuzzy, the nearest parent route with a notFoundComponent will handle the error. If the router's notFoundMode is set to root, the root route will handle the error.\nExamples:\nAttempting to access /users when there is no /users route\nAttempting to access /posts/1/edit when the route tree only handles /posts/$postId\nMissing resources: When a resource cannot be found, such as a post with a given ID or any asynchronous data that is not available or does not exist\nYou, the developer must throw a not-found error when a resource cannot be found. This can be done in the beforeLoad or loader functions using the notFound utility.\nWill be handled by the nearest parent route with a notFoundComponent (when notFound is called within loader) or the root route.\nExamples:\nAttempting to access /posts/1 when the post with ID 1 does not exist\nAttempting to access /docs/path/to/document when the document does not exist\n\nUnder the hood, both of these cases are implemented using the same notFound function and notFoundComponent API.\n\nThe notFoundMode option\n\nWhen TanStack Router encounters a pathname that doesn't match any known route pattern OR partially matches a route pattern but with extra trailing pathname segments, it will automatically throw a not-found error.\n\nDepending on the notFoundMode option, the router will handle these automatic errors differently::\n\n\"fuzzy\" mode (default): The router will intelligently find the closest matching suitable route and display the notFoundComponent.\n\"root\" mode: All not-found errors will be handled by the root route's notFoundComponent, regardless of the nearest matching route.\nnotFoundMode: 'fuzzy'\n\nBy default, the router's notFoundMode is set to fuzzy, which indicates that if a pathname doesn't match any known route, the router will attempt to use the closest matching route with children/(an outlet) and a configured not found component.\n\n‚ùì Why is this the default? Fuzzy matching to preserve as much parent layout as possible for the user gives them more context to navigate to a useful location based on where they thought they would arrive.\n\nThe nearest suitable route is found using the following criteria:\n\nThe route must have children and therefore an Outlet to render the notFoundComponent\nThe route must have a notFoundComponent configured or the router must have a defaultNotFoundComponent configured\n\nFor example, consider the following route tree:\n\n__root__ (has a notFoundComponent configured)\nposts (has a notFoundComponent configured)\n$postId (has a notFoundComponent configured)\n\nIf provided the path of /posts/1/edit, the following component structure will be rendered:\n\n<Root>\n<Posts>\n<Posts.notFoundComponent>\n\nThe notFoundComponent of the posts route will be rendered because it is the nearest suitable parent route with children (and therefore an outlet) and a notFoundComponent configured.\n\nnotFoundMode: 'root'\n\nWhen notFoundMode is set to root, all not-found errors will be handled by the root route's notFoundComponent instead of bubbling up from the nearest fuzzy-matched route.\n\nFor example, consider the following route tree:\n\n__root__ (has a notFoundComponent configured)\nposts (has a notFoundComponent configured)\n$postId (has a notFoundComponent configured)\n\nIf provided the path of /posts/1/edit, the following component structure will be rendered:\n\n<Root>\n<Root.notFoundComponent>\n\nThe notFoundComponent of the __root__ route will be rendered because the notFoundMode is set to root.\n\nConfiguring a route's notFoundComponent\n\nTo handle both types of not-found errors, you can attach a notFoundComponent to a route. This component will be rendered when a not-found error is thrown.\n\nFor example, configuring a notFoundComponent for a /settings route to handle non-existing settings pages:\n\ntsx\nexport const Route = createFileRoute('/settings')({\n  component: () => {\n    return (\n      <div>\n        <p>Settings page</p>\n        <Outlet />\n      </div>\n    )\n  },\n  notFoundComponent: () => {\n    return <p>This setting page doesn't exist!</p>\n  },\n})\n\n\nOr configuring a notFoundComponent for a /posts/$postId route to handle posts that don't exist:\n\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params: { postId } }) => {\n    const post = await getPost(postId)\n    if (!post) throw notFound()\n    return { post }\n  },\n  component: ({ post }) => {\n    return (\n      <div>\n        <h1>{post.title}</h1>\n        <p>{post.body}</p>\n      </div>\n    )\n  },\n  notFoundComponent: () => {\n    return <p>Post not found!</p>\n  },\n})\n\nDefault Router-Wide Not Found Handling\n\nYou may want to provide a default not-found component for every route in your app with child routes.\n\nWhy only routes with children? Leaf-node routes (routes without children) will never render an Outlet and therefore are not able to handle not-found errors.\n\nTo do this, pass a defaultNotFoundComponent to the createRouter function:\n\ntsx\nconst router = createRouter({\n  defaultNotFoundComponent: () => {\n    return (\n      <div>\n        <p>Not found!</p>\n        <Link to=\"/\">Go home</Link>\n      </div>\n    )\n  },\n})\n\nThrowing your own notFound errors\n\nYou can manually throw not-found errors in loader methods and components using the notFound function. This is useful when you need to signal that a resource cannot be found.\n\nThe notFound function works in a similar fashion to the redirect function. To cause a not-found error, you can throw a notFound().\n\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params: { postId } }) => {\n    // Returns `null` if the post doesn't exist\n    const post = await getPost(postId)\n    if (!post) {\n      throw notFound()\n      // Alternatively, you can make the notFound function throw:\n      // notFound({ throw: true })\n    }\n    // Post is guaranteed to be defined here because we threw an error\n    return { post }\n  },\n})\n\n\nThe not-found error above will be handled by the same route or nearest parent route that has either a notFoundComponent route option or the defaultNotFoundComponent router option configured.\n\nIf neither the route nor any suitable parent route is found to handle the error, the root route will handle it using TanStack Router's extremely basic (and purposefully undesirable) default not-found component that simply renders <div>Not Found</div>. It's highly recommended to either attach at least one notFoundComponent to the root route or configure a router-wide defaultNotFoundComponent to handle not-found errors.\n\nSpecifying Which Routes Handle Not Found Errors\n\nSometimes you may want to trigger a not-found on a specific parent route and bypass the normal not-found component propagation. To do this, pass in a route id to the route option in the notFound function.\n\ntsx\n// _pathlessLayout.tsx\nexport const Route = createFileRoute('/_pathlessLayout')({\n  // This will render\n  notFoundComponent: () => {\n    return <p>Not found (in _pathlessLayout)</p>\n  },\n  component: () => {\n    return (\n      <div>\n        <p>This is a pathless layout route!</p>\n        <Outlet />\n      </div>\n    )\n  },\n})\n\n// _pathlessLayout/route-a.tsx\nexport const Route = createFileRoute('/_pathless/route-a')({\n  loader: async () => {\n    // This will make LayoutRoute handle the not-found error\n    throw notFound({ routeId: '/_pathlessLayout' })\n    //                      ^^^^^^^^^ This will autocomplete from the registered router\n  },\n  // This WILL NOT render\n  notFoundComponent: () => {\n    return <p>Not found (in _pathlessLayout/route-a)</p>\n  },\n})\n\nManually targeting the root route\n\nYou can also target the root route by passing the exported rootRouteId variable to the notFound function's route property:\n\ntsx\nimport { rootRouteId } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params: { postId } }) => {\n    const post = await getPost(postId)\n    if (!post) throw notFound({ routeId: rootRouteId })\n    return { post }\n  },\n})\n\nThrowing Not Found Errors in Components\n\nYou can also throw not-found errors in components. However, it is recommended to throw not-found errors in loader methods instead of components in order to correctly type loader data and prevent flickering.\n\nTanStack Router exposes a CatchNotFound component similar to CatchBoundary that can be used to catch not-found errors in components and display UI accordingly.\n\nData Loading Inside notFoundComponent\n\nnotFoundComponent is a special case when it comes to data loading. SomeRoute.useLoaderData may not be defined depending on which route you are trying to access and where the not-found error gets thrown. However, Route.useParams, Route.useSearch, Route.useRouteContext, etc. will return a defined value.\n\nIf you need to pass incomplete loader data to notFoundComponent, pass the data via the data option in the notFound function and validate it in notFoundComponent.\n\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params: { postId } }) => {\n    const post = await getPost(postId)\n    if (!post)\n      throw notFound({\n        // Forward some data to the notFoundComponent\n        // data: someIncompleteLoaderData\n      })\n    return { post }\n  },\n  // `data: unknown` is passed to the component via the `data` option when calling `notFound`\n  notFoundComponent: ({ data }) => {\n    // ‚ùå useLoaderData is not valid here: const { post } = Route.useLoaderData()\n\n    // ‚úÖ:\n    const { postId } = Route.useParams()\n    const search = Route.useSearch()\n    const context = Route.useRouteContext()\n\n    return <p>Post with id {postId} not found!</p>\n  },\n})\n\nUsage With SSR\n\nSee SSR guide for more information.\n\nMigrating from NotFoundRoute\n\nThe NotFoundRoute API is deprecated in favor of notFoundComponent. The NotFoundRoute API will be removed in a future release.\n\nThe notFound function and notFoundComponent will not work when using NotFoundRoute.\n\nThe main differences are:\n\nNotFoundRoute is a route that requires an <Outlet> on its parent route to render. notFoundComponent is a component that can be attached to any route.\nWhen using NotFoundRoute, you can't use layouts. notFoundComponent can be used with layouts.\nWhen using notFoundComponent, path matching is strict. This means that if you have a route at /post/$postId, a not-found error will be thrown if you try to access /post/1/2/3. With NotFoundRoute, /post/1/2/3 would match the NotFoundRoute and only render it if there is an <Outlet>.\n\nTo migrate from NotFoundRoute to notFoundComponent, you'll just need to make a few changes:\n\ntsx\n// router.tsx\nimport { createRouter } from '@tanstack/react-router'\nimport { routeTree } from './routeTree.gen.'\n- import { notFoundRoute } from './notFoundRoute'  // [!code --]\n\nexport const router = createRouter({\n  routeTree,\n- notFoundRoute // [!code --]\n})\n\n// routes/__root.tsx\nimport { createRootRoute } from '@tanstack/react-router'\n\nexport const Route = createRootRoute({\n  // ...\n+ notFoundComponent: () => {  // [!code ++]\n+   return <p>Not found!</p>  // [!code ++]\n+ } // [!code ++]\n})\n\n\nImportant changes:\n\nA notFoundComponent is added to the root route for global not-found handling.\nYou can also add a notFoundComponent to any other route in your route tree to handle not-found errors for that specific route.\nThe notFoundComponent does not support rendering an <Outlet>.\nEdit on GitHub\nRouter Context\nAuthenticated Routes\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Authenticated Routes | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/authenticated-routes",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nAuthenticated Routes\n\nAuthentication is an extremely common requirement for web applications. In this guide, we'll walk through how to use TanStack Router to build protected routes, and how to redirect users to login if they try to access them.\n\nThe route.beforeLoad Option\n\nThe route.beforeLoad option allows you to specify a function that will be called before a route is loaded. It receives all of the same arguments that the route.loader function does. This is a great place to check if a user is authenticated, and redirect them to a login page if they are not.\n\nThe beforeLoad function runs in relative order to these other route loading functions:\n\nRoute Matching (Top-Down)\nroute.params.parse\nroute.validateSearch\nRoute Loading (including Preloading)\nroute.beforeLoad\nroute.onError\nRoute Loading (Parallel)\nroute.component.preload?\nroute.load\n\nIt's important to know that the beforeLoad function for a route is called before any of its child routes' beforeLoad functions. It is essentially a middleware function for the route and all of its children.\n\nIf you throw an error in beforeLoad, none of its children will attempt to load.\n\nRedirecting\n\nWhile not required, some authentication flows require redirecting to a login page. To do this, you can throw a redirect() from beforeLoad:\n\ntsx\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  beforeLoad: async ({ location }) => {\n    if (!isAuthenticated()) {\n      throw redirect({\n        to: '/login',\n        search: {\n          // Use the current location to power a redirect after login\n          // (Do not use `router.state.resolvedLocation` as it can\n          // potentially lag behind the actual current location)\n          redirect: location.href,\n        },\n      })\n    }\n  },\n})\n\n\nTip\n\nThe redirect() function takes all of the same options as the navigate function, so you can pass options like replace: true if you want to replace the current history entry instead of adding a new one.\n\nOnce you have authenticated a user, it's also common practice to redirect them back to the page they were trying to access. To do this, you can utilize the redirect search param that we added in our original redirect. Since we'll be replacing the entire URL with what it was, router.history.push is better suited for this than router.navigate:\n\ntsx\nrouter.history.push(search.redirect)\n\nNon-Redirected Authentication\n\nSome applications choose to not redirect users to a login page, and instead keep the user on the same page and show a login form that either replaces the main content or hides it via a modal. This is also possible with TanStack Router by simply short circuiting rendering the <Outlet /> that would normally render the child routes:\n\ntsx\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  component: () => {\n    if (!isAuthenticated()) {\n      return <Login />\n    }\n\n    return <Outlet />\n  },\n})\n\n\nThis keeps the user on the same page, but still allows you to render a login form. Once the user is authenticated, you can simply render the <Outlet /> and the child routes will be rendered.\n\nAuthentication using React context/hooks\n\nIf your authentication flow relies on interactions with React context and/or hooks, you'll need to pass down your authentication state to TanStack Router using router.context option.\n\nImportant\n\nReact hooks are not meant to be consumed outside of React components. If you need to use a hook outside of a React component, you need to extract the returned state from the hook in a component that wraps your <RouterProvider /> and then pass the returned value down to TanStack Router.\n\nWe'll cover the router.context options in-detail in the Router Context section.\n\nHere's an example that uses React context and hooks for protecting authenticated routes in TanStack Router. See the entire working setup in the Authenticated Routes example.\n\nsrc/routes/__root.tsx\ntsx\nimport { createRootRouteWithContext } from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  // The ReturnType of your useAuth hook or the value of your AuthContext\n  auth: AuthState\n}\n\nexport const Route = createRootRouteWithContext<MyRouterContext>()({\n  component: () => <Outlet />,\n})\n\nsrc/router.tsx\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nimport { routeTree } from './routeTree.gen'\n\nexport const router = createRouter({\n  routeTree,\n  context: {\n    // auth will initially be undefined\n    // We'll be passing down the auth state from within a React component\n    auth: undefined!,\n  },\n})\n\nsrc/App.tsx\ntsx\nimport { RouterProvider } from '@tanstack/react-router'\n\nimport { AuthProvider, useAuth } from './auth'\n\nimport { router } from './router'\n\nfunction InnerApp() {\n  const auth = useAuth()\n  return <RouterProvider router={router} context={{ auth }} />\n}\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <InnerApp />\n    </AuthProvider>\n  )\n}\n\n\nThen in the authenticated route, you can check the auth state using the beforeLoad function, and throw a redirect() to your Login route if the user is not signed-in.\n\nsrc/routes/dashboard.route.tsx\ntsx\nimport { createFileRoute, redirect } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/dashboard')({\n  beforeLoad: ({ context, location }) => {\n    if (!context.auth.isAuthenticated) {\n      throw redirect({\n        to: '/login',\n        search: {\n          redirect: location.href,\n        },\n      })\n    }\n  },\n})\n\n\nYou can optionally, also use the Non-Redirected Authentication approach to show a login form instead of calling a redirect.\n\nThis approach can also be used in conjunction with Pathless or Layout Route to protect all routes under their parent route.\n\nEdit on GitHub\nNot Found Errors\nScroll Restoration\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Scroll Restoration | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/scroll-restoration",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nScroll Restoration\nHash/Top-of-Page Scrolling\n\nOut of the box, TanStack Router supports both hash scrolling and top-of-page scrolling without any additional configuration.\n\nScroll-to-top & Nested Scrollable Areas\n\nBy default, scroll-to-top mimics the behavior of the browser, which means only the window itself is scrolled to the top after successful navigation. For many apps however, it's common for the main scrollable area to be a nested div or similar because of advanced layouts. If you would like TanStack Router to also scroll these main scrollable areas for you, you can add selectors to target them using the routerOptions.scrollToTopSelectors:\n\ntsx\nconst router = createRouter({\n  scrollToTopSelectors: ['#main-scrollable-area'],\n})\n\n\nThese selectors are handled in addition to window which cannot be disabled currently.\n\nScroll Restoration\n\nScroll restoration is the process of restoring the scroll position of a page when the user navigates back to it. This is normally a built-in feature for standard HTML based websites, but can be difficult to replicate for SPA applications because:\n\nSPAs typically use the history.pushState API for navigation, so the browser doesn't know to restore the scroll position natively\nSPAs sometimes render content asynchronously, so the browser doesn't know the height of the page until after it's rendered\nSPAs can sometimes use nested scrollable containers to force specific layouts and features.\n\nNot only that, but it's very common for applications to have multiple scrollable areas within an app, not just the body. For example, a chat application might have a scrollable sidebar and a scrollable chat area. In this case, you would want to restore the scroll position of both areas independently.\n\nTo alleviate this problem, TanStack Router provides a scroll restoration component and hook that handle the process of monitoring, caching and restoring scroll positions for you.\n\nIt does this by:\n\nMonitoring the DOM for scroll events\nRegistering scrollable areas with the scroll restoration cache\nListening to the proper router events to know when to cache and restore scroll positions\nStoring scroll positions for each scrollable area in the cache (including window and body)\nRestoring scroll positions after successful navigations before DOM paint\n\nThat may sound like a lot, but for you, it's as simple as this:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  scrollRestoration: true,\n})\n\n\nNote\n\nThe <ScrollRestoration /> component still works, but has been deprecated.\n\nCustom Cache Keys\n\nFalling in behind Remix's own Scroll Restoration APIs, you can also customize the key used to cache scroll positions for a given scrollable area using the getKey option. This could be used, for example, to force the same scroll position to be used regardless of the users browser history.\n\nThe getKey option receives the relevant Location state from TanStack Router and expects you to return a string to uniquely identify the scrollable measurements for that state.\n\nThe default getKey is (location) => location.state.key!, where key is the unique key generated for each entry in the history.\n\nExamples\n\nYou could sync scrolling to the pathname:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  getScrollRestorationKey: (location) => location.pathname,\n})\n\n\nYou can conditionally sync only some paths, then use the key for the rest:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  getScrollRestorationKey: (location) => {\n    const paths = ['/', '/chat']\n    return paths.includes(location.pathname)\n      ? location.pathname\n      : location.state.key!\n  },\n})\n\nPreventing Scroll Restoration\n\nSometimes you may want to prevent scroll restoration from happening. To do this you can utilize the resetScroll option available on the following APIs:\n\n<Link resetScroll={false}>\nnavigate({ resetScroll: false })\nredirect({ resetScroll: false })\n\nWhen resetScroll is set to false, the scroll position for the next navigation will not be restored (if navigating to an existing history event in the stack) or reset to the top (if it's a new history event in the stack).\n\nManual Scroll Restoration\n\nMost of the time, you won't need to do anything special to get scroll restoration to work. However, there are some cases where you may need to manually control scroll restoration. The most common example is virtualized lists.\n\nTo manually control scroll restoration for virtualized lists within the whole browser window:\n\ntsx\nfunction Component() {\n  const scrollEntry = useElementScrollRestoration({\n    getElement: () => window,\n  })\n\n  // Let's use TanStack Virtual to virtualize some content!\n  const virtualizer = useWindowVirtualizer({\n    count: 10000,\n    estimateSize: () => 100,\n    // We pass the scrollY from the scroll restoration entry to the virtualizer\n    // as the initial offset\n    initialOffset: scrollEntry?.scrollY,\n  })\n\n  return (\n    <div>\n      {virtualizer.getVirtualItems().map(item => (\n        ...\n      ))}\n    </div>\n  )\n}\n\n\nTo manually control scroll restoration for a specific element, you can use the useElementScrollRestoration hook and the data-scroll-restoration-id DOM attribute:\n\ntsx\nfunction Component() {\n  // We need a unique ID for manual scroll restoration on a specific element\n  // It should be as unique as possible for this element across your app\n  const scrollRestorationId = 'myVirtualizedContent'\n\n  // We use that ID to get the scroll entry for this element\n  const scrollEntry = useElementScrollRestoration({\n    id: scrollRestorationId,\n  })\n\n  // Let's use TanStack Virtual to virtualize some content!\n  const virtualizerParentRef = React.useRef<HTMLDivElement>(null)\n  const virtualizer = useVirtualizer({\n    count: 10000,\n    getScrollElement: () => virtualizerParentRef.current,\n    estimateSize: () => 100,\n    // We pass the scrollY from the scroll restoration entry to the virtualizer\n    // as the initial offset\n    initialOffset: scrollEntry?.scrollY,\n  })\n\n  return (\n    <div\n      ref={virtualizerParentRef}\n      // We pass the scroll restoration ID to the element\n      // as a custom attribute that will get picked up by the\n      // scroll restoration watcher\n      data-scroll-restoration-id={scrollRestorationId}\n      className=\"flex-1 border rounded-lg overflow-auto relative\"\n    >\n      ...\n    </div>\n  )\n}\n\nScroll Behavior\n\nTo control the scroll behavior when navigating between pages, you can use the scrollRestorationBehavior option. This allows you to make the transition between pages instant instead of a smooth scroll. The global configuration of scroll restoration behavior has the same options as those supported by the browser, which are smooth, instant, and auto (see MDN for more information).\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  scrollRestorationBehavior: 'instant',\n})\n\nEdit on GitHub\nAuthenticated Routes\nStatic Route Data\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Static Route Data | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/static-route-data",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nStatic Route Data\n\nWhen creating routes, you can optionally specify a staticData property in the route's options. This object can literally contain anything you want as long as it's synchronously available when you create your route.\n\nIn addition to being able to access this data from the route itself, you can also access it from any match under the match.staticData property.\n\nExample\nposts.tsx\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  staticData: {\n    customData: 'Hello!',\n  },\n})\n\n\nYou can then access this data anywhere you have access to your routes, including matches that can be mapped back to their routes.\n\n__root.tsx\ntsx\nimport { createRootRoute } from '@tanstack/react-router'\n\nexport const Route = createRootRoute({\n  component: () => {\n    const matches = useMatches()\n\n    return (\n      <div>\n        {matches.map((match) => {\n          return <div key={match.id}>{match.staticData.customData}</div>\n        })}\n      </div>\n    )\n  },\n})\n\nEnforcing Static Data\n\nIf you want to enforce that a route has static data, you can use declaration merging to add a type to the route's static option:\n\ntsx\ndeclare module '@tanstack/react-router' {\n  interface StaticDataRouteOption {\n    customData: string\n  }\n}\n\n\nNow, if you try to create a route without the customData property, you'll get a type error:\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  staticData: {\n    // Property 'customData' is missing in type '{ customData: number; }' but required in type 'StaticDataRouteOption'.ts(2741)\n  },\n})\n\nOptional Static Data\n\nIf you want to make static data optional, simply add a ? to the property:\n\ntsx\ndeclare module '@tanstack/react-router' {\n  interface StaticDataRouteOption {\n    customData?: string\n  }\n}\n\n\nAs long as there are any required properties on the StaticDataRouteOption, you'll be required to pass in an object.\n\nEdit on GitHub\nScroll Restoration\nSSR\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Document Head Management | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/document-head-management",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nDocument Head Management\n\nDocument head management is the process of managing the head, title, meta, link, and script tags of a document and TanStack Router provides a robust way to manage the document head for full-stack applications that use Start and for single-page applications that use @tanstack/react-router. It provides:\n\nAutomatic deduping of title and meta tags\nAutomatic loading/unloading of tags based on route visibility\nA composable way to merge title and meta tags from nested routes\n\nFor full-stack applications that use Start, and even for single-page applications that use @tanstack/react-router, managing the document head is a crucial part of any application for the following reasons:\n\nSEO\nSocial media sharing\nAnalytics\nCSS and JS loading/unloading\n\nTo manage the document head, it's required that you render both the <HeadContent /> and <Scripts /> components and use the routeOptions.head property to manage the head of a route, which returns an object with title, meta, links, and scripts properties.\n\nManaging the Document Head\ntsx\nexport const Route = createRootRoute({\n  head: () => ({\n    meta: [\n      {\n        name: 'description',\n        content: 'My App is a web application',\n      },\n      {\n        title: 'My App',\n      },\n    ],\n    links: [\n      {\n        rel: 'icon',\n        href: '/favicon.ico',\n      },\n    ],\n    scripts: [\n      {\n        src: 'https://www.google-analytics.com/analytics.js',\n      },\n    ],\n  }),\n})\n\nDeduping\n\nOut of the box, TanStack Router will dedupe title and meta tags, preferring the last occurrence of each tag found in nested routes.\n\ntitle tags defined in nested routes will override a title tag defined in a parent route (but you can compose them together, which is covered in a future section of this guide)\nmeta tags with the same name or property will be overridden by the last occurrence of that tag found in nested routes\n<HeadContent />\n\nThe <HeadContent /> component is required to render the head, title, meta, link, and head-related script tags of a document.\n\nIt should be rendered either in the <head> tag of your root layout or as high up in the component tree as possible if your application doesn't or can't manage the <head> tag.\n\nStart/Full-Stack Applications\ntsx\nimport { HeadContent } from '@tanstack/react-router'\n\nexport const Route = createRootRoute({\n  component: () => (\n    <html>\n      <head>\n        <HeadContent />\n      </head>\n      <body>\n        <Outlet />\n      </body>\n    </html>\n  ),\n})\n\nSingle-Page Applications\ntsx\nimport { HeadContent } from '@tanstack/react-router'\n\nconst rootRoute = createRootRoute({\n  component: () => (\n    <>\n      <HeadContent />\n      <Outlet />\n    </>\n  ),\n})\n\nManaging Body Scripts\n\nIn addition to scripts that can be rendered in the <head> tag, you can also render scripts in the <body> tag using the routeOptions.scripts property. This is useful for loading scripts (even inline scripts) that require the DOM to be loaded, but before the main entry point of your application (which includes hydration if you're using Start or a full-stack implementation of TanStack Router).\n\nTo do this, you must:\n\nUse the scripts property of the routeOptions object\nRender the <Scripts /> component\ntsx\nexport const Route = createRootRoute({\n  scripts: [\n    {\n      children: 'console.log(\"Hello, world!\")',\n    },\n  ],\n})\n\n<Scripts />\n\nThe <Scripts /> component is required to render the body scripts of a document. It should be rendered either in the <body> tag of your root layout or as high up in the component tree as possible if your application doesn't or can't manage the <body> tag.\n\nExample\ntsx\nimport { createFileRoute, Scripts } from '@tanstack/react-router'\nexport const Router = createFileRoute('/')({\n  component: () => (\n    <html>\n      <head />\n      <body>\n        <Outlet />\n        <Scripts />\n      </body>\n    </html>\n  ),\n})\n\ntsx\nimport { Scripts, createRootRoute } from '@tanstack/react-router'\n\nexport const Route = createRootRoute({\n  component: () => (\n    <>\n      <Outlet />\n      <Scripts />\n    </>\n  ),\n})\n\nEdit on GitHub\nPreloading\nRoute Masking\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Route Masking | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/route-masking",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRoute Masking\n\nRoute masking is a way to mask the actual URL of a route that gets persisted to the browser's history and URL bar. This is useful for scenarios where you want to show a different URL than the one that is actually being navigated to and then falling back to the displayed URL when it is shared and (optionally) when the page is reloaded. Here's a few examples:\n\nNavigating to a modal route like /photo/5/modal, but masking the actual URL as /photos/5\nNavigating to a modal route like /post/5/comments, but masking the actual URL as /posts/5\nNavigating to a route with the search param ?showLogin=true, but masking the URL to not contain the search param\nNavigating to a route with the search param ?modal=settings, but masking the URL as `/settings'\n\nEach of these scenarios can be achieved with route masking and even extended to support more advanced patterns like parallel routes.\n\nHow does route masking work?\n\nImportant\n\nYou do not need to understand how route masking works in order to use it. This section is for those who are curious about how it works under the hood. Skip to How do I use route masking? to learn how to use it!.\n\nRoute masking utilizes the location.state API to store the desired runtime location inside of the location that will get written to the URL. It stores this runtime location under the __tempLocation state property:\n\ntsx\nconst location = {\n  pathname: '/photos/5',\n  search: '',\n  hash: '',\n  state: {\n    key: 'wesdfs',\n    __tempKey: 'sadfasd',\n    __tempLocation: {\n      pathname: '/photo/5/modal',\n      search: '',\n      hash: '',\n      state: {},\n    },\n  },\n}\n\n\nWhen the router parses a location from history with the location.state.__tempLocation property, it will use that location instead of the one that was parsed from the URL. This allows you to navigate to a route like /photos/5 and have the router actually navigate to /photo/5/modal instead. When this happens, the history location is saved back into the location.maskedLocation property, just in case we need to know what the actual URL is. One example of where this is used is in the Devtools where we detect if a route is masked and show the actual URL instead of the masked one!\n\nRemember, you don't need to worry about any of this. It's all handled for you automatically under the hood!\n\nHow do I use route masking?\n\nRoute masking is a simple API that can be used in 2 ways:\n\nImperatively via the mask option available on the <Link> and navigate() APIs\nDeclaratively via the Router's routeMasks option\n\nWhen using either route masking APIs, the mask option accepts the same navigation object that the <Link> and navigate() APIs accept. This means you can use the same to, replace, state, and search options that you're already familiar with. The only difference is that the mask option will be used to mask the URL of the route being navigated to.\n\nüß† The mask option is also type-safe! This means that if you're using TypeScript, you'll get type errors if you try to pass an invalid navigation object to the mask option. Booyah!\n\nImperative route masking\n\nThe <Link> and navigate() APIs both accept a mask option that can be used to mask the URL of the route being navigated to. Here's an example of using it with the <Link> component:\n\ntsx\n<Link\n  to=\"/photos/$photoId/modal\"\n  params={{ photoId: 5 }}\n  mask={{\n    to: '/photos/$photoId',\n    params: {\n      photoId: 5,\n    },\n  }}\n>\n  Open Photo\n</Link>\n\n\nAnd here's an example of using it with the navigate() API:\n\ntsx\nconst navigate = useNavigate()\n\nfunction onOpenPhoto() {\n  navigate({\n    to: '/photos/$photoId/modal',\n    params: { photoId: 5 },\n    mask: {\n      to: '/photos/$photoId',\n      params: {\n        photoId: 5,\n      },\n    },\n  })\n}\n\nDeclarative route masking\n\nIn addition to the imperative API, you can also use the Router's routeMasks option to declaratively mask routes. Instead of needing to pass the mask option to every <Link> or navigate() call, you can instead create a route mask on the Router to mask routes that match a certain pattern. Here's an example of the same route mask from above, but using the routeMasks option instead:\n\n// Use the following for the example below\n\ntsx\nimport { createRouteMask } from '@tanstack/react-router'\n\nconst photoModalToPhotoMask = createRouteMask({\n  routeTree,\n  from: '/photos/$photoId/modal',\n  to: '/photos/$photoId',\n  params: (prev) => ({\n    photoId: prev.photoId,\n  }),\n})\n\nconst router = createRouter({\n  routeTree,\n  routeMasks: [photoModalToPhotoMask],\n})\n\n\nWhen creating a route mask, you'll need to pass 1 argument with at least:\n\nrouteTree - The route tree that the route mask will be applied to\nfrom - The route ID that the route mask will be applied to\n...navigateOptions - The standard to, search, params, replace, etc options that the <Link> and navigate() APIs accept\n\nüß† The createRouteMask option is also type-safe! This means that if you're using TypeScript, you'll get type errors if you try to pass an invalid route mask to the routeMasks option.\n\nUnmasking when sharing the URL\n\nURLs are automatically unmasked when they are shared since as soon as a URL is detached from your browsers local history stack, the URL masking data is no longer available. Essentially, as soon as you copy and paste a URL out of your history, its masking data is lost... after all, that's the point of masking a URL!\n\nLocal Unmasking Defaults\n\nBy default, URLs are not unmasked when the page is reloaded locally. Masking data is stored in the location.state property of the history location, so as long as the history location is still in memory in your history stack, the masking data will be available and the URL will continue to be masked.\n\nUnmasking on page reload\n\nAs stated above, URLs are not unmasked when the page is reloaded by default.\n\nIf you want to unmask a URL locally when the page is reloaded, you have 3 options, each overriding the previous one in priority if passed:\n\nSet the Router's default unmaskOnReload option to true\nReturn the unmaskOnReload: true option from the masking function when creating a route mask with createRouteMask()\nPass the unmaskOnReload: true option to the <Link> component or navigate() API\nEdit on GitHub\nDocument Head Management\nNavigation Blocking\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Type Safety | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/type-safety",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nType Safety\n\nTanStack Router is built to be as type-safe as possible within the limits of the TypeScript compiler and runtime. This means that it's not only written in TypeScript, but that it also fully infers the types it's provided and tenaciously pipes them through the entire routing experience.\n\nUltimately, this means that you write less types as a developer and have more confidence in your code as it evolves.\n\nRoute Definitions File-based Routing\n\nRoutes are hierarchical, and so are their definitions. If you're using file-based routing, much of the type-safety is already taken care of for you.\n\nCode-based Routing\n\nIf you're using the Route class directly, you'll need to be aware of how to ensure your routes are typed properly using the Route's getParentRoute option. This is because child routes need to be aware of all of their parent routes types. Without this, those precious search params you parsed out of your layout and pathless layout routes, 3 levels up, would be lost to the JS void.\n\nSo, don't forget to pass the parent route to your child routes!\n\ntsx\nconst parentRoute = createRoute({\n  getParentRoute: () => parentRoute,\n})\n\nExported Hooks, Components, and Utilities\n\nFor the types of your router to work with top-level exports like Link, useNavigate, useParams, etc. they must permeate the type-script module boundary and be registered right into the library. To do this, we use declaration merging on the exported Register interface.\n\nts\nconst router = createRouter({\n  // ...\n})\n\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: typeof router\n  }\n}\n\n\nBy registering your router with the module, you can now use the exported hooks, components, and utilities with your router's exact types.\n\nFixing the Component Context Problem\n\nComponent context is a wonderful tool in React and other frameworks for providing dependencies to components. However, if that context is changing types as it moves throughout your component hierarchy, it becomes impossible for TypeScript to know how to infer those changes. To get around this, context-based hooks and components require that you give them a hint on how and where they are being used.\n\ntsx\nexport const Route = createFileRoute('/posts')({\n  component: PostsComponent,\n})\n\nfunction PostsComponent() {\n  // Each route has type-safe versions of most of the built-in hooks from TanStack Router\n  const params = Route.useParams()\n  const search = Route.useSearch()\n\n  // Some hooks require context from the *entire* router, not just the current route. To achieve type-safety here,\n  // we must pass the `from` param to tell the hook our relative position in the route hierarchy.\n  const navigate = useNavigate({ from: Route.fullPath })\n  // ... etc\n}\n\n\nEvery hook and component that requires a context hint will have a from param where you can pass the ID or path of the route you are rendering within.\n\nüß† Quick tip: If your component is code-split, you can use the getRouteApi function to avoid having to pass in the Route.fullPath to get access to the typed useParams() and useSearch() hooks.\n\nWhat if I don't know the route? What if it's a shared component?\n\nThe from property is optional, which means if you don't pass it, you'll get the router's best guess on what types will be available. Usually, that means you'll get a union of all of the types of all of the routes in the router.\n\nWhat if I pass the wrong from path?\n\nIt's technically possible to pass a from that satisfies TypeScript, but may not match the actual route you are rendering within at runtime. In this case, each hook and component that supports from will detect if your expectations don't match the actual route you are rendering within, and will throw a runtime error.\n\nWhat if I don't know the route, or it's a shared component, and I can't pass from?\n\nIf you are rendering a component that is shared across multiple routes, or you are rendering a component that is not within a route, you can pass strict: false instead of a from option. This will not only silence the runtime error, but will also give you relaxed, but accurate types for the potential hook you are calling. A good example of this is calling useSearch from a shared component:\n\ntsx\nfunction MyComponent() {\n  const search = useSearch({ strict: false })\n}\n\n\nIn this case, the search variable will be typed as a union of all possible search params from all routes in the router.\n\nRouter Context\n\nRouter context is so extremely useful as it's the ultimate hierarchical dependency injection. You can supply context to the router and to each and every route it renders. As you build up this context, TanStack Router will merge it down with the hierarchy of routes, so that each route has access to the context of all of its parents.\n\nThe createRootRouteWithContext factory creates a new router with the instantiated type, which then creates a requirement for you to fulfill the same type contract to your router, and will also ensure that your context is properly typed throughout the entire route tree.\n\ntsx\nconst rootRoute = createRootRouteWithContext<{ whateverYouWant: true }>()({\n  component: App,\n})\n\nconst routeTree = rootRoute.addChildren([\n  // ... all child routes will have access to `whateverYouWant` in their context\n])\n\nconst router = createRouter({\n  routeTree,\n  context: {\n    // This will be required to be passed now\n    whateverYouWant: true,\n  },\n})\n\nPerformance Recommendations\n\nAs your application scales, TypeScript check times will naturally increase. There are a few things to keep in mind when your application scales to keep your TS check times down.\n\nOnly infer types you need\n\nA great pattern with client side data caches (TanStack Query, etc.) is to prefetch data. For example with TanStack Query you might have a route which calls queryClient.ensureQueryData in a loader.\n\ntsx\nexport const Route = createFileRoute('/posts/$postId/deep')({\n  loader: ({ context: { queryClient }, params: { postId } }) =>\n    queryClient.ensureQueryData(postQueryOptions(postId)),\n  component: PostDeepComponent,\n})\n\nfunction PostDeepComponent() {\n  const params = Route.useParams()\n  const data = useSuspenseQuery(postQueryOptions(params.postId))\n\n  return <></>\n}\n\n\nThis may look fine and for small route trees and you may not notice any TS performance issues. However in this case TS has to infer the loader's return type, despite it never being used in your route. If the loader data is a complex type with many routes that prefetch in this manner, it can slow down editor performance. In this case, the change is quite simple and let typescript infer Promise.\n\ntsx\nexport const Route = createFileRoute('/posts/$postId/deep')({\n  loader: async ({ context: { queryClient }, params: { postId } }) => {\n    await queryClient.ensureQueryData(postQueryOptions(postId))\n  },\n  component: PostDeepComponent,\n})\n\nfunction PostDeepComponent() {\n  const params = Route.useParams()\n  const data = useSuspenseQuery(postQueryOptions(params.postId))\n\n  return <></>\n}\n\n\nThis way the loader data is never inferred and it moves the inference out of the route tree to the first time you use useSuspenseQuery.\n\nNarrow to relevant routes as much as you possibly can\n\nConsider the following usage of Link\n\ntsx\n<Link to=\"..\" search={{ page: 0 }} />\n<Link to=\".\" search={{ page: 0 }} />\n\n\nThese examples are bad for TS performance. That's because search resolves to a union of all search params for all routes and TS has to check whatever you pass to the search prop against this potentially big union. As your application grows, this check time will increase linearly to number of routes and search params. We have done our best to optimize for this case (TypeScript will typically do this work once and cache it) but the initial check against this large union is expensive. This also applies to params and other API's such as useSearch, useParams, useNavigate etc.\n\nInstead you should try to narrow to relevant routes with from or to.\n\ntsx\n<Link from={Route.fullPath} to=\"..\" search={{page: 0}} />\n<Link from=\"/posts\" to=\"..\" search={{page: 0}} />\n\n\nRemember you can always pass a union to to or from to narrow the routes you're interested in.\n\ntsx\nconst from: '/posts/$postId/deep' | '/posts/' = '/posts/'\n<Link from={from} to='..' />\n\n\nYou can also pass branches to from to only resolve search or params to be from any descendants of that branch:\n\ntsx\nconst from = '/posts'\n<Link from={from} to='..' />\n\n\n/posts could be a branch with many descendants which share the same search or params\n\nConsider using the object syntax of addChildren\n\nIt's typical of routes to have params search, loaders or context that can even reference external dependencies which are also heavy on TS inference. For such applications, using objects for creating the route tree can be more performant than tuples.\n\ncreateChildren also can accept an object. For large route trees with complex routes and external libraries, objects can be much faster for TS to type check as opposed to large tuples. The performance gains depend on your project, what external dependencies you have and how the types for those libraries are written\n\ntsx\nconst routeTree = rootRoute.addChildren({\n  postsRoute: postsRoute.addChildren({ postRoute, postsIndexRoute }),\n  indexRoute,\n})\n\n\nNote this syntax is more verbose but has better TS performance. With file based routing, the route tree is generated for you so a verbose route tree is not a concern\n\nAvoid internal types without narrowing\n\nIt's common you might want to re-use types exposed. For example you might be tempted to use LinkProps like so\n\ntsx\nconst props: LinkProps = {\n  to: '/posts/',\n}\n\nreturn (\n  <Link {...props}>\n)\n\n\nThis is VERY bad for TS Performance. The problem here is LinkProps has no type arguments and is therefore an extremely large type. It includes search which is a union of all search params, it contains params which is a union of all params. When merging this object with Link it will do a structural comparison of this huge type.\n\nInstead you can use as const satisfies to infer a precise type and not LinkProps directly to avoid the huge check\n\ntsx\nconst props = {\n  to: '/posts/',\n} as const satisfies LinkProps\n\nreturn (\n  <Link {...props}>\n)\n\n\nAs props is not of type LinkProps and therefore this check is cheaper because the type is much more precise. You can also improve type checking further by narrowing LinkProps\n\ntsx\nconst props = {\n  to: '/posts/',\n} as const satisfies LinkProps<RegisteredRouter, string '/posts/'>\n\nreturn (\n  <Link {...props}>\n)\n\n\nThis is even faster as we're checking against the narrowed LinkProps type.\n\nYou can also use this to narrow the type of LinkProps to a specific type to be used as a prop or parameter to a function\n\ntsx\nexport const myLinkProps = [\n  {\n    to: '/posts',\n  },\n  {\n    to: '/posts/$postId',\n    params: { postId: 'postId' },\n  },\n] as const satisfies ReadonlyArray<LinkProps>\n\nexport type MyLinkProps = (typeof myLinkProps)[number]\n\nconst MyComponent = (props: { linkProps: MyLinkProps }) => {\n  return <Link {...props.linkProps} />\n}\n\n\nThis is faster than using LinkProps directly in a component because MyLinkProps is a much more precise type\n\nAnother solution is not to use LinkProps and to provide inversion of control to render a Link component narrowed to a specific route. Render props are a good method of inverting control to the user of a component\n\ntsx\nexport interface MyComponentProps {\n  readonly renderLink: () => React.ReactNode\n}\n\nconst MyComponent = (props: MyComponentProps) => {\n  return <div>{props.renderLink()}</div>\n}\n\nconst Page = () => {\n  return <MyComponent renderLink={() => <Link to=\"/absolute\" />} />\n}\n\n\nThis particular example is very fast as we've inverted control of where we're navigating to the user of the component. The Link is narrowed to the exact route we want to navigate to\n\nEdit on GitHub\nData Mutations\nType Utilities\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Type Utilities | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/type-utilities",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nType Utilities\n\nMost types exposed by TanStack Router are internal, subject to breaking changes and not always easy to use. That is why TanStack Router has a subset of exposed types focused on ease of use with the intension to be used externally. These types provide the same type safe experience from TanStack Router's runtime concepts on the type level, with flexibility of where to provide type checking\n\nType checking Link options with ValidateLinkOptions\n\nValidateLinkOptions type checks object literal types to ensure they conform to Link options at inference sites. For example, you may have a generic HeadingLink component which accepts a title prop along with linkOptions, the idea being this component can be re-used for any navigation.\n\ntsx\nexport interface HeaderLinkProps<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TOptions = unknown,\n> {\n  title: string\n  linkOptions: ValidateLinkOptions<TRouter, TOptions>\n}\n\nexport function HeadingLink<TRouter extends RegisteredRouter, TOptions>(\n  props: HeaderLinkProps<TRouter, TOptions>,\n): React.ReactNode\nexport function HeadingLink(props: HeaderLinkProps): React.ReactNode {\n  return (\n    <>\n      <h1>{props.title}</h1>\n      <Link {...props.linkOptions} />\n    </>\n  )\n}\n\n\nA more permissive overload of HeadingLink is used to avoid type assertions you would otherwise have to do with the generic signature. Using a looser signature without type parameters is an easy way to avoid type assertions in the implementation of HeadingLink\n\nAll type parameters for utilities are optional but for the best TypeScript performance TRouter should always be specified for the public facing signature. And TOptions should always be used at inference sites like HeadingLink to infer the linkOptions to correctly narrow params and search\n\nThe result of this is that linkOptions in the following is completely type-safe\n\ntsx\n<HeadingLink title=\"Posts\" linkOptions={{ to: '/posts' }} />\n<HeadingLink title=\"Post\" linkOptions={{ to: '/posts/$postId', params: {postId: 'postId'} }} />\n\nType checking an array of Link options with ValidateLinkOptionsArray\n\nAll navigation type utilities have an array variant. ValidateLinkOptionsArray enables type checking of an array of Link options. For example, you might have a generic Menu component where each item is a Link.\n\ntsx\nexport interface MenuProps<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TItems extends ReadonlyArray<unknown> = ReadonlyArray<unknown>,\n> {\n  items: ValidateLinkOptionsArray<TRouter, TItems>\n}\n\nexport function Menu<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TItems extends ReadonlyArray<unknown>,\n>(props: MenuProps<TRouter, TItems>): React.ReactNode\nexport function Menu(props: MenuProps): React.ReactNode {\n  return (\n    <ul>\n      {props.items.map((item) => (\n        <li>\n          <Link {...item} />\n        </li>\n      ))}\n    </ul>\n  )\n}\n\n\nThis of course allows the following items prop to be completely type-safe\n\ntsx\n<Menu\n  items={[\n    { to: '/posts' },\n    { to: '/posts/$postId', params: { postId: 'postId' } },\n  ]}\n/>\n\n\nIt is also possible to fix from for each Link options in the array. This would allow all Menu items to navigate relative to from. Additional type checking of from can be provided by the ValidateFromPath utility\n\ntsx\nexport interface MenuProps<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TItems extends ReadonlyArray<unknown> = ReadonlyArray<unknown>,\n  TFrom extends string = string,\n> {\n  from: ValidateFromPath<TRouter, TFrom>\n  items: ValidateLinkOptionsArray<TRouter, TItems, TFrom>\n}\n\nexport function Menu<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TItems extends ReadonlyArray<unknown>,\n  TFrom extends string = string,\n>(props: MenuProps<TRouter, TItems, TFrom>): React.ReactNode\nexport function Menu(props: MenuProps): React.ReactNode {\n  return (\n    <ul>\n      {props.items.map((item) => (\n        <li>\n          <Link {...item} from={props.from} />\n        </li>\n      ))}\n    </ul>\n  )\n}\n\n\nValidateLinkOptionsArray allows you to fix from by providing an extra type parameter. The result is a type safe array of Link options providing navigation relative to from\n\ntsx\n<Menu\n  from=\"/posts\"\n  items={[{ to: '.' }, { to: './$postId', params: { postId: 'postId' } }]}\n/>\n\nType checking redirect options with ValidateRedirectOptions\n\nValidateRedirectOptions type checks object literal types to ensure they conform to redirect options at inference sites. For example, you may need a generic fetchOrRedirect function which accepts a url along with redirectOptions, the idea being this function will redirect when the fetch fails.\n\ntsx\nexport async function fetchOrRedirect<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TOptions,\n>(\n  url: string,\n  redirectOptions: ValidateRedirectOptions<TRouter, TOptions>,\n): Promise<unknown>\nexport async function fetchOrRedirect(\n  url: string,\n  redirectOptions: ValidateRedirectOptions,\n): Promise<unknown> {\n  const response = await fetch(url)\n\n  if (!response.ok && response.status === 401) {\n    throw redirect(redirectOptions)\n  }\n\n  return await response.json()\n}\n\n\nThe result is that redirectOptions passed to fetchOrRedirect is completely type-safe\n\ntsx\nfetchOrRedirect('http://example.com/', { to: '/login' })\n\nType checking navigate options with ValidateNavigateOptions\n\nValidateNavigateOptions type checks object literal types to ensure they conform to navigate options at inference sites. For example, you may want to write a custom hook to enable/disable navigation.\n\ntsx\nexport interface UseConditionalNavigateResult {\n  enable: () => void\n  disable: () => void\n  navigate: () => void\n}\n\nexport function useConditionalNavigate<\n  TRouter extends RegisteredRouter = RegisteredRouter,\n  TOptions,\n>(\n  navigateOptions: ValidateNavigateOptions<TRouter, TOptions>,\n): UseConditionalNavigateResult\nexport function useConditionalNavigate(\n  navigateOptions: ValidateNavigateOptions,\n): UseConditionalNavigateResult {\n  const [enabled, setEnabled] = useState(false)\n  const navigate = useNavigate()\n  return {\n    enable: () => setEnabled(true),\n    disable: () => setEnabled(false),\n    navigate: () => {\n      if (enabled) {\n        navigate(navigateOptions)\n      }\n    },\n  }\n}\n\n\nThe result of this is that navigateOptions passed to useConditionalNavigate is completely type-safe and we can enable/disable navigation based on react state\n\ntsx\nconst { enable, disable, navigate } = useConditionalNavigate({\n  to: '/posts/$postId',\n  params: { postId: 'postId' },\n})\n\nEdit on GitHub\nType Safety\nPreloading\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Data Mutations | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/data-mutations",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nData Mutations\n\nSince TanStack router does not store or cache data, it's role in data mutation is slim to none outside of reacting to potential URL side-effects from external mutation events. That said, we've compiled a list of mutation-related features you might find useful and libraries that implement them.\n\nLook for and use mutation utilities that support:\n\nHandling and caching submission state\nProviding both local and global optimistic UI support\nBuilt-in hooks to wire up invalidation (or automatically support it)\nHandling multiple in-flight mutations at once\nOrganizing mutation state as a globally accessible resource\nSubmission state history and garbage collection\n\nSome suggested libraries:\n\nTanStack Query\nSWR\nRTK Query\nurql\nRelay\nApollo\n\nOr, even...\n\nZustand\nJotai\nRecoil\nRedux\n\nSimilar to data fetching, mutation state isn't a one-size-fits-all solution, so you'll need to pick a solution that fits your needs and your team's needs. We recommend trying out a few different solutions and seeing what works best for you.\n\n‚ö†Ô∏è Still here? Submission state is an interesting topic when it comes to persistence. Do you keep every mutation around forever? How do you know when to get rid of it? What if the user navigates away from the screen and then back? Let's dig in!\n\nInvalidating TanStack Router after a mutation\n\nTanStack Router comes with short-term caching built-in. So even though we're not storing any data after a route match is unmounted, there is a high probability that if any mutations are made related to the data stored in the Router, the current route matches' data could become stale.\n\nWhen mutations related to loader data are made, we can use router.invalidate to force the router to reload all of the current route matches:\n\ntsx\nconst router = useRouter()\n\nconst addTodo = async (todo: Todo) => {\n  try {\n    await api.addTodo()\n    router.invalidate()\n  } catch {\n    //\n  }\n}\n\n\nInvalidating all of the current route matches happens in the background, so existing data will continue to be served until the new data is ready, just as if you were navigating to a new route.\n\nIf you want to await the invalidation until all loaders have finished, pass {sync: true} into router.invalidate:\n\ntsx\nconst router = useRouter()\n\nconst addTodo = async (todo: Todo) => {\n  try {\n    await api.addTodo()\n    await router.invalidate({ sync: true })\n  } catch {\n    //\n  }\n}\n\nLong-term mutation State\n\nRegardless of the mutation library used, mutations often create state related to their submission. While most mutations are set-and-forget, some mutation states are more long-lived, either to support optimistic UI or to provide feedback to the user about the status of their submissions. Most state managers will correctly keep this submission state around and expose it to make it possible to show UI elements like loading spinners, success messages, error messages, etc.\n\nLet's consider the following interactions:\n\nUser navigates to the /posts/123/edit screen to edit a post\nUser edits the 123 post and upon success, sees a success message below the editor that the post was updated\nUser navigates to the /posts screen\nUser navigates back to the /posts/123/edit screen again\n\nWithout notifying your mutation management library about the route change, it's possible that your submission state could still be around and your user would still see the \"Post updated successfully\" message when they return to the previous screen. This is not ideal. Obviously, our intent wasn't to keep this mutation state around forever, right?!\n\nUsing mutation keys\n\nHopefully and hypothetically, the easiest way is for your mutation library to support a keying mechanism that will allow your mutations's state to be reset when the key changes:\n\ntsx\nconst routeApi = getRouteApi('/posts/$postId/edit')\n\nfunction EditPost() {\n  const { roomId } = routeApi.useParams()\n\n  const sendMessageMutation = useCoolMutation({\n    fn: sendMessage,\n    // Clear the mutation state when the roomId changes\n    // including any submission state\n    key: ['sendMessage', roomId],\n  })\n\n  // Fire off a bunch of messages\n  const test = () => {\n    sendMessageMutation.mutate({ roomId, message: 'Hello!' })\n    sendMessageMutation.mutate({ roomId, message: 'How are you?' })\n    sendMessageMutation.mutate({ roomId, message: 'Goodbye!' })\n  }\n\n  return (\n    <>\n      {sendMessageMutation.submissions.map((submission) => {\n        return (\n          <div>\n            <div>{submission.status}</div>\n            <div>{submission.message}</div>\n          </div>\n        )\n      })}\n    </>\n  )\n}\n\nUsing the router.subscribe method\n\nFor libraries that don't have a keying mechanism, we'll likely need to manually reset the mutation state when the user navigates away from the screen. To solve this, we can use TanStack Router's invalidate and subscribe method to clear mutation states when the user is no longer in need of them.\n\nThe router.subscribe method is a function that subscribes a callback to various router events. The event in particular that we'll use here is the onResolved event. It's important to understand that this event is fired when the location path is changed (not just reloaded) and has finally resolved.\n\nThis is a great place to reset your old mutation states. Here's an example:\n\ntsx\nconst router = createRouter()\nconst coolMutationCache = createCoolMutationCache()\n\nconst unsubscribeFn = router.subscribe('onResolved', () => {\n  // Reset mutation states when the route changes\n  coolMutationCache.clear()\n})\n\nEdit on GitHub\nExternal Data Loading\nType Safety\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Preloading | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/preloading",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nPreloading\n\nPreloading in TanStack Router is a way to load a route before the user actually navigates to it. This is useful for routes that are likely to be visited by the user next. For example, if you have a list of posts and the user is likely to click on one of them, you can preload the post route so that it's ready to go when the user clicks on it.\n\nSupported Preloading Strategies\nIntent\nPreloading by \"intent\" works by using hover and touch start events on <Link> components to preload the dependencies for the destination route.\nThis strategy is useful for preloading routes that the user is likely to visit next.\nViewport Visibility\nPreloading by \"viewport\" works by using the Intersection Observer API to preload the dependencies for the destination route when the <Link> component is in the viewport.\nThis strategy is useful for preloading routes that are below the fold or off-screen.\nRender\nPreloading by \"render\" works by preloading the dependencies for the destination route as soon as the <Link> component is rendered in the DOM.\nThis strategy is useful for preloading routes that are always needed.\nHow long does preloaded data stay in memory?\n\nPreloaded route matches are temporarily cached in memory with a few important caveats:\n\nUnused preloaded data is removed after 30 seconds by default. This can be configured by setting the defaultPreloadMaxAge option on your router.\nObviously, when a a route is loaded, its preloaded version is promoted to the router's normal pending matches state.\n\nIf you need more control over preloading, caching and/or garbage collection of preloaded data, you should use an external caching library like TanStack Query.\n\nThe simplest way to preload routes for your application is to set the defaultPreload option to intent for your entire router:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n  defaultPreload: 'intent',\n})\n\n\nThis will turn on intent preloading by default for all <Link> components in your application. You can also set the preload prop on individual <Link> components to override the default behavior.\n\nPreload Delay\n\nBy default, preloading will start after 50ms of the user hovering or touching a <Link> component. You can change this delay by setting the defaultPreloadDelay option on your router:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n  defaultPreloadDelay: 100,\n})\n\n\nYou can also set the preloadDelay prop on individual <Link> components to override the default behavior on a per-link basis.\n\nBuilt-in Preloading & preloadStaleTime\n\nIf you're using the built-in loaders, you can control how long preloaded data is considered fresh until another preload is triggered by setting either routerOptions.defaultPreloadStaleTime or routeOptions.preloadStaleTime to a number of milliseconds. By default, preloaded data is considered fresh for 30 seconds..\n\nTo change this, you can set the defaultPreloadStaleTime option on your router:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n  defaultPreloadStaleTime: 10_000,\n})\n\n\nOr, you can use the routeOptions.preloadStaleTime option on individual routes:\n\ntsx\n// src/routes/posts.$postId.tsx\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params }) => fetchPost(params.postId),\n  // Preload the route again if the preload cache is older than 10 seconds\n  preloadStaleTime: 10_000,\n})\n\nPreloading with External Libraries\n\nWhen integrating external caching libraries like React Query, which have their own mechanisms for determining stale data, you may want to override the default preloading and stale-while-revalidate logic of TanStack Router. These libraries often use options like staleTime to control the freshness of data.\n\nTo customize the preloading behavior in TanStack Router and fully leverage your external library's caching strategy, you can bypass the built-in caching by setting routerOptions.defaultPreloadStaleTime or routeOptions.preloadStaleTime to 0. This ensures that all preloads are marked as stale internally, and loaders are always invoked, allowing your external library, such as React Query, to manage data loading and caching.\n\nFor example:\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n  defaultPreloadStaleTime: 0,\n})\n\n\nThis would then allow you, for instance, to use an option like React Query's staleTime to control the freshness of your preloads.\n\nPreloading Manually\n\nIf you need to manually preload a route, you can use the router's preloadRoute method. It accepts a standard TanStack NavigateOptions object and returns a promise that resolves when the route is preloaded.\n\ntsx\nfunction Component() {\n  const router = useRouter()\n\n  useEffect(() => {\n    async function preload() {\n      try {\n        const matches = await router.preloadRoute({\n          to: postRoute,\n          params: { id: 1 },\n        })\n      } catch (err) {\n        // Failed to preload route\n      }\n    }\n\n    preload()\n  }, [router])\n\n  return <div />\n}\n\n\nIf you need to preload only the JS chunk of a route, you can use the router's loadRouteChunk method. It accepts a route object and returns a promise that resolves when the route chunk is loaded.\n\ntsx\nfunction Component() {\n  const router = useRouter()\n\n  useEffect(() => {\n    async function preloadRouteChunks() {\n      try {\n        const postsRoute = router.routesByPath['/posts']\n        await Promise.all([\n          router.loadRouteChunk(router.routesByPath['/']),\n          router.loadRouteChunk(postsRoute),\n          router.loadRouteChunk(postsRoute.parentRoute),\n        ])\n      } catch (err) {\n        // Failed to preload route chunk\n      }\n    }\n\n    preloadRouteChunks()\n  }, [router])\n\n  return <div />\n}\n\nEdit on GitHub\nType Utilities\nDocument Head Management\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "External Data Loading | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nExternal Data Loading\n\nImportant\n\nThis guide is geared towards external state management libraries and their integration with TanStack Router for data fetching, ssr, hydration/dehydration and streaming. If you haven't read the standard Data Loading guide, please do so first.\n\nTo Store or to Coordinate?\n\nWhile Router is very capable of storing and managing most data needs out of the box, sometimes you just might want something more robust!\n\nRouter is designed to be a perfect coordinator for external data fetching and caching libraries. This means that you can use any data fetching/caching library you want, and the router will coordinate the loading of your data in a way that aligns with your users' navigation and expectations of freshness.\n\nWhat data fetching libraries are supported?\n\nAny data fetching library that supports asynchronous promises can be used with TanStack Router. This includes:\n\nTanStack Query\nSWR\nRTK Query\nurql\nRelay\nApollo\n\nOr, even...\n\nZustand\nJotai\nRecoil\nRedux\n\nLiterally any library that can return a promise and read/write data can be integrated.\n\nUsing Loaders to ensure data is loaded\n\nThe easiest way to use integrate and external caching/data library into Router is to use route.loaders to ensure that the data required inside of a route has been loaded and is ready to be displayed.\n\n‚ö†Ô∏è BUT WHY? It's very important to preload your critical render data in the loader for a few reasons:\n\nNo \"flash of loading\" states\nNo waterfall data fetching, caused by component based fetching\nBetter for SEO. If your data is available at render time, it will be indexed by search engines.\n\nHere is a naive illustration (don't do this) of using a Route's loader option to seed the cache for some data:\n\ntsx\n// src/routes/posts.tsx\nlet postsCache = []\n\nexport const Route = createFileRoute('/posts')({\n  loader: async () => {\n    postsCache = await fetchPosts()\n  },\n  component: () => {\n    return (\n      <div>\n        {postsCache.map((post) => (\n          <Post key={post.id} post={post} />\n        ))}\n      </div>\n    )\n  },\n})\n\n\nThis example is obviously flawed, but illustrates the point that you can use a route's loader option to seed your cache with data. Let's take a look at a more realistic example using TanStack Query.\n\nReplace fetchPosts with your preferred data fetching library's prefetching API\nReplace postsCache with your preferred data fetching library's read-or-fetch API or hook\nA more realistic example using TanStack Query\n\nLet's take a look at a more realistic example using TanStack Query.\n\ntsx\n// src/routes/posts.tsx\nconst postsQueryOptions = queryOptions({\n  queryKey: ['posts'],\n  queryFn: () => fetchPosts(),\n})\n\nexport const Route = createFileRoute('/posts')({\n  // Use the `loader` option to ensure that the data is loaded\n  loader: () => queryClient.ensureQueryData(postsQueryOptions),\n  component: () => {\n    // Read the data from the cache and subscribe to updates\n    const {\n      data: { posts },\n    } = useSuspenseQuery(postsQueryOptions)\n\n    return (\n      <div>\n        {posts.map((post) => (\n          <Post key={post.id} post={post} />\n        ))}\n      </div>\n    )\n  },\n})\n\nError handling with TanStack Query\n\nWhen an error occurs while using suspense with Tanstack Query, you'll need to let queries know that you want to try again when re-rendering. This can be done by using the reset function provided by the useQueryErrorResetBoundary hook. We can invoke this function in an effect as soon as the error component mounts. This will make sure that the query is reset and will try to fetch data again when the route component is rendered again. This will also cover cases where users navigate away from our route instead of clicking the retry button.\n\ntsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => queryClient.ensureQueryData(postsQueryOptions),\n  errorComponent: ({ error, reset }) => {\n    const router = useRouter()\n    const queryErrorResetBoundary = useQueryErrorResetBoundary()\n\n    useEffect(() => {\n      // Reset the query error boundary\n      queryErrorResetBoundary.reset()\n    }, [queryErrorResetBoundary])\n\n    return (\n      <div>\n        {error.message}\n        <button\n          onClick={() => {\n            // Invalidate the route to reload the loader, and reset any router error boundaries\n            router.invalidate()\n          }}\n        >\n          retry\n        </button>\n      </div>\n    )\n  },\n})\n\nSSR Dehydration/Hydration\n\nTools that are able can integrate with TanStack Router's convenient Dehydration/Hydration APIs to shuttle dehydrated data between the server and client and rehydrate it where needed. Let's go over how to do this with both 3rd party critical data and 3rd party deferred data.\n\nCritical Dehydration/Hydration\n\nFor critical data needed for the first render/paint, TanStack Router supports dehydrate and hydrate options when configuring the Router. These callbacks are functions that are automatically called on the server and client when the router dehydrates and hydrates normally and allow you to augment the dehydrated data with your own data.\n\nThe dehydrate function can return any serializable JSON data which will get merged and injected into the dehydrated payload that is sent to the client. This payload is delivered via the DehydrateRouter component which, when rendered, provides the data back to you in the hydrate function on the client.\n\nFor example, let's dehydrate and hydrate a TanStack Query QueryClient so that our data we fetched on the server will be available for hydration on the client.\n\ntsx\n// src/router.tsx\n\nexport function createRouter() {\n  // Make sure you create your loader client or similar data\n  // stores inside of your `createRouter` function. This ensures\n  // that your data stores are unique to each request and\n  // always present on both server and client.\n  const queryClient = new QueryClient()\n\n  return createRouter({\n    routeTree,\n    // Optionally provide your loaderClient to the router context for\n    // convenience (you can provide anything you want to the router\n    // context!)\n    context: {\n      queryClient,\n    },\n    // On the server, dehydrate the loader client so the router\n    // can serialize it and send it to the client for us\n    dehydrate: () => {\n      return {\n        queryClientState: dehydrate(queryClient),\n      }\n    },\n    // On the client, hydrate the loader client with the data\n    // we dehydrated on the server\n    hydrate: (dehydrated) => {\n      hydrate(queryClient, dehydrated.queryClientState)\n    },\n    // Optionally, we can use `Wrap` to wrap our router in the loader client provider\n    Wrap: ({ children }) => {\n      return (\n        <QueryClientProvider client={queryClient}>\n          {children}\n        </QueryClientProvider>\n      )\n    },\n  })\n}\n\nEdit on GitHub\nDeferred Data Loading\nData Mutations\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Deferred Data Loading | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/deferred-data-loading",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nDeferred Data Loading\n\nTanStack Router is designed to run loaders in parallel and wait for all of them to resolve before rendering the next route. This is great most of the time, but occasionally, you may want to show the user something sooner while the rest of the data loads in the background.\n\nDeferred data loading is a pattern that allows the router to render the next location's critical data/markup while slower, non-critical route data is resolved in the background. This process works on both the client and server (via streaming) and is a great way to improve the perceived performance of your application.\n\nIf you are using a library like TanStack Query or any other data fetching library, then deferred data loading works a bit differently. Skip ahead to the Deferred Data Loading with External Libraries section for more information.\n\nDeferred Data Loading with Await\n\nTo defer slow or non-critical data, return an unawaited/unresolved promise anywhere in your loader response:\n\ntsx\n// src/routes/posts.$postId.tsx\nimport { createFileRoute, defer } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async () => {\n    // Fetch some slower data, but do not await it\n    const slowDataPromise = fetchSlowData()\n\n    // Fetch and await some data that resolves quickly\n    const fastData = await fetchFastData()\n\n    return {\n      fastData,\n      deferredSlowData: slowDataPromise,\n    }\n  },\n})\n\n\nAs soon as any awaited promises are resolved, the next route will begin rendering while the deferred promises continue to resolve.\n\nIn the component, deferred promises can be resolved and utilized using the Await component:\n\ntsx\n// src/routes/posts.$postId.tsx\nimport { createFileRoute, Await } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  // ...\n  component: PostIdComponent,\n})\n\nfunction PostIdComponent() {\n  const { deferredSlowData, fastData } = Route.useLoaderData()\n\n  // do something with fastData\n\n  return (\n    <Await promise={deferredSlowData} fallback={<div>Loading...</div>}>\n      {(data) => {\n        return <div>{data}</div>\n      }}\n    </Await>\n  )\n}\n\n\nTip\n\nIf your component is code-split, you can use the getRouteApi function to avoid having to import the Route configuration to get access to the typed useLoaderData() hook.\n\nThe Await component resolves the promise by triggering the nearest suspense boundary until it is resolved, after which it renders the component's children as a function with the resolved data.\n\nIf the promise is rejected, the Await component will throw the serialized error, which can be caught by the nearest error boundary.\n\nTip\n\nIn React 19, you can use the use() hook instead of Await\n\nDeferred Data Loading with External libraries\n\nWhen your strategy for fetching information for the route relies on External Data Loading with an external library like TanStack Query, deferred data loading works a bit differently, as the library handles the data fetching and caching for you outside of TanStack Router.\n\nSo, instead of using defer and Await, you'll instead want to use the Route's loader to kick off the data fetching and then use the library's hooks to access the data in your components.\n\ntsx\n// src/routes/posts.$postId.tsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { slowDataOptions, fastDataOptions } from '~/api/query-options'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ context: { queryClient } }) => {\n    // Kick off the fetching of some slower data, but do not await it\n    queryClient.prefetchQuery(slowDataOptions())\n\n    // Fetch and await some data that resolves quickly\n    await queryClient.ensureQueryData(fastDataOptions())\n  },\n})\n\n\nThen in your component, you can use the library's hooks to access the data:\n\ntsx\n// src/routes/posts.$postId.tsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { useSuspenseQuery } from '@tanstack/react-query'\nimport { slowDataOptions, fastDataOptions } from '~/api/query-options'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  // ...\n  component: PostIdComponent,\n})\n\nfunction PostIdComponent() {\n  const fastData = useSuspenseQuery(fastDataOptions())\n\n  // do something with fastData\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <SlowDataComponent />\n    </Suspense>\n  )\n}\n\nfunction SlowDataComponent() {\n  const data = useSuspenseQuery(slowDataOptions())\n\n  return <div>{data}</div>\n}\n\nCaching and Invalidation\n\nStreamed promises follow the same lifecycle as the loader data they are associated with. They can even be preloaded!\n\nSSR & Streaming Deferred Data\n\nStreaming requires a server that supports it and for TanStack Router to be configured to use it properly.\n\nPlease read the entire Streaming SSR Guide for step by step instructions on how to set up your server for streaming.\n\nSSR Streaming Lifecycle\n\nThe following is a high-level overview of how deferred data streaming works with TanStack Router:\n\nServer\nPromises are marked and tracked as they are returned from route loaders\nAll loaders resolve and any deferred promises are serialized and embedded into the html\nThe route begins to render\nDeferred promises rendered with the <Await> component trigger suspense boundaries, allowing the server to stream html up to that point\nClient\nThe client receives the initial html from the server\n<Await> components suspend with placeholder promises while they wait for their data to resolve on the server\nServer\nAs deferred promises resolve, their results (or errors) are serialized and streamed to the client via an inline script tag\nThe resolved <Await> components and their suspense boundaries are resolved and their resulting HTML is streamed to the client along with their dehydrated data\nClient\nThe suspended placeholder promises within <Await> are resolved with the streamed data/error responses and either render the result or throw the error to the nearest error boundary\nEdit on GitHub\nData Loading\nExternal Data Loading\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Data Loading | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/data-loading",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nData Loading\n\nData loading is a common concern for web applications and is related to routing. When loading a page for your app, it's ideal if all of the page's async requirements are fetched and fulfilled as early as possible, in parallel. The router is the best place to coordinate these async dependencies as it's usually the only place in your app that knows where users are headed before content is rendered.\n\nYou may be familiar with getServerSideProps from Next.js or loaders from Remix/React-Router. TanStack Router has similar functionality to preload/load assets on a per-route basis in parallel allowing it to render as quickly as possible as it fetches via suspense.\n\nBeyond these normal expectations of a router, TanStack Router goes above and beyond and provides built-in SWR Caching, a long-term in-memory caching layer for route loaders. This means that you can use TanStack Router to both preload data for your routes so they load instantaneously or temporarily cache route data for previously visited routes to use again later.\n\nThe route loading lifecycle\n\nEvery time a URL/history update is detected, the router executes the following sequence:\n\nRoute Matching (Top-Down)\nroute.params.parse\nroute.validateSearch\nRoute Pre-Loading (Serial)\nroute.beforeLoad\nroute.onError\nroute.errorComponent / parentRoute.errorComponent / router.defaultErrorComponent\nRoute Loading (Parallel)\nroute.component.preload?\nroute.loader\nroute.pendingComponent (Optional)\nroute.component\nroute.onError\nroute.errorComponent / parentRoute.errorComponent / router.defaultErrorComponent\nTo Router Cache or not to Router Cache?\n\nThere is a high possibility that TanStack's router cache will be a good fit for most smaller to medium size applications, but it's important to understand the tradeoffs of using it vs a more robust caching solution like TanStack Query:\n\nTanStack Router Cache Pros:\n\nBuilt-in, easy to use, no extra dependencies\nHandles deduping, preloading, loading, stale-while-revalidate, background refetching on a per-route basis\nCoarse invalidation (invalidate all routes and cache at once)\nAutomatic garbage collection\nWorks great for apps that share little data between routes\n\"Just works\" for SSR\n\nTanStack Router Cache Cons:\n\nNo persistence adapters/model\nNo shared caching/deduping between routes\nNo built-in mutation APIs (a basic useMutation hook is provided in many examples that may be sufficient for many use cases)\nNo built-in cache-level optimistic update APIs (you can still use ephemeral state from something like a useMutation hook to achieve this at the component level)\n\nTip\n\nIf you know right away that you'd like to or need to use something more robust like TanStack Query, skip to the External Data Loading guide.\n\nUsing the Router Cache\n\nThe router cache is built-in and is as easy as returning data from any route's loader function. Let's learn how!\n\nRoute loaders\n\nRoute loader functions are called when a route match is loaded. They are called with a single parameter which is an object containing many helpful properties. We'll go over those in a bit, but first, let's look at an example of a route loader function:\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n})\n\nloader Parameters\n\nThe loader function receives a single object with the following properties:\n\nabortController - The route's abortController. Its signal is cancelled when the route is unloaded or when the Route is no longer relevant and the current invocation of the loader function becomes outdated.\ncause - The cause of the current route match, either enter or stay.\ncontext - The route's context object, which is a merged union of:\nParent route context\nThis route's context as provided by the beforeLoad option\ndeps - The object value returned from the Route.loaderDeps function. If Route.loaderDeps is not defined, an empty object will be provided instead.\nlocation - The current location\nparams - The route's path params\nparentMatchPromise - Promise<RouteMatch> (undefined for the root route)\npreload - Boolean which is true when the route is being preloaded instead of loaded\nroute - The route itself\n\nUsing these parameters, we can do a lot of cool things, but first, let's take a look at how we can control it and when the loader function is called.\n\nConsuming data from loaders\n\nTo consume data from a loader, use the useLoaderData hook defined on your Route object.\n\ntsx\nconst posts = Route.useLoaderData()\n\n\nIf you don't have ready access to your route object (i.e. you're deep in the component tree for the current route), you can use getRouteApi to access the same hook (as well as the other hooks on the Route object). This should be preferred over importing the Route object, which is likely to create circular dependencies.\n\ntsx\nimport { getRouteApi } from '@tanstack/react-router'\n\n// in your component\n\nconst routeApi = getRouteApi('/posts')\nconst data = routeApi.useLoaderData()\n\nDependency-based Stale-While-Revalidate Caching\n\nTanStack Router provides a built-in Stale-While-Revalidate caching layer for route loaders that is keyed on the dependencies of a route:\n\nThe route's fully parsed pathname\ne.g. /posts/1 vs /posts/2\nAny additional dependencies provided by the loaderDeps option\ne.g. loaderDeps: ({ search: { pageIndex, pageSize } }) => ({ pageIndex, pageSize })\n\nUsing these dependencies as keys, TanStack Router will cache the data returned from a route's loader function and use it to fulfill subsequent requests for the same route match. This means that if a route's data is already in the cache, it will be returned immediately, then potentially be refetched in the background depending on the \"freshness\" of the data.\n\nKey options\n\nTo control router dependencies and \"freshness\", TanStack Router provides a plethora of options to control the keying and caching behavior of your route loaders. Let's take a look at them in the order that you are most likely to use them:\n\nrouteOptions.loaderDeps\nA function that supplies you the search params for a router and returns an object of dependencies for use in your loader function. When these deps changed from navigation to navigation, it will cause the route to reload regardless of staleTimes. The deps are compared using a deep equality check.\nrouteOptions.staleTime\nrouterOptions.defaultStaleTime\nThe number of milliseconds that a route's data should be considered fresh when attempting to load.\nrouteOptions.preloadStaleTime\nrouterOptions.defaultPreloadStaleTime\nThe number of milliseconds that a route's data should be considered fresh attempting to preload.\nrouteOptions.gcTime\nrouterOptions.defaultGcTime\nThe number of milliseconds that a route's data should be kept in the cache before being garbage collected.\nrouteOptions.shouldReload\nA function that receives the same beforeLoad and loaderContext parameters and returns a boolean indicating if the route should reload. This offers one more level of control over when a route should reload beyond staleTime and loaderDeps and can be used to implement patterns similar to Remix's shouldLoad option.\n‚ö†Ô∏è Some Important Defaults\nBy default, the staleTime is set to 0, meaning that the route's data will always be considered stale and will always be reloaded in the background when the route is rematched.\nBy default, a previously preloaded route is considered fresh for 30 seconds. This means if a route is preloaded, then preloaded again within 30 seconds, the second preload will be ignored. This prevents unnecessary preloads from happening too frequently. When a route is loaded normally, the standard staleTime is used.\nBy default, the gcTime is set to 30 minutes, meaning that any route data that has not been accessed in 30 minutes will be garbage collected and removed from the cache.\nrouter.invalidate() will force all active routes to reload their loaders immediately and mark every cached route's data as stale.\nUsing loaderDeps to access search params\n\nImagine a /posts route supports some pagination via search params offset and limit. For the cache to uniquely store this data, we need to access these search params via the loaderDeps function. By explicitly identifying them, each route match for /posts with different offset and limit won't get mixed up!\n\nOnce we have these deps in place, the route will always reload when the deps change.\n\ntsx\n// /routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loaderDeps: ({ search: { offset, limit } }) => ({ offset, limit }),\n  loader: ({ deps: { offset, limit } }) =>\n    fetchPosts({\n      offset,\n      limit,\n    }),\n})\n\nUsing staleTime to control how long data is considered fresh\n\nBy default, staleTime for navigations is set to 0ms (and 30 seconds for preloads) which means that the route's data will always be considered stale and will always be reloaded in the background when the route is matched and navigated to.\n\nThis is a good default for most use cases, but you may find that some route data is more static or potentially expensive to load. In these cases, you can use the staleTime option to control how long the route's data is considered fresh for navigations. Let's take a look at an example:\n\ntsx\n// /routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  // Consider the route's data fresh for 10 seconds\n  staleTime: 10_000,\n})\n\n\nBy passing 10_000 to the staleTime option, we are telling the router to consider the route's data fresh for 10 seconds. This means that if the user navigates to /posts from /about within 10 seconds of the last loader result, the route's data will not be reloaded. If the user then navigates to /posts from /about after 10 seconds, the route's data will be reloaded in the background.\n\nTurning off stale-while-revalidate caching\n\nTo disable stale-while-revalidate caching for a route, set the staleTime option to Infinity:\n\ntsx\n// /routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  staleTime: Infinity,\n})\n\n\nYou can even turn this off for all routes by setting the defaultStaleTime option on the router:\n\ntsx\nconst router = createRouter({\n  routeTree,\n  defaultStaleTime: Infinity,\n})\n\nUsing shouldReload and gcTime to opt-out of caching\n\nSimilar to Remix's default functionality, you may want to configure a route to only load on entry or when critical loader deps change. You can do this by using the gcTime option combined with the shouldReload option, which accepts either a boolean or a function that receives the same beforeLoad and loaderContext parameters and returns a boolean indicating if the route should reload.\n\ntsx\n// /routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loaderDeps: ({ search: { offset, limit } }) => ({ offset, limit }),\n  loader: ({ deps }) => fetchPosts(deps),\n  // Do not cache this route's data after it's unloaded\n  gcTime: 0,\n  // Only reload the route when the user navigates to it or when deps change\n  shouldReload: false,\n})\n\nOpting out of caching while still preloading\n\nEven though you may opt-out of short-term caching for your route data, you can still get the benefits of preloading! With the above configuration, preloading will still \"just work\" with the default preloadGcTime. This means that if a route is preloaded, then navigated to, the route's data will be considered fresh and will not be reloaded.\n\nTo opt out of preloading, don't turn it on via the routerOptions.defaultPreload or routeOptions.preload options.\n\nPassing all loader events to an external cache\n\nWe break down this use case in the External Data Loading page, but if you'd like to use an external cache like TanStack Query, you can do so by passing all loader events to your external cache. As long as you are using the defaults, the only change you'll need to make is to set the defaultPreloadStaleTime option on the router to 0:\n\ntsx\nconst router = createRouter({\n  routeTree,\n  defaultPreloadStaleTime: 0,\n})\n\n\nThis will ensure that every preload, load, and reload event will trigger your loader functions, which can then be handled and deduped by your external cache.\n\nUsing Router Context\n\nThe context argument passed to the loader function is an object containing a merged union of:\n\nParent route context\nThis route's context as provided by the beforeLoad option\n\nStarting at the very top of the router, you can pass an initial context to the router via the context option. This context will be available to all routes in the router and get copied and extended by each route as they are matched. This happens by passing a context to a route via the beforeLoad option. This context will be available to all the route's child routes. The resulting context will be available to the route's loader function.\n\nIn this example, we'll create a function in our route context to fetch posts, then use it in our loader function.\n\nüß† Context is a powerful tool for dependency injection. You can use it to inject services, hooks, and other objects into your router and routes. You can also additively pass data down the route tree at every route using a route's beforeLoad option.\n\n/utils/fetchPosts.tsx\ntsx\nexport const fetchPosts = async () => {\n  const res = await fetch(`/api/posts?page=${pageIndex}`)\n  if (!res.ok) throw new Error('Failed to fetch posts')\n  return res.json()\n}\n\n/routes/__root.tsx\ntsx\nimport { createRootRouteWithContext } from '@tanstack/react-router'\n\n// Create a root route using the createRootRouteWithContext<{...}>() function and pass it whatever types you would like to be available in your router context.\nexport const Route = createRootRouteWithContext<{\n  fetchPosts: typeof fetchPosts\n}>()() // NOTE: the double call is on purpose, since createRootRouteWithContext is a factory ;)\n\n/routes/posts.tsx\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\n// Notice how our postsRoute references context to get our fetchPosts function\n// This can be a powerful tool for dependency injection across your router\n// and routes.\nexport const Route = createFileRoute('/posts')({\n  loader: ({ context: { fetchPosts } }) => fetchPosts(),\n})\n\n/router.tsx\ntsx\nimport { routeTree } from './routeTree.gen'\n\n// Use your routerContext to create a new router\n// This will require that you fullfil the type requirements of the routerContext\nconst router = createRouter({\n  routeTree,\n  context: {\n    // Supply the fetchPosts function to the router context\n    fetchPosts,\n  },\n})\n\nUsing Path Params\n\nTo use path params in your loader function, access them via the params property on the function's parameters. Here's an example:\n\ntsx\n// routes/posts.$postId.tsx\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: ({ params: { postId } }) => fetchPostById(postId),\n})\n\nUsing Route Context\n\nPassing down global context to your router is great, but what if you want to provide context that is specific to a route? This is where the beforeLoad option comes in. The beforeLoad option is a function that runs right before attempting to load a route and receives the same parameters as loader. Beyond its ability to redirect potential matches, block loader requests, etc, it can also return an object that will be merged into the route's context. Let's take a look at an example where we inject some data into our route context via the beforeLoad option:\n\ntsx\n// /routes/posts.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  // Pass the fetchPosts function to the route context\n  beforeLoad: () => ({\n    fetchPosts: () => console.info('foo'),\n  }),\n  loader: ({ context: { fetchPosts } }) => {\n    console.info(fetchPosts()) // 'foo'\n\n    // ...\n  },\n})\n\nUsing Search Params in Loaders\n\n‚ùì But wait Tanner... where the heck are my search params?!\n\nYou might be here wondering why search isn't directly available in the loader function's parameters. We've purposefully designed it this way to help you succeed. Let's take a look at why:\n\nSearch Parameters being used in a loader function are a very good indicator that those search params should also be used to uniquely identify the data being loaded. For example, you may have a route that uses a search param like pageIndex that uniquely identifies the data held inside of the route match. Or, imagine a /users/user route that uses the search param userId to identify a specific user in your application, you might model your url like this: /users/user?userId=123. This means that your user route would need some extra help to identify a specific user.\nDirectly accessing search params in a loader function can lead to bugs in caching and preloading where the data being loaded is not unique to the current URL pathname and search params. For example, you might ask your /posts route to preload page 2's results, but without the distinction of pages in your route configuration, you will end up fetching, storing and displaying page 2's data on your /posts or ?page=1 screen instead of it preloading in the background!\nPlacing a threshold between search parameters and the loader function allows the router to understand your dependencies and reactivity.\ntsx\n// /routes/users.user.tsx\nexport const Route = createFileRoute('/users/user')({\n  validateSearch: (search) =>\n    search as {\n      userId: string\n    },\n  loaderDeps: ({ search: { userId } }) => ({\n    userId,\n  }),\n  loader: async ({ deps: { userId } }) => getUser(userId),\n})\n\nAccessing Search Params via routeOptions.loaderDeps\ntsx\n// /routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  // Use zod to validate and parse the search params\n  validateSearch: z.object({\n    offset: z.number().int().nonnegative().catch(0),\n  }),\n  // Pass the offset to your loader deps via the loaderDeps function\n  loaderDeps: ({ search: { offset } }) => ({ offset }),\n  // Use the offset from context in the loader function\n  loader: async ({ deps: { offset } }) =>\n    fetchPosts({\n      offset,\n    }),\n})\n\nUsing the Abort Signal\n\nThe abortController property of the loader function is an AbortController. Its signal is cancelled when the route is unloaded or when the loader call becomes outdated. This is useful for cancelling network requests when the route is unloaded or when the route's params change. Here is an example using it with a fetch call:\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: ({ abortController }) =>\n    fetchPosts({\n      // Pass this to an underlying fetch call or anything that supports signals\n      signal: abortController.signal,\n    }),\n})\n\nUsing the preload flag\n\nThe preload property of the loader function is a boolean which is true when the route is being preloaded instead of loaded. Some data loading libraries may handle preloading differently than a standard fetch, so you may want to pass preload to your data loading library, or use it to execute the appropriate data loading logic:\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: async ({ preload }) =>\n    fetchPosts({\n      maxAge: preload ? 10_000 : 0, // Preloads should hang around a bit longer\n    }),\n})\n\nHandling Slow Loaders\n\nIdeally most route loaders can resolve their data within a short moment, removing the need to render a placeholder spinner and simply rely on suspense to render the next route when it's completely ready. When critical data that is required to render a route's component is slow though, you have 2 options:\n\nSplit up your fast and slow data into separate promises and defer the slow data until after the fast data is loaded (see the Deferred Data Loading guide).\nShow a pending component after an optimistic suspense threshold until all of the data is ready (See below).\nShowing a pending component\n\nBy default, TanStack Router will show a pending component for loaders that take longer than 1 second to resolve. This is an optimistic threshold that can be configured via:\n\nrouteOptions.pendingMs or\nrouterOptions.defaultPendingMs\n\nWhen the pending time threshold is exceeded, the router will render the pendingComponent option of the route, if configured.\n\nAvoiding Pending Component Flash\n\nIf you're using a pending component, the last thing you want is for your pending time threshold to be met, then have your data resolve immediately after, resulting in a jarring flash of your pending component. To avoid this, TanStack Router by default will show your pending component for at least 500ms. This is an optimistic threshold that can be configured via:\n\nrouteOptions.pendingMinMs or\nrouterOptions.defaultPendingMinMs\nHandling Errors\n\nTanStack Router provides a few ways to handle errors that occur during the route loading lifecycle. Let's take a look at them.\n\nHandling Errors with routeOptions.onError\n\nThe routeOptions.onError option is a function that is called when an error occurs during the route loading.\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  onError: ({ error }) => {\n    // Log the error\n    console.error(error)\n  },\n})\n\nHandling Errors with routeOptions.onCatch\n\nThe routeOptions.onCatch option is a function that is called whenever an error was caught by the router's CatchBoundary.\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  onCatch: ({ error, errorInfo }) => {\n    // Log the error\n    console.error(error)\n  },\n})\n\nHandling Errors with routeOptions.errorComponent\n\nThe routeOptions.errorComponent option is a component that is rendered when an error occurs during the route loading or rendering lifecycle. It is rendered with the following props:\n\nerror - The error that occurred\nreset - A function to reset the internal CatchBoundary\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  errorComponent: ({ error }) => {\n    // Render an error message\n    return <div>{error.message}</div>\n  },\n})\n\n\nThe reset function can be used to allow the user to retry rendering the error boundaries normal children:\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  errorComponent: ({ error, reset }) => {\n    return (\n      <div>\n        {error.message}\n        <button\n          onClick={() => {\n            // Reset the router error boundary\n            reset()\n          }}\n        >\n          retry\n        </button>\n      </div>\n    )\n  },\n})\n\n\nIf the error was the result of a route load, you should instead call router.invalidate(), which will coordinate both a router reload and an error boundary reset:\n\ntsx\n// routes/posts.tsx\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  errorComponent: ({ error, reset }) => {\n    const router = useRouter()\n\n    return (\n      <div>\n        {error.message}\n        <button\n          onClick={() => {\n            // Invalidate the route to reload the loader, which will also reset the error boundary\n            router.invalidate()\n          }}\n        >\n          retry\n        </button>\n      </div>\n    )\n  },\n})\n\nUsing the default ErrorComponent\n\nTanStack Router provides a default ErrorComponent that is rendered when an error occurs during the route loading or rendering lifecycle. If you choose to override your routes' error components, it's still wise to always fall back to rendering any uncaught errors with the default ErrorComponent:\n\ntsx\n// routes/posts.tsx\nimport { createFileRoute, ErrorComponent } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  errorComponent: ({ error }) => {\n    if (error instanceof MyCustomError) {\n      // Render a custom error message\n      return <div>{error.message}</div>\n    }\n\n    // Fallback to the default ErrorComponent\n    return <ErrorComponent error={error} />\n  },\n})\n\nEdit on GitHub\nCustom Links\nDeferred Data Loading\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Custom Link | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/custom-link",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nCustom Link\n\nWhile repeating yourself can be acceptable in many situations, you might find that you do it too often. At times, you may want to create cross-cutting components with additional behavior or styles. You might also consider using third-party libraries in combination with TanStack Router's type safety.\n\ncreateLink for cross-cutting concerns\n\ncreateLink creates a custom Link component with the same type parameters as Link. This means you can create your own component which provides the same type safety and typescript performance as Link.\n\nBasic example\n\nIf you want to create a basic custom link component, you can do so with the following:\n\ntsx\nimport * as React from 'react'\nimport { createLink, LinkComponent } from '@tanstack/react-router'\n\ninterface BasicLinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  // Add any additional props you want to pass to the anchor element\n}\n\nconst BasicLinkComponent = React.forwardRef<HTMLAnchorElement, BasicLinkProps>(\n  (props, ref) => {\n    return (\n      <a ref={ref} {...props} className={'block px-3 py-2 text-blue-700'} />\n    )\n  },\n)\n\nconst CreatedLinkComponent = createLink(BasicLinkComponent)\n\nexport const CustomLink: LinkComponent<typeof BasicLinkComponent> = (props) => {\n  return <CreatedLinkComponent preload={'intent'} {...props} />\n}\n\n\nYou can then use your newly created Link component as any other Link\n\ntsx\n<CustomLink to={'/dashboard/invoices/$invoiceId'} params={{ invoiceId: 0 }} />\n\ncreateLink with third party libraries\n\nHere are some examples of how you can use createLink with third-party libraries.\n\nReact Aria Components example\n\nReact Aria Components' Link component does not support the standard onMouseEnter and onMouseLeave events. Therefore, you cannot use it directly with TanStack Router's preload (intent) prop.\n\nExplanation for this can be found here:\n\nhttps://react-spectrum.adobe.com/react-aria/interactions.html\nhttps://react-spectrum.adobe.com/blog/building-a-button-part-2.html\n\nIt is possible to work around this by using the useLink hook from React Aria Hooks with a standard anchor element.\n\ntsx\nimport * as React from 'react'\nimport { createLink, LinkComponent } from '@tanstack/react-router'\nimport {\n  mergeProps,\n  useFocusRing,\n  useHover,\n  useLink,\n  useObjectRef,\n} from 'react-aria'\nimport type { AriaLinkOptions } from 'react-aria'\n\ninterface RACLinkProps extends Omit<AriaLinkOptions, 'href'> {\n  children?: React.ReactNode\n}\n\nconst RACLinkComponent = React.forwardRef<HTMLAnchorElement, RACLinkProps>(\n  (props, forwardedRef) => {\n    const ref = useObjectRef(forwardedRef)\n\n    const { isPressed, linkProps } = useLink(props, ref)\n    const { isHovered, hoverProps } = useHover(props)\n    const { isFocusVisible, isFocused, focusProps } = useFocusRing(props)\n\n    return (\n      <a\n        {...mergeProps(linkProps, hoverProps, focusProps, props)}\n        ref={ref}\n        data-hovered={isHovered || undefined}\n        data-pressed={isPressed || undefined}\n        data-focus-visible={isFocusVisible || undefined}\n        data-focused={isFocused || undefined}\n      />\n    )\n  },\n)\n\nconst CreatedLinkComponent = createLink(RACLinkComponent)\n\nexport const CustomLink: LinkComponent<typeof RACLinkComponent> = (props) => {\n  return <CreatedLinkComponent preload={'intent'} {...props} />\n}\n\nChakra UI example\ntsx\nimport * as React from 'react'\nimport { createLink, LinkComponent } from '@tanstack/react-router'\nimport { Link } from '@chakra-ui/react'\n\ninterface ChakraLinkProps\n  extends Omit<React.ComponentPropsWithoutRef<typeof Link>, 'href'> {\n  // Add any additional props you want to pass to the link\n}\n\nconst ChakraLinkComponent = React.forwardRef<\n  HTMLAnchorElement,\n  ChakraLinkProps\n>((props, ref) => {\n  return <Link ref={ref} {...props} />\n})\n\nconst CreatedLinkComponent = createLink(ChakraLinkComponent)\n\nexport const CustomLink: LinkComponent<typeof ChakraLinkComponent> = (\n  props,\n) => {\n  return (\n    <CreatedLinkComponent\n      textDecoration={'underline'}\n      _hover={{ textDecoration: 'none' }}\n      _focus={{ textDecoration: 'none' }}\n      preload={'intent'}\n      {...props}\n    />\n  )\n}\n\nMUI example\n\nThere is an example available which uses these patterns.\n\nLink\n\nIf the MUI Link should simply behave like the router Link, it can be just wrapped with createLink:\n\ntsx\nimport { createLink } from '@tanstack/react-router'\nimport { Link } from '@mui/material'\n\nexport const CustomLink = createLink(Link)\n\n\nIf the Link should be customized this approach can be used:\n\ntsx\nimport React from 'react'\nimport { createLink } from '@tanstack/react-router'\nimport { Link } from '@mui/material'\nimport type { LinkProps } from '@mui/material'\nimport type { LinkComponent } from '@tanstack/react-router'\n\ninterface MUILinkProps extends LinkProps {\n  // Add any additional props you want to pass to the Link\n}\n\nconst MUILinkComponent = React.forwardRef<HTMLAnchorElement, MUILinkProps>(\n  (props, ref) => <Link ref={ref} {...props} />,\n)\n\nconst CreatedLinkComponent = createLink(MUILinkComponent)\n\nexport const CustomLink: LinkComponent<typeof MUILinkComponent> = (props) => {\n  return <CreatedLinkComponent preload={'intent'} {...props} />\n}\n\n// Can also be styled\n\nButton\n\nIf a Button should be used as a router Link, the component should be set as a:\n\ntsx\nimport React from 'react'\nimport { createLink } from '@tanstack/react-router'\nimport { Button } from '@mui/material'\nimport type { ButtonProps } from '@mui/material'\nimport type { LinkComponent } from '@tanstack/react-router'\n\ninterface MUIButtonLinkProps extends ButtonProps<'a'> {\n  // Add any additional props you want to pass to the Button\n}\n\nconst MUIButtonLinkComponent = React.forwardRef<\n  HTMLAnchorElement,\n  MUIButtonLinkProps\n>((props, ref) => <Button ref={ref} component=\"a\" {...props} />)\n\nconst CreatedButtonLinkComponent = createLink(MUIButtonLinkComponent)\n\nexport const CustomButtonLink: LinkComponent<typeof MUIButtonLinkComponent> = (\n  props,\n) => {\n  return <CreatedButtonLinkComponent preload={'intent'} {...props} />\n}\n\nUsage with styled\n\nAny of these MUI approaches can then be used with styled:\n\ntsx\nimport { css, styled } from '@mui/material'\nimport { CustomLink } from './CustomLink'\n\nconst StyledCustomLink = styled(CustomLink)(\n  ({ theme }) => css`\n    color: ${theme.palette.common.white};\n  `,\n)\n\nMantine example\ntsx\nimport * as React from 'react'\nimport { createLink, LinkComponent } from '@tanstack/react-router'\nimport { Anchor, AnchorProps } from '@mantine/core'\n\ninterface MantineAnchorProps extends Omit<AnchorProps, 'href'> {\n  // Add any additional props you want to pass to the anchor\n}\n\nconst MantineLinkComponent = React.forwardRef<\n  HTMLAnchorElement,\n  MantineAnchorProps\n>((props, ref) => {\n  return <Anchor ref={ref} {...props} />\n})\n\nconst CreatedLinkComponent = createLink(MantineLinkComponent)\n\nexport const CustomLink: LinkComponent<typeof MantineLinkComponent> = (\n  props,\n) => {\n  return <CreatedLinkComponent preload=\"intent\" {...props} />\n}\n\nEdit on GitHub\nLink Options\nData Loading\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Search Params | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/search-params",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nSearch Params\n\nSimilar to how TanStack Query made handling server-state in your React and Solid applications a breeze, TanStack Router aims to unlock the power of URL search params in your applications.\n\nüß† If you are on a really old browser, like IE11, you may need to use a polyfill for URLSearchParams.\n\nWhy not just use URLSearchParams?\n\nWe get it, you've been hearing a lot of \"use the platform\" lately and for the most part, we agree. However, we also believe it's important to recognize where the platform falls short for more advanced use-cases and we believe URLSearchParams is one of these circumstances.\n\nTraditional Search Param APIs usually assume a few things:\n\nSearch params are always strings\nThey are mostly flat\nSerializing and deserializing using URLSearchParams is good enough (Spoiler alert: it's not.)\nSearch params modifications are tightly coupled with the URL's pathname and must be updated together, even if the pathname is not changing.\n\nReality is very different from these assumptions though.\n\nSearch params represent application state, so inevitably, we will expect them to have the same DX associated with other state managers. This means having the capability of distinguishing between primitive value types and efficiently storing and manipulating complex data structures like nested arrays and objects.\nThere are many ways to serialize and deserialize state with different tradeoffs. You should be able to choose the best one for your application or at the very least get a better default than URLSearchParams.\nImmutability & Structural Sharing. Every time you stringify and parse url search params, referential integrity and object identity is lost because each new parse creates a brand new data structure with a unique memory reference. If not properly managed over its lifetime, this constant serialization and parsing can result in unexpected and undesirable performance issues, especially in frameworks like React that choose to track reactivity via immutability or in Solid that normally relies on reconciliation to detect changes from deserialized data sources.\nSearch params, while an important part of the URL, do frequently change independently of the URL's pathname. For example, a user may want to change the page number of a paginated list without touching the URL's pathname.\nSearch Params, the \"OG\" State Manager\n\nYou've probably seen search params like ?page=3 or ?filter-name=tanner in the URL. There is no question that this is truly a form of global state living inside of the URL. It's valuable to store specific pieces of state in the URL because:\n\nUsers should be able to:\nCmd/Ctrl + Click to open a link in a new tab and reliably see the state they expected\nBookmark and share links from your application with others with assurances that they will see exactly the state as when the link was copied.\nRefresh your app or navigate back and forth between pages without losing their state\nDevelopers should be able to easily:\nAdd, remove or modify state in the URL with the same great DX as other state managers\nEasily validate search params coming from the URL in a format and type that is safe for their application to consume\nRead and write to search params without having to worry about the underlying serialization format\nJSON-first Search Params\n\nTo achieve the above, the first step built in to TanStack Router is a powerful search param parser that automatically converts the search string of your URL to structured JSON. This means that you can store any JSON-serializable data structure in your search params and it will be parsed and serialized as JSON. This is a huge improvement over URLSearchParams which has limited support for array-like structures and nested data.\n\nFor example, navigating to the following route:\n\ntsx\nconst link = (\n  <Link\n    to=\"/shop\"\n    search={{\n      pageIndex: 3,\n      includeCategories: ['electronics', 'gifts'],\n      sortBy: 'price',\n      desc: true,\n    }}\n  />\n)\n\n\nWill result in the following URL:\n\n/shop?pageIndex=3&includeCategories=%5B%22electronics%22%2C%22gifts%22%5D&sortBy=price&desc=true\n\n\nWhen this URL is parsed, the search params will be accurately converted back to the following JSON:\n\njson\n{\n  \"pageIndex\": 3,\n  \"includeCategories\": [\"electronics\", \"gifts\"],\n  \"sortBy\": \"price\",\n  \"desc\": true\n}\n\n\nIf you noticed, there are a few things going on here:\n\nThe first level of the search params is flat and string based, just like URLSearchParams.\nFirst level values that are not strings are accurately preserved as actual numbers and booleans.\nNested data structures are automatically converted to URL-safe JSON strings\n\nüß† It's common for other tools to assume that search params are always flat and string-based which is why we've chosen to keep things URLSearchParam compliant at the first level. This ultimately means that even though TanStack Router is managing your nested search params as JSON, other tools will still be able to write to the URL and read first-level params normally.\n\nValidating and Typing Search Params\n\nDespite TanStack Router being able to parse search params into reliable JSON, they ultimately still came from a user-facing raw-text input. Similar to other serialization boundaries, this means that before you consume search params, they should be validated into a format that your application can trust and rely on.\n\nEnter Validation + TypeScript!\n\nTanStack Router provides convenient APIs for validating and typing search params. This all starts with the Route's validateSearch option:\n\ntsx\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // validate and parse the search params into a typed state\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\n\n\nIn the above example, we're validating the search params of the Route and returning a typed ProductSearch object. This typed object is then made available to this route's other options and any child routes, too!\n\nValidating Search Params\n\nThe validateSearch option is a function that is provided the JSON parsed (but non-validated) search params as a Record<string, unknown> and returns a typed object of your choice. It's usually best to provide sensible fallbacks for malformed or unexpected search params so your users' experience stays non-interrupted.\n\nHere's an example:\n\ntsx\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // validate and parse the search params into a typed state\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\n\n\nHere's an example using the Zod library (but feel free to use any validation library you want) to both validate and type the search params in a single step:\n\ntsx\n// /routes/shop.products.tsx\n\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search) => productSearchSchema.parse(search),\n})\n\n\nBecause validateSearch also accepts an object with the parse property, this can be shortened to:\n\ntsx\nvalidateSearch: productSearchSchema\n\n\nIn the above example, we used Zod's .catch() modifier instead of .default() to avoid showing an error to the user because we firmly believe that if a search parameter is malformed, you probably don't want to halt the user's experience through the app to show a big fat error message. That said, there may be times that you do want to show an error message. In that case, you can use .default() instead of .catch().\n\nThe underlying mechanics why this works relies on the validateSearch function throwing an error. If an error is thrown, the route's onError option will be triggered (and error.routerCode will be set to VALIDATE_SEARCH and the errorComponent will be rendered instead of the route's component where you can handle the search param error however you'd like.\n\nAdapters\n\nWhen using a library like Zod to validate search params you might want to transform search params before committing the search params to the URL. A common zod transform is default for example.\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().default(1),\n  filter: z.string().default(''),\n  sort: z.enum(['newest', 'oldest', 'price']).default('newest'),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n\n\nIt might be surprising that when you try to navigate to this route, search is required. The following Link will type error as search is missing.\n\ntsx\n<Link to=\"/shop/products\" />\n\n\nFor validation libraries we recommend using adapters which infer the correct input and output types.\n\nZod\n\nAn adapter is provided for Zod which will pipe through the correct input type and output type\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().default(1),\n  filter: z.string().default(''),\n  sort: z.enum(['newest', 'oldest', 'price']).default('newest'),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator(productSearchSchema),\n})\n\n\nThe important part here is the following use of Link no longer requires search params\n\ntsx\n<Link to=\"/shop/products\" />\n\n\nHowever the use of catch here overrides the types and makes page, filter and sort unknown causing type loss. We have handled this case by providing a fallback generic function which retains the types but provides a fallback value when validation fails\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { fallback, zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: fallback(z.number(), 1).default(1),\n  filter: fallback(z.string(), '').default(''),\n  sort: fallback(z.enum(['newest', 'oldest', 'price']), 'newest').default(\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator(productSearchSchema),\n})\n\n\nTherefore when navigating to this route, search is optional and retains the correct types.\n\nWhile not recommended, it is also possible to configure input and output type in case the output type is more accurate than the input type\n\ntsx\nconst productSearchSchema = z.object({\n  page: fallback(z.number(), 1).default(1),\n  filter: fallback(z.string(), '').default(''),\n  sort: fallback(z.enum(['newest', 'oldest', 'price']), 'newest').default(\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator({\n    schema: productSearchSchema,\n    input: 'output',\n    output: 'input',\n  }),\n})\n\n\nThis provides flexibility in which type you want to infer for navigation and which types you want to infer for reading search params.\n\nValibot\n\nWarning\n\nRouter expects the valibot 1.0 package to be installed.\n\nWhen using Valibot an adapter is not needed to ensure the correct input and output types are used for navigation and reading search params. This is because valibot implements Standard Schema\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport * as v from 'valibot'\n\nconst productSearchSchema = v.object({\n  page: v.optional(v.fallback(v.number(), 1), 1),\n  filter: v.optional(v.fallback(v.string(), ''), ''),\n  sort: v.optional(\n    v.fallback(v.picklist(['newest', 'oldest', 'price']), 'newest'),\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n\nArktype\n\nWarning\n\nRouter expects the arktype 2.0-rc package to be installed.\n\nWhen using ArkType an adapter is not needed to ensure the correct input and output types are used for navigation and reading search params. This is because ArkType implements Standard Schema\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { type } from 'arktype'\n\nconst productSearchSchema = type({\n  page: 'number = 1',\n  filter: 'string = \"\"',\n  sort: '\"newest\" | \"oldest\" | \"price\" = \"newest\"',\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n\nEffect/Schema\n\nWhen using Effect/Schema an adapter is not needed to ensure the correct input and output types are used for navigation and reading search params. This is because Effect/Schema implements Standard Schema\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { Schema as S } from 'effect'\n\nconst productSearchSchema = S.standardSchemaV1(\n  S.Struct({\n    page: S.NumberFromString.pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => 1,\n        decoding: () => 1,\n      }),\n    ),\n    filter: S.String.pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => '',\n        decoding: () => '',\n      }),\n    ),\n    sort: S.Literal('newest', 'oldest', 'price').pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => 'newest' as const,\n        decoding: () => 'newest' as const,\n      }),\n    ),\n  }),\n)\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n\nReading Search Params\n\nOnce your search params have been validated and typed, you're finally ready to start reading and writing to them. There are a few ways to do this in TanStack Router, so let's check them out.\n\nUsing Search Params in Loaders\n\nPlease read the Search Params in Loaders section for more information about how to read search params in loaders with the loaderDeps option.\n\nSearch Params are inherited from Parent Routes\n\nThe search parameters and types of parents are merged as you go down the route tree, so child routes also have access to their parent's search params:\n\nshop.products.tsx\ntsx\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nshop.products.$productId.tsx\ntsx\nexport const Route = createFileRoute('/shop/products/$productId')({\n  beforeLoad: ({ search }) => {\n    search\n    // ^? ProductSearch ‚úÖ\n  },\n})\n\nSearch Params in Components\n\nYou can access your route's validated search params in your route's component via the useSearch hook.\n\ntsx\n// /routes/shop.products.tsx\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  const { page, filter, sort } = Route.useSearch()\n\n  return <div>...</div>\n}\n\n\nTip\n\nIf your component is code-split, you can use the getRouteApi function to avoid having to import the Route configuration to get access to the typed useSearch() hook.\n\nSearch Params outside of Route Components\n\nYou can access your route's validated search params anywhere in your app using the useSearch hook. By passing the from id/path of your origin route, you'll get even better type safety:\n\ntsx\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n  // ...\n})\n\n// Somewhere else...\n\n// /components/product-list-sidebar.tsx\nconst routeApi = getRouteApi('/shop/products')\n\nconst ProductList = () => {\n  const routeSearch = routeApi.useSearch()\n\n  // OR\n\n  const { page, filter, sort } = useSearch({\n    from: Route.fullPath,\n  })\n\n  return <div>...</div>\n}\n\n\nOr, you can loosen up the type-safety and get an optional search object by passing strict: false:\n\ntsx\nfunction ProductList() {\n  const search = useSearch({\n    strict: false,\n  })\n  // {\n  //   page: number | undefined\n  //   filter: string | undefined\n  //   sort: 'newest' | 'oldest' | 'price' | undefined\n  // }\n\n  return <div>...</div>\n}\n\nWriting Search Params\n\nNow that you've learned how to read your route's search params, you'll be happy to know that you've already seen the primary APIs to modify and update them. Let's remind ourselves a bit\n\n<Link search />\n\nThe best way to update search params is to use the search prop on the <Link /> component.\n\nIf the search for the current page shall be updated and the from prop is specified, the to prop can be omitted.\nHere's an example:\n\ntsx\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  return (\n    <div>\n      <Link from={Route.fullPath} search={(prev) => ({ page: prev.page + 1 })}>\n        Next Page\n      </Link>\n    </div>\n  )\n}\n\n\nIf you want to update the search params in a generic component that is rendered on multiple routes, specifying from can be challenging.\n\nIn this scenario you can set to=\".\" which will give you access to loosely typed search params.\nHere is an example that illustrates this:\n\ntsx\n// `page` is a search param that is defined in the __root route and hence available on all routes.\nconst PageSelector = () => {\n  return (\n    <div>\n      <Link to=\".\" search={(prev) => ({ ...prev, page: prev.page + 1 })}>\n        Next Page\n      </Link>\n    </div>\n  )\n}\n\n\nIf the generic component is only rendered in a specific subtree of the route tree, you can specify that subtree using from. Here you can omit to='.' if you want.\n\ntsx\n// `page` is a search param that is defined in the /posts route and hence available on all of its child routes.\nconst PageSelector = () => {\n  return (\n    <div>\n      <Link\n        from=\"/posts\"\n        to=\".\"\n        search={(prev) => ({ ...prev, page: prev.page + 1 })}\n      >\n        Next Page\n      </Link>\n    </div>\n  )\n\nuseNavigate(), navigate({ search })\n\nThe navigate function also accepts a search option that works the same way as the search prop on <Link />:\n\ntsx\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products/$productId')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  const navigate = useNavigate({ from: Route.fullPath })\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          navigate({\n            search: (prev) => ({ page: prev.page + 1 }),\n          })\n        }}\n      >\n        Next Page\n      </button>\n    </div>\n  )\n}\n\nrouter.navigate({ search })\n\nThe router.navigate function works exactly the same way as the useNavigate/navigate hook/function above.\n\n<Navigate search />\n\nThe <Navigate search /> component works exactly the same way as the useNavigate/navigate hook/function above, but accepts its options as props instead of a function argument.\n\nTransforming search with search middlewares\n\nWhen link hrefs are built, by default the only thing that matters for the query string part is the search property of a <Link>.\n\nTanStack Router provides a way to manipulate search params before the href is generated via search middlewares. Search middlewares are functions that transform the search parameters when generating new links for a route or its descendants. They are also executed upon navigation after search validation to allow manipulation of the query string.\n\nThe following example shows how to make sure that for every link that is being built, the rootValue search param is added if it is part of the current search params. If a link specifies rootValue inside search, then that value is used for building the link.\n\ntsx\nimport { z } from 'zod'\nimport { createFileRoute } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [\n      ({ search, next }) => {\n        const result = next(search)\n        return {\n          rootValue: search.rootValue,\n          ...result,\n        }\n      },\n    ],\n  },\n})\n\n\nSince this specific use case is quite common, TanStack Router provides a generic implementation to retain search params via retainSearchParams:\n\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, retainSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [retainSearchParams(['rootValue'])],\n  },\n})\n\n\nAnother common use case is to strip out search params from links if their default value is set. TanStack Router provides a generic implementation for this use case via stripSearchParams:\n\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, stripSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = {\n  one: 'abc',\n  two: 'xyz',\n}\n\nconst searchSchema = z.object({\n  one: z.string().default(defaultValues.one),\n  two: z.string().default(defaultValues.two),\n})\n\nexport const Route = createFileRoute('/hello')({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    // strip default values\n    middlewares: [stripSearchParams(defaultValues)],\n  },\n})\n\n\nMultiple middlewares can be chained. The following example shows how to combine both retainSearchParams and stripSearchParams.\n\ntsx\nimport {\n  Link,\n  createFileRoute,\n  retainSearchParams,\n  stripSearchParams,\n} from '@tanstack/react-router'\nimport { z } from 'zod'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = ['foo', 'bar']\n\nexport const Route = createFileRoute('/search')({\n  validateSearch: zodValidator(\n    z.object({\n      retainMe: z.string().optional(),\n      arrayWithDefaults: z.string().array().default(defaultValues),\n      required: z.string(),\n    }),\n  ),\n  search: {\n    middlewares: [\n      retainSearchParams(['retainMe']),\n      stripSearchParams({ arrayWithDefaults: defaultValues }),\n    ],\n  },\n})\n\nEdit on GitHub\nPath Params\nLink Options\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Link Options | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/link-options",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nLink Options\n\nYou may want to reuse options that are intended to be passed to Link, redirect or navigate. In which case you may decide an object literal is a good way to represent options passed to Link.\n\ntsx\nconst dashboardLinkOptions = {\n  to: '/dashboard',\n  search: { search: '' },\n}\n\nfunction DashboardComponent() {\n  return <Link {...dashboardLinkOptions} />\n}\n\n\nThere are a few problems here. dashboardLinkOptions.to is inferred as string which by default will resolve to every route when passed to Link, navigate or redirect (this particular issue could be fixed by as const). The other issue here is we do not know dashboardLinkOptions even passes the type checker until it is spread into Link. We could very easily create incorrect navigation options and only when the options are spread into Link do we know there is a type error.\n\nUsing linkOptions function to create re-usable options\n\nlinkOptions is a function which type checks an object literal and returns the inferred input as is. This provides type safety on options exactly like Link before it is used allowing for easier maintenance and re-usability. Our above example using linkOptions looks like this:\n\ntsx\nconst dashboardLinkOptions = linkOptions({\n  to: '/dashboard',\n  search: { search: '' },\n})\n\nfunction DashboardComponent() {\n  return <Link {...dashboardLinkOptions} />\n}\n\n\nThis allows eager type checking of dashboardLinkOptions which can then be re-used anywhere\n\ntsx\nconst dashboardLinkOptions = linkOptions({\n  to: '/dashboard',\n  search: { search: '' },\n})\n\nexport const Route = createFileRoute('/dashboard')({\n  component: DashboardComponent,\n  validateSearch: (input) => ({ search: input.search }),\n  beforeLoad: () => {\n    // can used in redirect\n    throw redirect(dashboardLinkOptions)\n  },\n})\n\nfunction DashboardComponent() {\n  const navigate = useNavigate()\n\n  return (\n    <div>\n      {/** can be used in navigate */}\n      <button onClick={() => navigate(dashboardLinkOptions)} />\n\n      {/** can be used in Link */}\n      <Link {...dashboardLinkOptions} />\n    </div>\n  )\n}\n\nAn array of linkOptions\n\nWhen creating navigation you might loop over an array to construct a navigation bar. In which case linkOptions can be used to type check an array of object literals which are intended for Link props\n\ntsx\nconst options = linkOptions([\n  {\n    to: '/dashboard',\n    label: 'Summary',\n    activeOptions: { exact: true },\n  },\n  {\n    to: '/dashboard/invoices',\n    label: 'Invoices',\n  },\n  {\n    to: '/dashboard/users',\n    label: 'Users',\n  },\n])\n\nfunction DashboardComponent() {\n  return (\n    <>\n      <div className=\"flex items-center border-b\">\n        <h2 className=\"text-xl p-2\">Dashboard</h2>\n      </div>\n\n      <div className=\"flex flex-wrap divide-x\">\n        {options.map((option) => {\n          return (\n            <Link\n              {...option}\n              key={option.to}\n              activeProps={{ className: `font-bold` }}\n              className=\"p-2\"\n            >\n              {option.label}\n            </Link>\n          )\n        })}\n      </div>\n      <hr />\n\n      <Outlet />\n    </>\n  )\n}\n\n\nThe input of linkOptions is inferred and returned, as shown with the use of label as this does not exist on Link props\n\nEdit on GitHub\nSearch Params\nCustom Links\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Path Params | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/path-params",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nPath Params\n\nPath params are used to match a single segment (the text until the next /) and provide its value back to you as a named variable. They are defined by using the $ character prefix in the path, followed by the key variable to assign it to. The following are valid path param paths:\n\n$postId\n$name\n$teamId\nabout/$name\nteam/$teamId\nblog/$postId\n\nBecause path param routes only match to the next /, child routes can be created to continue expressing hierarchy:\n\nLet's create a post route file that uses a path param to match the post ID:\n\nposts.$postId.tsx\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params }) => {\n    return fetchPost(params.postId)\n  },\n})\n\nPath Params can be used by child routes\n\nOnce a path param has been parsed, it is available to all child routes. This means that if we define a child route to our postRoute, we can use the postId variable from the URL in the child route's path!\n\nPath Params in Loaders\n\nPath params are passed to the loader as a params object. The keys of this object are the names of the path params, and the values are the values that were parsed out of the actual URL path. For example, if we were to visit the /blog/123 URL, the params object would be { postId: '123' }:\n\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  loader: async ({ params }) => {\n    return fetchPost(params.postId)\n  },\n})\n\n\nThe params object is also passed to the beforeLoad option:\n\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  beforeLoad: async ({ params }) => {\n    // do something with params.postId\n  },\n})\n\nPath Params in Components\n\nIf we add a component to our postRoute, we can access the postId variable from the URL by using the route's useParams hook:\n\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  const { postId } = Route.useParams()\n  return <div>Post {postId}</div>\n}\n\n\nüß† Quick tip: If your component is code-split, you can use the getRouteApi function to avoid having to import the Route configuration to get access to the typed useParams() hook.\n\nPath Params outside of Routes\n\nYou can also use the globally exported useParams hook to access any parsed path params from any component in your app. You'll need to pass the strict: false option to useParams, denoting that you want to access the params from an ambiguous location:\n\ntsx\nfunction PostComponent() {\n  const { postId } = useParams({ strict: false })\n  return <div>Post {postId}</div>\n}\n\nNavigating with Path Params\n\nWhen navigating to a route with path params, TypeScript will require you to pass the params either as an object or as a function that returns an object of params.\n\nLet's see what an object style looks like:\n\ntsx\nfunction Component() {\n  return (\n    <Link to=\"/blog/$postId\" params={{ postId: '123' }}>\n      Post 123\n    </Link>\n  )\n}\n\n\nAnd here's what a function style looks like:\n\ntsx\nfunction Component() {\n  return (\n    <Link to=\"/blog/$postId\" params={(prev) => ({ ...prev, postId: '123' })}>\n      Post 123\n    </Link>\n  )\n}\n\n\nNotice that the function style is useful when you need to persist params that are already in the URL for other routes. This is because the function style will receive the current params as an argument, allowing you to modify them as needed and return the final params object.\n\nAllowed Characters\n\nBy default, path params are escaped with encodeURIComponent. If you want to allow other valid URI characters (e.g. @ or +), you can specify that in your RouterOptions\n\nExample usage:\n\ntsx\nconst router = createRouter({\n  ...\n  pathParamsAllowedCharacters: ['@']\n})\n\n\nThe following is the list of accepted allowed characters: ; : @ & = + $ ,\n\nEdit on GitHub\nNavigation\nSearch Params\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Navigation | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/navigation",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nNavigation\nEverything is Relative\n\nBelieve it or not, every navigation within an app is relative, even if you aren't using explicit relative path syntax (../../somewhere). Any time a link is clicked or an imperative navigation call is made, you will always have an origin path and a destination path which means you are navigating from one route to another route.\n\nTanStack Router keeps this constant concept of relative navigation in mind for every navigation, so you'll constantly see two properties in the API:\n\nfrom - The origin route path\nto - The destination route path\n\n‚ö†Ô∏è If a from route path isn't provided the router will assume you are navigating from the root / route and only auto-complete absolute paths. After all, you need to know where you are from in order to know where you're going üòâ.\n\nShared Navigation API\n\nEvery navigation and route matching API in TanStack Router uses the same core interface with minor differences depending on the API. This means that you can learn navigation and route matching once and use the same syntax and concepts across the library.\n\nToOptions Interface\n\nThis is the core ToOptions interface that is used in every navigation and route matching API:\n\nts\ntype ToOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = {\n  // `from` is an optional route ID or path. If it is not supplied, only absolute paths will be auto-completed and type-safe. It's common to supply the route.fullPath of the origin route you are rendering from for convenience. If you don't know the origin route, leave this empty and work with absolute paths or unsafe relative paths.\n  from: string\n  // `to` can be an absolute route path or a relative path from the `from` option to a valid route path. ‚ö†Ô∏è Do not interpolate path params, hash or search params into the `to` options. Use the `params`, `search`, and `hash` options instead.\n  to: string\n  // `params` is either an object of path params to interpolate into the `to` option or a function that supplies the previous params and allows you to return new ones. This is the only way to interpolate dynamic parameters into the final URL. Depending on the `from` and `to` route, you may need to supply none, some or all of the path params. TypeScript will notify you of the required params if there are any.\n  params:\n    | Record<string, unknown>\n    | ((prevParams: Record<string, unknown>) => Record<string, unknown>)\n  // `search` is either an object of query params or a function that supplies the previous search and allows you to return new ones. Depending on the `from` and `to` route, you may need to supply none, some or all of the query params. TypeScript will notify you of the required search params if there are any.\n  search:\n    | Record<string, unknown>\n    | ((prevSearch: Record<string, unknown>) => Record<string, unknown>)\n  // `hash` is either a string or a function that supplies the previous hash and allows you to return a new one.\n  hash?: string | ((prevHash: string) => string)\n  // `state` is either an object of state or a function that supplies the previous state and allows you to return a new one. State is stored in the history API and can be useful for passing data between routes that you do not want to permanently store in URL search params.\n  state?:\n    | Record<string, any>\n    | ((prevState: Record<string, unknown>) => Record<string, unknown>)\n}\n\n\nüß† Every route object has a to property, which can be used as the to for any navigation or route matching API. Where possible, this will allow you to avoid plain strings and use type-safe route references instead:\n\ntsx\nimport { Route as aboutRoute } from './routes/about.tsx'\n\nfunction Comp() {\n  return <Link to={aboutRoute.to}>About</Link>\n}\n\nNavigateOptions Interface\n\nThis is the core NavigateOptions interface that extends ToOptions. Any API that is actually performing a navigation will use this interface:\n\nts\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  // `resetScroll` is a boolean that determines whether scroll position will be reset to 0,0 after the location is committed to browser history.\n  resetScroll?: boolean\n  // `hashScrollIntoView` is a boolean or object that determines whether an id matching the hash will be scrolled into view after the location is committed to history.\n  hashScrollIntoView?: boolean | ScrollIntoViewOptions\n  // `viewTransition` is either a boolean or function that determines if and how the browser will call document.startViewTransition() when navigating.\n  viewTransition?: boolean | ViewTransitionOptions\n  // `ignoreBlocker` is a boolean that determines if navigation should ignore any blockers that might prevent it.\n  ignoreBlocker?: boolean\n  // `reloadDocument` is a boolean that determines if navigation to a route inside of router will trigger a full page load instead of the traditional SPA navigation.\n  reloadDocument?: boolean\n  // `href` is a string that can be used in place of `to` to navigate to a full built href, e.g. pointing to an external target.\n  href?: string\n}\n\nLinkOptions Interface\n\nAnywhere an actual <a> tag the LinkOptions interface which extends NavigateOptions will be available:\n\ntsx\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: {\n    exact?: boolean\n    includeHash?: boolean\n    includeSearch?: boolean\n    explicitUndefined?: boolean\n  }\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nNavigation API\n\nWith relative navigation and all of the interfaces in mind now, let's talk about the different flavors of navigation API at your disposal:\n\nThe <Link> component\nGenerates an actual <a> tag with a valid href which can be click or even cmd/ctrl + clicked to open in a new tab\nThe useNavigate() hook\nWhen possible, Link component should be used for navigation, but sometimes you need to navigate imperatively as a result of a side-effect. useNavigate returns a function that can be called to perform an immediate client-side navigation.\nThe <Navigate> component\nRenders nothing and performs an immediate client-side navigation.\nThe Router.navigate() method\nThis is the most powerful navigation API in TanStack Router. Similar to useNavigate, it imperatively navigates, but is available everywhere you have access to your router.\n\n‚ö†Ô∏è None of these APIs are a replacement for server-side redirects. If you need to redirect a user immediately from one route to another before mounting your application, use a server-side redirect instead of a client-side navigation.\n\n<Link> Component\n\nThe Link component is the most common way to navigate within an app. It renders an actual <a> tag with a valid href attribute which can be clicked or even cmd/ctrl + clicked to open in a new tab. It also supports any normal <a> attributes including target to open links in new windows, etc.\n\nIn addition to the LinkOptions interface, the Link component also supports the following props:\n\ntsx\nexport type LinkProps<\n  TFrom extends RoutePaths<RegisteredRouter['routeTree']> | string = string,\n  TTo extends string = '',\n> = LinkOptions<RegisteredRouter['routeTree'], TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | FrameworkHTMLAnchorTagAttributes\n    | (() => FrameworkHTMLAnchorAttributes)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | FrameworkHTMLAnchorAttributes\n    | (() => FrameworkHTMLAnchorAttributes)\n}\n\nAbsolute Links\n\nLet's make a simple static link!\n\ntsx\nimport { Link } from '@tanstack/react-router'\n\nconst link = <Link to=\"/about\">About</Link>\n\nDynamic Links\n\nDynamic links are links that have dynamic segments in them. For example, a link to a blog post might look like this:\n\ntsx\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n  >\n    Blog Post\n  </Link>\n)\n\n\nKeep in mind that normally dynamic segment params are string values, but they can also be any other type that you parse them to in your route options. Either way, the type will be checked at compile time to ensure that you are passing the correct type.\n\nRelative Links\n\nBy default, all links are absolute unless a from route path is provided. This means that the above link will always navigate to the /about route regardless of what route you are currently on.\n\nIf you want to make a link that is relative to the current route, you can provide a from route path:\n\ntsx\nconst postIdRoute = createRoute({\n  path: '/blog/post/$postId',\n})\n\nconst link = (\n  <Link from={postIdRoute.fullPath} to=\"../categories\">\n    Categories\n  </Link>\n)\n\n\nAs seen above, it's common to provide the route.fullPath as the from route path. This is because the route.fullPath is a reference that will update if you refactor your application. However, sometimes it's not possible to import the route directly, in which case it's fine to provide the route path directly as a string. It will still get type-checked as per usual!\n\nSearch Param Links\n\nSearch params are a great way to provide additional context to a route. For example, you might want to provide a search query to a search page:\n\ntsx\nconst link = (\n  <Link\n    to=\"/search\"\n    search={{\n      query: 'tanstack',\n    }}\n  >\n    Search\n  </Link>\n)\n\n\nIt's also common to want to update a single search param without supplying any other information about the existing route. For example, you might want to update the page number of a search result:\n\ntsx\nconst link = (\n  <Link\n    to=\".\"\n    search={(prev) => ({\n      ...prev,\n      page: prev.page + 1,\n    })}\n  >\n    Next Page\n  </Link>\n)\n\nSearch Param Type Safety\n\nSearch params are a highly dynamic state management mechanism, so it's important to ensure that you are passing the correct types to your search params. We'll see in a later section in detail how to validate and ensure search params typesafety, among other great features!\n\nHash Links\n\nHash links are a great way to link to a specific section of a page. For example, you might want to link to a specific section of a blog post:\n\ntsx\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n    hash=\"section-1\"\n  >\n    Section 1\n  </Link>\n)\n\nActive & Inactive Props\n\nThe Link component supports two additional props: activeProps and inactiveProps. These props are functions that return additional props for the active and inactive states of the link. All props other than styles and classes passed here will override the original props passed to Link. Any styles or classes passed are merged together.\n\nHere's an example:\n\ntsx\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n    activeProps={{\n      style: {\n        fontWeight: 'bold',\n      },\n    }}\n  >\n    Section 1\n  </Link>\n)\n\nThe data-status attribute\n\nIn addition to the activeProps and inactiveProps props, the Link component also adds a data-status attribute to the rendered element when it is in an active state. This attribute will be active or undefined depending on the current state of the link. This can come in handy if you prefer to use data-attributes to style your links instead of props.\n\nActive Options\n\nThe Link component comes with an activeOptions property that offers a few options of determining if a link is active or not. The following interface describes those options:\n\ntsx\nexport interface ActiveOptions {\n  // If true, the link will be active if the current route matches the `to` route path exactly (no children routes)\n  // Defaults to `false`\n  exact?: boolean\n  // If true, the link will only be active if the current URL hash matches the `hash` prop\n  // Defaults to `false`\n  includeHash?: boolean // Defaults to false\n  // If true, the link will only be active if the current URL search params inclusively match the `search` prop\n  // Defaults to `true`\n  includeSearch?: boolean\n  // This modifies the `includeSearch` behavior.\n  // If true,  properties in `search` that are explicitly `undefined` must NOT be present in the current URL search params for the link to be active.\n  // defaults to `false`\n  explicitUndefined?: boolean\n}\n\n\nBy default, it will check if the resulting pathname is a prefix of the current route. If any search params are provided, it will check that they inclusively match those in the current location. Hashes are not checked by default.\n\nFor example, if you are on the /blog/post/my-first-blog-post route, the following links will be active:\n\ntsx\nconst link1 = (\n  <Link to=\"/blog/post/$postId\" params={{ postId: 'my-first-blog-post' }}>\n    Blog Post\n  </Link>\n)\nconst link2 = <Link to=\"/blog/post\">Blog Post</Link>\nconst link3 = <Link to=\"/blog\">Blog Post</Link>\n\n\nHowever, the following links will not be active:\n\ntsx\nconst link4 = (\n  <Link to=\"/blog/post/$postId\" params={{ postId: 'my-second-blog-post' }}>\n    Blog Post\n  </Link>\n)\n\n\nIt's common for some links to only be active if they are an exact match. A good example of this would be a link to the home page. In scenarios like these, you can pass the exact: true option:\n\ntsx\nconst link = (\n  <Link to=\"/\" activeOptions={{ exact: true }}>\n    Home\n  </Link>\n)\n\n\nThis will ensure that the link is not active when you are a child route.\n\nA few more options to be aware of:\n\nIf you want to include the hash in your matching, you can pass the includeHash: true option\nIf you do not want to include the search params in your matching, you can pass the includeSearch: false option\nPassing isActive to children\n\nThe Link component accepts a function for its children, allowing you to propagate its isActive property to children. For example, you could style a child component based on whether the parent link is active:\n\ntsx\nconst link = (\n  <Link to=\"/blog/post\">\n    {({ isActive }) => {\n      return (\n        <>\n          <span>My Blog Post</span>\n          <icon className={isActive ? 'active' : 'inactive'} />\n        </>\n      )\n    }}\n  </Link>\n)\n\nLink Preloading\n\nThe Link component supports automatically preloading routes on intent (hovering or touchstart for now). This can be configured as a default in the router options (which we'll talk more about soon) or by passing a preload='intent' prop to the Link component. Here's an example:\n\ntsx\nconst link = (\n  <Link to=\"/blog/post/$postId\" preload=\"intent\">\n    Blog Post\n  </Link>\n)\n\n\nWith preloading enabled and relatively quick asynchronous route dependencies (if any), this simple trick can increase the perceived performance of your application with very little effort.\n\nWhat's even better is that by using a cache-first library like @tanstack/query, preloaded routes will stick around and be ready for a stale-while-revalidate experience if the user decides to navigate to the route later on.\n\nLink Preloading Timeout\n\nAlong with preloading is a configurable timeout which determines how long a user must hover over a link to trigger the intent-based preloading. The default timeout is 50 milliseconds, but you can change this by passing a preloadTimeout prop to the Link component with the number of milliseconds you'd like to wait:\n\ntsx\nconst link = (\n  <Link to=\"/blog/post/$postId\" preload=\"intent\" preloadTimeout={100}>\n    Blog Post\n  </Link>\n)\n\nuseNavigate\n\n‚ö†Ô∏è Because of the Link component's built-in affordances around href, cmd/ctrl + click-ability, and active/inactive capabilities, it's recommended to use the Link component instead of useNavigate for anything the user can interact with (e.g. links, buttons). However, there are some cases where useNavigate is necessary to handle side-effect navigations (e.g. a successful async action that results in a navigation).\n\nThe useNavigate hook returns a navigate function that can be called to imperatively navigate. It's a great way to navigate to a route from a side-effect (e.g. a successful async action). Here's an example:\n\ntsx\nfunction Component() {\n  const navigate = useNavigate({ from: '/posts/$postId' })\n\n  const handleSubmit = async (e: FrameworkFormEvent) => {\n    e.preventDefault()\n\n    const response = await fetch('/posts', {\n      method: 'POST',\n      body: JSON.stringify({ title: 'My First Post' }),\n    })\n\n    const { id: postId } = await response.json()\n\n    if (response.ok) {\n      navigate({ to: '/posts/$postId', params: { postId } })\n    }\n  }\n}\n\n\nüß† As shown above, you can pass the from option to specify the route to navigate from in the hook call. While this is also possible to pass in the resulting navigate function each time you call it, it's recommended to pass it here to reduce on potential error and also not type as much!\n\nnavigate Options\n\nThe navigate function returned by useNavigate accepts the NavigateOptions interface\n\nNavigate Component\n\nOccasionally, you may find yourself needing to navigate immediately when a component mounts. Your first instinct might be to reach for useNavigate and an immediate side-effect (e.g. useEffect), but this is unnecessary. Instead, you can render the Navigate component to achieve the same result:\n\ntsx\nfunction Component() {\n  return <Navigate to=\"/posts/$postId\" params={{ postId: 'my-first-post' }} />\n}\n\n\nThink of the Navigate component as a way to navigate to a route immediately when a component mounts. It's a great way to handle client-only redirects. It is definitely not a substitute for handling server-aware redirects responsibly on the server.\n\nrouter.navigate\n\nThe router.navigate method is the same as the navigate function returned by useNavigate and accepts the same NavigateOptions interface. Unlike the useNavigate hook, it is available anywhere your router instance is available and is thus a great way to navigate imperatively from anywhere in your application, including outside of your framework.\n\nuseMatchRoute and <MatchRoute>\n\nThe useMatchRoute hook and <MatchRoute> component are the same thing, but the hook is a bit more flexible. They both accept the standard navigation ToOptions interface either as options or props and return true/false if that route is currently matched. It also has a handy pending option that will return true if the route is currently pending (e.g. a route is currently transitioning to that route). This can be extremely useful for showing optimistic UI around where a user is navigating:\n\ntsx\nfunction Component() {\n  return (\n    <div>\n      <Link to=\"/users\">\n        Users\n        <MatchRoute to=\"/users\" pending>\n          <Spinner />\n        </MatchRoute>\n      </Link>\n    </div>\n  )\n}\n\n\nThe component version <MatchRoute> can also be used with a function as children to render something when the route is matched:\n\ntsx\nfunction Component() {\n  return (\n    <div>\n      <Link to=\"/users\">\n        Users\n        <MatchRoute to=\"/users\" pending>\n          {(match) => {\n            return <Spinner show={match} />\n          }}\n        </MatchRoute>\n      </Link>\n    </div>\n  )\n}\n\n\nThe hook version useMatchRoute returns a function that can be called programmatically to check if a route is matched:\n\ntsx\nfunction Component() {\n  const matchRoute = useMatchRoute()\n\n  useEffect(() => {\n    if (matchRoute({ to: '/users', pending: true })) {\n      console.info('The /users route is matched and pending')\n    }\n  })\n\n  return (\n    <div>\n      <Link to=\"/users\">Users</Link>\n    </div>\n  )\n}\n\n\nPhew! That's a lot of navigating! That said, hopefully you're feeling pretty good about getting around your application now. Let's move on!\n\nEdit on GitHub\nOutlets\nPath Params\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nSTART\nFull-document SSR, Streaming, Server Functions, bundling and more, powered by TanStack Router and Vite - Ready to deploy to your favorite hosting provider.\nLEARN MORE\nTANSTACK\nSTORE\nThe immutable-reactive data store that powers the core of TanStack libraries and their framework adapters.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Outlets | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/outlets",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nOutlets\n\nNested routing means that routes can be nested within other routes, including the way they render. So how do we tell our routes where to render this nested content?\n\nThe Outlet Component\n\nThe Outlet component is used to render the next potentially matching child route. <Outlet /> doesn't take any props and can be rendered anywhere within a route's component tree. If there is no matching child route, <Outlet /> will render null.\n\nTip\n\nIf a route's component is left undefined, it will render an <Outlet /> automatically.\n\nA great example is configuring the root route of your application. Let's give our root route a component that renders a title, then an <Outlet /> for our top-level routes to render.\n\ntsx\nimport { createRootRoute, Outlet } from '@tanstack/react-router'\n\nexport const Route = createRootRoute({\n  component: RootComponent,\n})\n\nfunction RootComponent() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <Outlet /> {/* This is where child routes will render */}\n    </div>\n  )\n}\n\nEdit on GitHub\nCreating a Router\nNavigation\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Creating a Router | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/creating-a-router",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nCreating a Router\nThe Router Class\n\nWhen you're ready to start using your router, you'll need to create a new Router instance. The router instance is the core brains of TanStack Router and is responsible for managing the route tree, matching routes, and coordinating navigations and route transitions. It also serves as a place to configure router-wide settings.\n\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  // ...\n})\n\nRoute Tree\n\nYou'll probably notice quickly that the Router constructor requires a routeTree option. This is the route tree that the router will use to match routes and render components.\n\nWhether you used file-based routing or code-based routing, you'll need to pass your route tree to the createRouter function:\n\nFilesystem Route Tree\n\nIf you used our recommended file-based routing, then it's likely your generated route tree file was created at the default src/routeTree.gen.ts location. If you used a custom location, then you'll need to import your route tree from that location.\n\ntsx\nimport { routeTree } from './routeTree.gen'\n\nCode-Based Route Tree\n\nIf you used code-based routing, then you likely created your route tree manually using the root route's addChildren method:\n\ntsx\nconst routeTree = rootRoute.addChildren([\n  // ...\n])\n\nRouter Type Safety\n\nImportant\n\nDO NOT SKIP THIS SECTION! ‚ö†Ô∏è\n\nTanStack Router provides amazing support for TypeScript, even for things you wouldn't expect like bare imports straight from the library! To make this possible, you must register your router's types using TypeScripts' Declaration Merging feature. This is done by extending the Register interface on @tanstack/react-router with a router property that has the type of your router instance:\n\ntsx\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    // This infers the type of our router and registers it across your entire project\n    router: typeof router\n  }\n}\n\n\nWith your router registered, you'll now get type-safety across your entire project for anything related to routing.\n\n404 Not Found Route\n\nAs promised in earlier guides, we'll now cover the notFoundRoute option. This option is used to configure a route that will render when no other suitable match is found. This is useful for rendering a 404 page or redirecting to a default route.\n\nIf you are using either file-based or code-based routing, then you'll need to add a notFoundComponent key to createRootRoute:\n\ntsx\nexport const Route = createRootRoute({\n  component: () => (\n    // ...\n  ),\n  notFoundComponent: () => <div>404 Not Found</div>,\n});\n\nOther Options\n\nThere are many other options that can be passed to the Router constructor. You can find a full list of them in the API Reference.\n\nEdit on GitHub\nAutomatic Code Splitting\nOutlets\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Automatic Code Splitting | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/automatic-code-splitting",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nAutomatic Code Splitting\n\nTip\n\nWe'll be filling in this guide soon about the wonderful world of automatic code splitting with TanStack Router and the many customization options available to you. Stay tuned!\n\nEdit on GitHub\nCode Splitting\nCreating a Router\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Code Splitting | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/guide/code-splitting",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nCode Splitting\n\nCode splitting and lazy loading is a powerful technique for improving the bundle size and load performance of an application.\n\nReduces the amount of code that needs to be loaded on initial page load\nCode is loaded on-demand when it is needed\nResults in more chunks that are smaller in size that can be cached more easily by the browser.\nHow does TanStack Router split code?\n\nTanStack Router separates code into two categories:\n\nCritical Route Configuration - The code that is required to render the current route and kick off the data loading process as early as possible.\n\nPath Parsing/Serialization\nSearch Param Validation\nLoaders, Before Load\nRoute Context\nStatic Data\nLinks\nScripts\nStyles\nAll other route configuration not listed below\n\nNon-Critical/Lazy Route Configuration - The code that is not required to match the route, and can be loaded on-demand.\n\nRoute Component\nError Component\nPending Component\nNot-found Component\n\nüß† Why is the loader not split?\n\nThe loader is already an asynchronous boundary, so you pay double to both get the chunk and wait for the loader to execute.\n\nCategorically, it is less likely to contribute to a large bundle size than a component.\n\nThe loader is one of the most important preloadable assets for a route, especially if you're using a default preload intent, like hovering over a link, so it's important for the loader to be available without any additional async overhead.\n\nKnowing the disadvantages of splitting the loader, if you still want to go ahead with it, head over to the Data Loader Splitting section.\n\nEncapsulating a route's files into a directory\n\nSince TanStack Router's file-based routing system is designed to support both flat and nested file structures, it's possible to encapsulate a route's files into a single directory without any additional configuration.\n\nTo encapsulate a route's files into a directory, move the route file itself into a .route file within a directory with the same name as the route file.\n\nFor example, if you have a route file named posts.tsx, you would create a new directory named posts and move the posts.tsx file into that directory, renaming it to route.tsx.\n\nBefore\n\nposts.tsx\n\nAfter\n\nposts\nroute.tsx\nApproaches to code splitting\n\nTanStack Router supports multiple approaches to code splitting. If you are using code-based routing, skip to the Code-Based Splitting section.\n\nWhen you are using file-based routing, you can use the following approaches to code splitting:\n\nUsing automatic code-splitting ‚ú®\nUsing the .lazy.tsx suffix\nUsing Virtual Routes\nUsing automatic code-splitting‚ú®\n\nThis is the easiest and most powerful way to code split your route files.\n\nWhen using the autoCodeSplitting feature, TanStack Router will automatically code split your route files based on the non-critical route configuration mentioned above.\n\nImportant\n\nThe automatic code-splitting feature is ONLY available when you are using file-based routing with one of our supported bundlers. This will NOT work if you are only using the CLI (@tanstack/router-cli).\n\nTo enable automatic code-splitting, you just need to add the following to the configuration of your TanStack Router Bundler Plugin:\n\nts\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n\nexport default defineConfig({\n  plugins: [\n    TanStackRouterVite({\n      // ...\n      autoCodeSplitting: true,\n    }),\n    react(), // Make sure to add this plugin after the TanStack Router Bundler plugin\n  ],\n})\n\n\nThat's it! TanStack Router will automatically code-split all your route files by their critical and non-critical route configurations.\n\nIf you want more control over the code-splitting process, head over to the Automatic Code Splitting guide to learn more about the options available.\n\nUsing the .lazy.tsx suffix\n\nIf you are not able to use the automatic code-splitting feature, you can still code-split your route files using the .lazy.tsx suffix. It is as easy as moving your code into a separate file with a .lazy.tsx suffix and using the createLazyFileRoute function instead of createFileRoute.\n\nImportant\n\nThe __root.tsx route file, using either createRootRoute or createRootRouteWithContext, does not support code splitting, since it's always rendered regardless of the current route.\n\nThese are the only options that createLazyFileRoute support:\n\nExport Name\tDescription\ncomponent\tThe component to render for the route.\nerrorComponent\tThe component to render when an error occurs while loading the route.\npendingComponent\tThe component to render while the route is loading.\nnotFoundComponent\tThe component to render if a not-found error gets thrown.\nExample code splitting with .lazy.tsx\n\nWhen you are using .lazy.tsx you can split your route into two files to enable code splitting:\n\nBefore (Single File)\n\ntsx\n// src/routes/posts.tsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { fetchPosts } from './api'\n\nexport const Route = createFileRoute('/posts')({\n  loader: fetchPosts,\n  component: Posts,\n})\n\nfunction Posts() {\n  // ...\n}\n\n\nAfter (Split into two files)\n\nThis file would contain the critical route configuration:\n\ntsx\n// src/routes/posts.tsx\n\nimport { createFileRoute } from '@tanstack/react-router'\nimport { fetchPosts } from './api'\n\nexport const Route = createFileRoute('/posts')({\n  loader: fetchPosts,\n})\n\n\nWith the non-critical route configuration going into the file with the .lazy.tsx suffix:\n\ntsx\n// src/routes/posts.lazy.tsx\nimport { createLazyFileRoute } from '@tanstack/react-router'\n\nexport const Route = createLazyFileRoute('/posts')({\n  component: Posts,\n})\n\nfunction Posts() {\n  // ...\n}\n\nUsing Virtual Routes\n\nYou might run into a situation where you end up splitting out everything from a route file, leaving it empty! In this case, simply delete the route file entirely! A virtual route will automatically be generated for you to serve as an anchor for your code split files. This virtual route will live directly in the generated route tree file.\n\nBefore (Virtual Routes)\n\ntsx\n// src/routes/posts.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  // Hello?\n})\n\ntsx\n// src/routes/posts.lazy.tsx\nimport { createLazyFileRoute } from '@tanstack/react-router'\n\nexport const Route = createLazyFileRoute('/posts')({\n  component: Posts,\n})\n\nfunction Posts() {\n  // ...\n}\n\n\nAfter (Virtual Routes)\n\ntsx\n// src/routes/posts.lazy.tsx\nimport { createLazyFileRoute } from '@tanstack/react-router'\n\nexport const Route = createLazyFileRoute('/posts')({\n  component: Posts,\n})\n\nfunction Posts() {\n  // ...\n}\n\n\nTada! üéâ\n\nCode-Based Splitting\n\nIf you are using code-based routing, you can still code-split your routes using the Route.lazy() method and the createLazyRoute function. You'll need to split your route configuration into two parts:\n\nCreate a lazy route using the createLazyRoute function.\n\ntsx\n// src/posts.tsx\nexport const Route = createLazyRoute('/posts')({\n  component: MyComponent,\n})\n\nfunction MyComponent() {\n  return <div>My Component</div>\n}\n\n\nThen, call the .lazy method on the route definition in your app.tsx to import the lazy/code-split route with the non-critical route configuration.\n\ntsx\n// src/app.tsx\nconst postsRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/posts',\n}).lazy(() => import('./posts.lazy').then((d) => d.Route))\n\nData Loader Splitting\n\nBe warned!!! Splitting a route loader is a dangerous game.\n\nIt can be a powerful tool to reduce bundle size, but it comes with a cost as mentioned in the How does TanStack Router split code? section.\n\nYou can code split your data loading logic using the Route's loader option. While this process makes it difficult to maintain type-safety with the parameters passed to your loader, you can always use the generic LoaderContext type to get you most of the way there:\n\ntsx\nimport { lazyFn } from '@tanstack/react-router'\n\nconst route = createRoute({\n  path: '/my-route',\n  component: MyComponent,\n  loader: lazyFn(() => import('./loader'), 'loader'),\n})\n\n// In another file...a\nexport const loader = async (context: LoaderContext) => {\n  /// ...\n}\n\n\nIf you are using file-based routing, you'll only be able to split your loader if you are using Automatic Code Splitting with customized bundling options.\n\nManually accessing Route APIs in other files with the getRouteApi helper\n\nAs you might have guessed, placing your component code in a separate file than your route can make it difficult to consume the route itself. To help with this, TanStack Router exports a handy getRouteApi function that you can use to access a route's type-safe APIs in a file without importing the route itself.\n\nmy-route.tsx\ntsx\nimport { createRoute } from '@tanstack/react-router'\nimport { MyComponent } from './MyComponent'\n\nconst route = createRoute({\n  path: '/my-route',\n  loader: () => ({\n    foo: 'bar',\n  }),\n  component: MyComponent,\n})\n\nMyComponent.tsx\ntsx\nimport { getRouteApi } from '@tanstack/react-router'\n\nconst route = getRouteApi('/my-route')\n\nexport function MyComponent() {\n  const loaderData = route.useLoaderData()\n  //    ^? { foo: string }\n\n  return <div>...</div>\n}\n\n\nThe getRouteApi function is useful for accessing other type-safe APIs:\n\nuseLoaderData\nuseLoaderDeps\nuseMatch\nuseParams\nuseRouteContext\nuseSearch\nEdit on GitHub\nFile Naming Conventions\nAutomatic Code Splitting\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "File Naming Conventions | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/file-naming-conventions",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nFile Naming Conventions\n\nFile-based routing requires that you follow a few simple file naming conventions to ensure that your routes are generated correctly. The concepts these conventions enable are covered in detail in the Route Trees & Nesting guide.\n\nFeature\tDescription\n__root.tsx\tThe root route file must be named __root.tsx and must be placed in the root of the configured routesDirectory.\n. Separator\tRoutes can use the . character to denote a nested route. For example, blog.post will be generated as a child of blog.\n$ Token\tRoute segments with the $ token are parameterized and will extract the value from the URL pathname as a route param.\n_ Prefix\tRoute segments with the _ prefix are considered to be pathless layout routes and will not be used when matching its child routes against the URL pathname.\n_ Suffix\tRoute segments with the _ suffix exclude the route from being nested under any parent routes.\n- Prefix\tFiles and folders with the - prefix are excluded from the route tree. They will not be added to the routeTree.gen.ts file and can be used to colocate logic in route folders.\n(folder) folder name pattern\tA folder that matches this pattern is treated as a route group, preventing the folder from being included in the route's URL path.\nindex Token\tRoute segments ending with the index token (before any file extensions) will match the parent route when the URL pathname matches the parent route exactly. This can be configured via the indexToken configuration option, see options.\n.route.tsx File Type\tWhen using directories to organise routes, the route suffix can be used to create a route file at the directory's path. For example, blog.post.route.tsx or blog/post/route.tsx can be used as the route file for the /blog/post route. This can be configured via the routeToken configuration option, see options.\n\nüí° Remember: The file-naming conventions for your project could be affected by what options are configured.\n\nDynamic Path Params\n\nDynamic path params can be used in both flat and directory routes to create routes that can match a dynamic segment of the URL path. Dynamic path params are denoted by the $ character in the filename:\n\nFilename\tRoute Path\tComponent Output\n...\t...\t...\n ¶ posts.$postId.tsx\t/posts/$postId\t<Root><Posts><Post>\n\nWe'll learn more about dynamic path params in the Path Params guide.\n\nPathless Routes\n\nPathless routes wrap child routes with either logic or a component without requiring a URL path. Non-path routes are denoted by the _ character in the filename:\n\nFilename\tRoute Path\tComponent Output\n ¶ _app.tsx\t\t\n ¶ _app.a.tsx\t/a\t<Root><App><A>\n ¶ _app.b.tsx\t/b\t<Root><App><B>\n\nTo learn more about pathless routes, see the Routing Concepts - Pathless Routes guide.\n\nEdit on GitHub\nInstallation with the Router CLI\nCode Splitting\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Installation with Vite | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/installation-with-esbuild",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nInstallation with Vite\n\nTo use file-based routing with Esbuild, you'll need to install the @tanstack/router-plugin package.\n\nsh\nnpm install -D @tanstack/router-plugin\n\n\nOnce installed, you'll need to add the plugin to your configuration.\n\ntsx\n// esbuild.config.js\nimport { TanStackRouterEsbuild } from '@tanstack/router-plugin/esbuild'\n\nexport default {\n  // ...\n  plugins: [\n    TanStackRouterEsbuild({ target: 'react', autoCodeSplitting: true }),\n  ],\n}\n\n\nOr, you can clone our Quickstart Esbuild example and get started.\n\nNow that you've added the plugin to your Esbuild configuration, you're all set to start using file-based routing with TanStack Router.\n\nIgnoring the generated route tree file\n\nIf your project is configured to use a linter and/or formatter, you may want to ignore the generated route tree file. This file is managed by TanStack Router and therefore shouldn't be changed by your linter or formatter.\n\nHere are some resources to help you ignore the generated route tree file:\n\nPrettier - https://prettier.io/docs/en/ignore.html#ignoring-files-prettierignore\nESLint - https://eslint.org/docs/latest/use/configure/ignore#ignoring-files\nBiome - https://biomejs.dev/reference/configuration/#filesignore\n\nWarning\n\nIf you are using VSCode, you may experience the route tree file unexpectedly open (with errors) after renaming a route.\n\nYou can prevent that from the VSCode settings by marking the file as readonly. Our recommendation is to also exclude it from search results and file watcher with the following settings:\n\njson\n{\n  \"files.readonlyInclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"files.watcherExclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"search.exclude\": {\n    \"**/routeTree.gen.ts\": true\n  }\n}\n\n\nYou can use those settings either at a user level or only for a single workspace by creating the file .vscode/settings.json at the root of your project.\n\nConfiguration\n\nWhen using the TanStack Router Plugin with Esbuild for File-based routing, it comes with some sane defaults that should work for most projects:\n\njson\n{\n  \"routesDirectory\": \"./src/routes\",\n  \"generatedRouteTree\": \"./src/routeTree.gen.ts\",\n  \"routeFileIgnorePrefix\": \"-\",\n  \"quoteStyle\": \"single\"\n}\n\n\nIf these defaults work for your project, you don't need to configure anything at all! However, if you need to customize the configuration, you can do so by editing the configuration object passed into the TanStackRouterEsbuild function.\n\nYou can find all the available configuration options in the File-based Routing API Reference.\n\nEdit on GitHub\nInstallation with Webpack\nInstallation with the Router CLI\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Installation with Router CLI | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/installation-with-router-cli",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nInstallation with Router CLI\n\nWarning\n\nYou should only use the TanStack Router CLI if you are not using a supported bundler. The CLI only supports the generation of the route tree file and does not provide any other features.\n\nTo use file-based routing with the TanStack Router CLI, you'll need to install the @tanstack/router-cli package.\n\nsh\nnpm install -D @tanstack/router-cli\n\n\nOnce installed, you'll need to amend your your scripts in your package.json for the CLI to watch and generate files.\n\njson\n{\n  \"scripts\": {\n    \"generate-routes\": \"tsr generate\",\n    \"watch-routes\": \"tsr watch\",\n    \"build\": \"npm run generate-routes && ...\",\n    \"dev\": \"npm run watch-routes && ...\"\n  }\n}\n\n\nYou shouldn't forget to ignore the generated route tree file. Head over to the Ignoring the generated route tree file section to learn more.\n\nWith the CLI installed, the following commands are made available via the tsr command\n\nUsing the generate command\n\nGenerates the routes for a project based on the provided configuration.\n\nsh\ntsr generate\n\nUsing the watch command\n\nContinuously watches the specified directories and regenerates routes as needed.\n\nUsage:\n\nsh\ntsr watch\n\n\nWith file-based routing enabled, whenever you start your application in development mode, TanStack Router will watch your configured routesDirectory and generate your route tree whenever a file is added, removed, or changed.\n\nIgnoring the generated route tree file\n\nIf your project is configured to use a linter and/or formatter, you may want to ignore the generated route tree file. This file is managed by TanStack Router and therefore shouldn't be changed by your linter or formatter.\n\nHere are some resources to help you ignore the generated route tree file:\n\nPrettier - https://prettier.io/docs/en/ignore.html#ignoring-files-prettierignore\nESLint - https://eslint.org/docs/latest/use/configure/ignore#ignoring-files\nBiome - https://biomejs.dev/reference/configuration/#filesignore\n\nWarning\n\nIf you are using VSCode, you may experience the route tree file unexpectedly open (with errors) after renaming a route.\n\nYou can prevent that from the VSCode settings by marking the file as readonly. Our recommendation is to also exclude it from search results and file watcher with the following settings:\n\njson\n{\n  \"files.readonlyInclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"files.watcherExclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"search.exclude\": {\n    \"**/routeTree.gen.ts\": true\n  }\n}\n\n\nYou can use those settings either at a user level or only for a single workspace by creating the file .vscode/settings.json at the root of your project.\n\nConfiguration\n\nWhen using the TanStack Router CLI for File-based routing, it comes with some sane defaults that should work for most projects:\n\njson\n{\n  \"routesDirectory\": \"./src/routes\",\n  \"generatedRouteTree\": \"./src/routeTree.gen.ts\",\n  \"routeFileIgnorePrefix\": \"-\",\n  \"quoteStyle\": \"single\"\n}\n\n\nIf these defaults work for your project, you don't need to configure anything at all! However, if you need to customize the configuration, you can do so by creating a tsr.config.json file in the root of your project directory.\n\nYou can find all the available configuration options in the File-based Routing API Reference.\n\nEdit on GitHub\nInstallation with Esbuild\nFile Naming Conventions\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Installation with Webpack | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/installation-with-webpack",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nInstallation with Webpack\n\nTo use file-based routing with Webpack, you'll need to install the @tanstack/router-plugin package.\n\nsh\nnpm install -D @tanstack/router-plugin\n\n\nOnce installed, you'll need to add the plugin to your configuration.\n\ntsx\n// webpack.config.ts\nimport { TanStackRouterWebpack } from '@tanstack/router-plugin/webpack'\n\nexport default {\n  plugins: [\n    TanStackRouterWebpack({ target: 'react', autoCodeSplitting: true }),\n  ],\n}\n\n\nOr, you can clone our Quickstart Webpack example and get started.\n\nNow that you've added the plugin to your Webpack configuration, you're all set to start using file-based routing with TanStack Router.\n\nIgnoring the generated route tree file\n\nIf your project is configured to use a linter and/or formatter, you may want to ignore the generated route tree file. This file is managed by TanStack Router and therefore shouldn't be changed by your linter or formatter.\n\nHere are some resources to help you ignore the generated route tree file:\n\nPrettier - https://prettier.io/docs/en/ignore.html#ignoring-files-prettierignore\nESLint - https://eslint.org/docs/latest/use/configure/ignore#ignoring-files\nBiome - https://biomejs.dev/reference/configuration/#filesignore\n\nWarning\n\nIf you are using VSCode, you may experience the route tree file unexpectedly open (with errors) after renaming a route.\n\nYou can prevent that from the VSCode settings by marking the file as readonly. Our recommendation is to also exclude it from search results and file watcher with the following settings:\n\njson\n{\n  \"files.readonlyInclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"files.watcherExclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"search.exclude\": {\n    \"**/routeTree.gen.ts\": true\n  }\n}\n\n\nYou can use those settings either at a user level or only for a single workspace by creating the file .vscode/settings.json at the root of your project.\n\nConfiguration\n\nWhen using the TanStack Router Plugin with Webpack for File-based routing, it comes with some sane defaults that should work for most projects:\n\njson\n{\n  \"routesDirectory\": \"./src/routes\",\n  \"generatedRouteTree\": \"./src/routeTree.gen.ts\",\n  \"routeFileIgnorePrefix\": \"-\",\n  \"quoteStyle\": \"single\"\n}\n\n\nIf these defaults work for your project, you don't need to configure anything at all! However, if you need to customize the configuration, you can do so by editing the configuration object passed into the TanStackRouterWebpack function.\n\nYou can find all the available configuration options in the File-based Routing API Reference.\n\nEdit on GitHub\nInstallation with Rspack/Rsbuild\nInstallation with Esbuild\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Installation with Rspack | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/installation-with-rspack",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nInstallation with Rspack\n\nTo use file-based routing with Rspack or Rsbuild, you'll need to install the @tanstack/router-plugin package.\n\nsh\nnpm install -D @tanstack/router-plugin\n\n\nOnce installed, you'll need to add the plugin to your configuration.\n\ntsx\n// rsbuild.config.ts\nimport { defineConfig } from '@rsbuild/core'\nimport { pluginReact } from '@rsbuild/plugin-react'\nimport { TanStackRouterRspack } from '@tanstack/router-plugin/rspack'\n\nexport default defineConfig({\n  plugins: [pluginReact()],\n  tools: {\n    rspack: {\n      plugins: [\n        TanStackRouterRspack({ target: 'react', autoCodeSplitting: true }),\n      ],\n    },\n  },\n})\n\n\nOr, you can clone our Quickstart Rspack/Rsbuild example and get started.\n\nNow that you've added the plugin to your Rspack/Rsbuild configuration, you're all set to start using file-based routing with TanStack Router.\n\nIgnoring the generated route tree file\n\nIf your project is configured to use a linter and/or formatter, you may want to ignore the generated route tree file. This file is managed by TanStack Router and therefore shouldn't be changed by your linter or formatter.\n\nHere are some resources to help you ignore the generated route tree file:\n\nPrettier - https://prettier.io/docs/en/ignore.html#ignoring-files-prettierignore\nESLint - https://eslint.org/docs/latest/use/configure/ignore#ignoring-files\nBiome - https://biomejs.dev/reference/configuration/#filesignore\n\nWarning\n\nIf you are using VSCode, you may experience the route tree file unexpectedly open (with errors) after renaming a route.\n\nYou can prevent that from the VSCode settings by marking the file as readonly. Our recommendation is to also exclude it from search results and file watcher with the following settings:\n\njson\n{\n  \"files.readonlyInclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"files.watcherExclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"search.exclude\": {\n    \"**/routeTree.gen.ts\": true\n  }\n}\n\n\nYou can use those settings either at a user level or only for a single workspace by creating the file .vscode/settings.json at the root of your project.\n\nConfiguration\n\nWhen using the TanStack Router Plugin with Rspack (or Rsbuild) for File-based routing, it comes with some sane defaults that should work for most projects:\n\njson\n{\n  \"routesDirectory\": \"./src/routes\",\n  \"generatedRouteTree\": \"./src/routeTree.gen.ts\",\n  \"routeFileIgnorePrefix\": \"-\",\n  \"quoteStyle\": \"single\"\n}\n\n\nIf these defaults work for your project, you don't need to configure anything at all! However, if you need to customize the configuration, you can do so by editing the configuration object passed into the TanStackRouterVite function.\n\nYou can find all the available configuration options in the File-based Routing API Reference.\n\nEdit on GitHub\nInstallation with Vite\nInstallation with Webpack\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Installation with Vite | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/installation-with-vite",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nInstallation with Vite\n\nTo use file-based routing with Vite, you'll need to install the @tanstack/router-plugin package.\n\nsh\nnpm install -D @tanstack/router-plugin\n\n\nOnce installed, you'll need to add the plugin to your Vite configuration.\n\nts\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    // Please make sure that '@tanstack/router-plugin' is passed before '@vitejs/plugin-react'\n    TanStackRouterVite({ target: 'react', autoCodeSplitting: true }),\n    react(),\n    // ...\n  ],\n})\n\n\nOr, you can clone our Quickstart Vite example and get started.\n\nWarning\n\nIf you are using the older @tanstack/router-vite-plugin package, you can still continue to use it, as it will be aliased to the @tanstack/router-plugin/vite package. However, we would recommend using the @tanstack/router-plugin package directly.\n\nNow that you've added the plugin to your Vite configuration, you're all set to start using file-based routing with TanStack Router.\n\nIgnoring the generated route tree file\n\nIf your project is configured to use a linter and/or formatter, you may want to ignore the generated route tree file. This file is managed by TanStack Router and therefore shouldn't be changed by your linter or formatter.\n\nHere are some resources to help you ignore the generated route tree file:\n\nPrettier - https://prettier.io/docs/en/ignore.html#ignoring-files-prettierignore\nESLint - https://eslint.org/docs/latest/use/configure/ignore#ignoring-files\nBiome - https://biomejs.dev/reference/configuration/#filesignore\n\nWarning\n\nIf you are using VSCode, you may experience the route tree file unexpectedly open (with errors) after renaming a route.\n\nYou can prevent that from the VSCode settings by marking the file as readonly. Our recommendation is to also exclude it from search results and file watcher with the following settings:\n\njson\n{\n  \"files.readonlyInclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"files.watcherExclude\": {\n    \"**/routeTree.gen.ts\": true\n  },\n  \"search.exclude\": {\n    \"**/routeTree.gen.ts\": true\n  }\n}\n\n\nYou can use those settings either at a user level or only for a single workspace by creating the file .vscode/settings.json at the root of your project.\n\nConfiguration\n\nWhen using the TanStack Router Plugin with Vite for File-based routing, it comes with some sane defaults that should work for most projects:\n\njson\n{\n  \"routesDirectory\": \"./src/routes\",\n  \"generatedRouteTree\": \"./src/routeTree.gen.ts\",\n  \"routeFileIgnorePrefix\": \"-\",\n  \"quoteStyle\": \"single\"\n}\n\n\nIf these defaults work for your project, you don't need to configure anything at all! However, if you need to customize the configuration, you can do so by editing the configuration object passed into the TanStackRouterVite function.\n\nYou can find all the available configuration options in the File-based Routing API Reference.\n\nEdit on GitHub\nCode-Based Routing\nInstallation with Rspack/Rsbuild\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Code-Based Routing | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/code-based-routing",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nCode-Based Routing\n\nTip\n\nCode-based routing is not recommended for most applications. It is recommended to use File-Based Routing instead.\n\n‚ö†Ô∏è Before You Start\nIf you're using File-Based Routing, skip this guide.\nIf you still insist on using code-based routing, you must read the Routing Concepts guide first, as it also covers core concepts of the router.\nRoute Trees\n\nCode-based routing is no different from file-based routing in that it uses the same route tree concept to organize, match and compose matching routes into a component tree. The only difference is that instead of using the filesystem to organize your routes, you use code.\n\nLet's consider the same route tree from the Route Trees & Nesting guide, and convert it to code-based routing:\n\nHere is the file-based version:\n\nroutes/\n‚îú‚îÄ‚îÄ __root.tsx\n‚îú‚îÄ‚îÄ index.tsx\n‚îú‚îÄ‚îÄ about.tsx\n‚îú‚îÄ‚îÄ posts/\n‚îÇ   ‚îú‚îÄ‚îÄ index.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ $postId.tsx\n‚îú‚îÄ‚îÄ posts.$postId.edit.tsx\n‚îú‚îÄ‚îÄ settings/\n‚îÇ   ‚îú‚îÄ‚îÄ profile.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ notifications.tsx\n‚îú‚îÄ‚îÄ _pathlessLayout.tsx\n‚îú‚îÄ‚îÄ _pathlessLayout/\n‚îÇ   ‚îú‚îÄ‚îÄ route-a.tsx\n‚îú‚îÄ‚îÄ ‚îú‚îÄ‚îÄ route-b.tsx\n‚îú‚îÄ‚îÄ files/\n‚îÇ   ‚îú‚îÄ‚îÄ $.tsx\n\n\nAnd here is a summarized code-based version:\n\ntsx\nimport { createRootRoute, createRoute } from '@tanstack/react-router'\n\nconst rootRoute = createRootRoute()\n\nconst indexRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/',\n})\n\nconst aboutRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'about',\n})\n\nconst postsRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'posts',\n})\n\nconst postsIndexRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '/',\n})\n\nconst postRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '$postId',\n})\n\nconst postEditorRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'posts/$postId/edit',\n})\n\nconst settingsRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'settings',\n})\n\nconst profileRoute = createRoute({\n  getParentRoute: () => settingsRoute,\n  path: 'profile',\n})\n\nconst notificationsRoute = createRoute({\n  getParentRoute: () => settingsRoute,\n  path: 'notifications',\n})\n\nconst pathlessLayoutRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  id: 'pathlessLayout',\n})\n\nconst pathlessLayoutARoute = createRoute({\n  getParentRoute: () => pathlessLayoutRoute,\n  path: 'route-a',\n})\n\nconst pathlessLayoutBRoute = createRoute({\n  getParentRoute: () => pathlessLayoutRoute,\n  path: 'route-b',\n})\n\nconst filesRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'files/$',\n})\n\nAnatomy of a Route\n\nAll other routes other than the root route are configured using the createRoute function:\n\ntsx\nconst route = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/posts',\n  component: PostsComponent,\n})\n\n\nThe getParentRoute option is a function that returns the parent route of the route you're creating.\n\n‚ùì‚ùì‚ùì \"Wait, you're making me pass the parent route for every route I make?\"\n\nAbsolutely! The reason for passing the parent route has everything to do with the magical type safety of TanStack Router. Without the parent route, TypeScript would have no idea what types to supply your route with!\n\nImportant\n\nFor every route that NOT the Root Route or a Pathless Layout Route, a path option is required. This is the path that will be matched against the URL pathname to determine if the route is a match.\n\nWhen configuring route path option on a route, it ignores leading and trailing slashes (this does not include \"index\" route paths /). You can include them if you want, but they will be normalized internally by TanStack Router. Here is a table of valid paths and what they will be normalized to:\n\nPath\tNormalized Path\n/\t/\n/about\tabout\nabout/\tabout\nabout\tabout\n$\t$\n/$\t$\n/$/\t$\nManually building the route tree\n\nWhen building a route tree in code, it's not enough to define the parent route of each route. You must also construct the final route tree by adding each route to its parent route's children array. This is because the route tree is not built automatically for you like it is in file-based routing.\n\ntsx\n/* prettier-ignore */\nconst routeTree = rootRoute.addChildren([\n  indexRoute,\n  aboutRoute,\n  postsRoute.addChildren([\n    postsIndexRoute,\n    postRoute,\n  ]),\n  postEditorRoute,\n  settingsRoute.addChildren([\n    profileRoute,\n    notificationsRoute,\n  ]),\n  pathlessLayoutRoute.addChildren([\n    pathlessLayoutARoute,\n    pathlessLayoutBRoute,\n  ]),\n  filesRoute.addChildren([\n    fileRoute,\n  ]),\n])\n/* prettier-ignore-end */\n\n\nBut before you can go ahead and build the route tree, you need to understand how the Routing Concepts for Code-Based Routing work.\n\nRouting Concepts for Code-Based Routing\n\nBelieve it or not, file-based routing is really a superset of code-based routing and uses the filesystem and a bit of code-generation abstraction on top of it to generate this structure you see above automatically.\n\nWe're going to assume you've read the Routing Concepts guide and are familiar with each of these main concepts:\n\nThe Root Route\nBasic Routes\nIndex Routes\nDynamic Route Segments\nSplat / Catch-All Routes\nLayout Routes\nPathless Routes\nNon-Nested Routes\n\nNow, let's take a look at how to create each of these route types in code.\n\nThe Root Route\n\nCreating a root route in code-based routing is thankfully the same as doing so in file-based routing. Call the createRootRoute() function.\n\nUnlike file-based routing however, you do not need to export the root route if you don't want to. It's certainly not recommended to build an entire route tree and application in a single file (although you can and we do this in the examples to demonstrate routing concepts in brevity).\n\ntsx\n// Standard root route\nimport { createRootRoute } from '@tanstack/react-router'\n\nconst rootRoute = createRootRoute()\n\n// Root route with Context\nimport { createRootRouteWithContext } from '@tanstack/react-router'\nimport type { QueryClient } from '@tanstack/react-query'\n\nexport interface MyRouterContext {\n  queryClient: QueryClient\n}\nconst rootRoute = createRootRouteWithContext<MyRouterContext>()\n\n\nTo learn more about Context in TanStack Router, see the Router Context guide.\n\nBasic Routes\n\nTo create a basic route, simply provide a normal path string to the createRoute function:\n\ntsx\nconst aboutRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'about',\n})\n\n\nSee, it's that simple! The aboutRoute will match the URL /about.\n\nIndex Routes\n\nUnlike file-based routing, which uses the index filename to denote an index route, code-based routing uses a single slash / to denote an index route. For example, the posts.index.tsx file from our example route tree above would be represented in code-based routing like this:\n\ntsx\nconst postsRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'posts',\n})\n\nconst postsIndexRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  // Notice the single slash `/` here\n  path: '/',\n})\n\n\nSo, the postsIndexRoute will match the URL /posts/ (or /posts).\n\nDynamic Route Segments\n\nDynamic route segments work exactly the same in code-based routing as they do in file-based routing. Simply prefix a segment of the path with a $ and it will be captured into the params object of the route's loader or component:\n\ntsx\nconst postIdRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '$postId',\n  // In a loader\n  loader: ({ params }) => fetchPost(params.postId),\n  // Or in a component\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  const { postId } = postIdRoute.useParams()\n  return <div>Post ID: {postId}</div>\n}\n\n\nTip\n\nIf your component is code-split, you can use the getRouteApi function to avoid having to import the postIdRoute configuration to get access to the typed useParams() hook.\n\nSplat / Catch-All Routes\n\nAs expected, splat/catch-all routes also work the same in code-based routing as they do in file-based routing. Simply prefix a segment of the path with a $ and it will be captured into the params object under the _splat key:\n\ntsx\nconst filesRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'files',\n})\n\nconst fileRoute = createRoute({\n  getParentRoute: () => filesRoute,\n  path: '$',\n})\n\n\nFor the URL /documents/hello-world, the params object will look like this:\n\njs\n{\n  '_splat': 'documents/hello-world'\n}\n\nLayout Routes\n\nLayout routes are routes that wrap their children in a layout component. In code-based routing, you can create a layout route by simply nesting a route under another route:\n\ntsx\nconst postsRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'posts',\n  component: PostsLayoutComponent, // The layout component\n})\n\nfunction PostsLayoutComponent() {\n  return (\n    <div>\n      <h1>Posts</h1>\n      <Outlet />\n    </div>\n  )\n}\n\nconst postsIndexRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '/',\n})\n\nconst postsCreateRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: 'create',\n})\n\nconst routeTree = rootRoute.addChildren([\n  // The postsRoute is the layout route\n  // Its children will be nested under the PostsLayoutComponent\n  postsRoute.addChildren([postsIndexRoute, postsCreateRoute]),\n])\n\n\nNow, both the postsIndexRoute and postsCreateRoute will render their contents inside of the PostsLayoutComponent:\n\ntsx\n// URL: /posts\n<PostsLayoutComponent>\n  <PostsIndexComponent />\n</PostsLayoutComponent>\n\n// URL: /posts/create\n<PostsLayoutComponent>\n  <PostsCreateComponent />\n</PostsLayoutComponent>\n\nPathless Layout Routes\n\nIn file-based routing a pathless layout route is prefixed with a _, but in code-based routing, this is simply a route with an id instead of a path option. This is because code-based routing does not use the filesystem to organize routes, so there is no need to prefix a route with a _ to denote that it has no path.\n\ntsx\nconst pathlessLayoutRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  id: 'pathlessLayout',\n  component: PathlessLayoutComponent,\n})\n\nfunction PathlessLayoutComponent() {\n  return (\n    <div>\n      <h1>Pathless Layout</h1>\n      <Outlet />\n    </div>\n  )\n}\n\nconst pathlessLayoutARoute = createRoute({\n  getParentRoute: () => pathlessLayoutRoute,\n  path: 'route-a',\n})\n\nconst pathlessLayoutBRoute = createRoute({\n  getParentRoute: () => pathlessLayoutRoute,\n  path: 'route-b',\n})\n\nconst routeTree = rootRoute.addChildren([\n  // The pathless layout route has no path, only an id\n  // So its children will be nested under the pathless layout route\n  pathlessLayoutRoute.addChildren([pathlessLayoutARoute, pathlessLayoutBRoute]),\n])\n\n\nNow both /route-a and /route-b will render their contents inside of the PathlessLayoutComponent:\n\ntsx\n// URL: /route-a\n<PathlessLayoutComponent>\n  <RouteAComponent />\n</PathlessLayoutComponent>\n\n// URL: /route-b\n<PathlessLayoutComponent>\n  <RouteBComponent />\n</PathlessLayoutComponent>\n\nNon-Nested Routes\n\nBuilding non-nested routes in code-based routing does not require using a trailing _ in the path, but does require you to build your route and route tree with the right paths and nesting. Let's consider the route tree where we want the post editor to not be nested under the posts route:\n\n/posts_/$postId/edit\n/posts\n$postId\n\nTo do this we need to build a separate route for the post editor and include the entire path in the path option from the root of where we want the route to be nested (in this case, the root):\n\ntsx\n// The posts editor route is nested under the root route\nconst postEditorRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  // The path includes the entire path we need to match\n  path: 'posts/$postId/edit',\n})\n\nconst postsRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: 'posts',\n})\n\nconst postRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '$postId',\n})\n\nconst routeTree = rootRoute.addChildren([\n  // The post editor route is nested under the root route\n  postEditorRoute,\n  postsRoute.addChildren([postRoute]),\n])\n\nEdit on GitHub\nVirtual File Routes\nInstallation with Vite\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nSTART\nFull-document SSR, Streaming, Server Functions, bundling and more, powered by TanStack Router and Vite - Ready to deploy to your favorite hosting provider.\nLEARN MORE\nTANSTACK\nSTORE\nThe immutable-reactive data store that powers the core of TanStack libraries and their framework adapters.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Virtual File Routes | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/virtual-file-routes",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nVirtual File Routes\n\nWe'd like to thank the Remix team for pioneering the concept of virtual file routes. We've taken inspiration from their work and adapted it to work with TanStack Router's existing file-based route-tree generation.\n\nVirtual file routes are a powerful concept that allows you to build a route tree programmatically using code that references real files in your project. This can be useful if:\n\nYou have an existing route organization that you want to keep.\nYou want to customize the location of your route files.\nYou want to completely override TanStack Router's file-based route generation and build your own convention.\n\nHere's a quick example of using virtual file routes to map a route tree to a set of real files in your project:\n\ntsx\n// routes.ts\nimport {\n  rootRoute,\n  route,\n  index,\n  layout,\n  physical,\n} from '@tanstack/virtual-file-routes'\n\nexport const routes = rootRoute('root.tsx', [\n  index('index.tsx'),\n  layout('pathlessLayout.tsx', [\n    route('/dashboard', 'app/dashboard.tsx', [\n      index('app/dashboard-index.tsx'),\n      route('/invoices', 'app/dashboard-invoices.tsx', [\n        index('app/invoices-index.tsx'),\n        route('$id', 'app/invoice-detail.tsx'),\n      ]),\n    ]),\n    physical('/posts', 'posts'),\n  ]),\n])\n\nConfiguration\n\nVirtual file routes can be configured either via:\n\nThe TanStackRouter plugin for Vite/Rspack/Webpack\nThe tsr.config.json file for the TanStack Router CLI\nConfiguration via the TanStackRouter Plugin\n\nIf you're using the TanStackRouter plugin for Vite/Rspack/Webpack, you can configure virtual file routes by passing the path of your routes file to the virtualRoutesConfig option when setting up the plugin:\n\ntsx\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n\nexport default defineConfig({\n  plugins: [\n    TanStackRouterVite({\n      target: 'react',\n      virtualRouteConfig: './routes.ts',\n    }),\n    react(),\n  ],\n})\n\n\nOr, you choose to define the virtual routes directly in the configuration:\n\ntsx\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\nimport { rootRoute } from '@tanstack/virtual-file-routes'\n\nconst routes = rootRoute('root.tsx', [\n  // ... the rest of your virtual route tree\n])\n\nexport default defineConfig({\n  plugins: [TanStackRouterVite({ virtualRouteConfig: routes }), react()],\n})\n\nCreating Virtual File Routes\n\nTo create virtual file routes, you'll need to import the @tanstack/virtual-file-routes package. This package provides a set of functions that allow you to create virtual routes that reference real files in your project. A few utility functions are exported from the package:\n\nrootRoute - Creates a virtual root route.\nroute - Creates a virtual route.\nindex - Creates a virtual index route.\nlayout - Creates a virtual pathless layout route.\nphysical - Creates a physical virtual route (more on this later).\nVirtual Root Route\n\nThe rootRoute function is used to create a virtual root route. It takes a file name and an array of children routes. Here's an example of a virtual root route:\n\ntsx\n// routes.ts\nimport { rootRoute } from '@tanstack/virtual-file-routes'\n\nexport const routes = rootRoute('root.tsx', [\n  // ... children routes\n])\n\nVirtual Route\n\nThe route function is used to create a virtual route. It takes a path, a file name, and an array of children routes. Here's an example of a virtual route:\n\ntsx\n// routes.ts\nimport { route } from '@tanstack/virtual-file-routes'\n\nexport const routes = rootRoute('root.tsx', [\n  route('/about', 'about.tsx', [\n    // ... children routes\n  ]),\n])\n\n\nYou can also define a virtual route without a file name. This allows to set a common path prefix for its children:\n\ntsx\n// routes.ts\nimport { route } from '@tanstack/virtual-file-routes'\n\nexport const routes = rootRoute('root.tsx', [\n  route('/hello', [\n    route('/world', 'world.tsx'), // full path will be \"/hello/world\"\n    route('/universe', 'universe.tsx'), // full path will be \"/hello/universe\"\n  ]),\n])\n\nVirtual Index Route\n\nThe index function is used to create a virtual index route. It takes a file name. Here's an example of a virtual index route:\n\ntsx\nimport { index } from '@tanstack/virtual-file-routes'\n\nconst routes = rootRoute('root.tsx', [index('index.tsx')])\n\nVirtual Pathless Route\n\nThe layout function is used to create a virtual pathless route. It takes a file name, an array of children routes, and an optional pathless ID. Here's an example of a virtual pathless route:\n\ntsx\n// routes.ts\nimport { layout } from '@tanstack/virtual-file-routes'\n\nexport const routes = rootRoute('root.tsx', [\n  layout('pathlessLayout.tsx', [\n    // ... children routes\n  ]),\n])\n\n\nYou can also specify a pathless ID to give the route a unique identifier that is different from the filename:\n\ntsx\n// routes.ts\nimport { layout } from '@tanstack/virtual-file-routes'\n\nexport const routes = rootRoute('root.tsx', [\n  layout('my-pathless-layout-id', 'pathlessLayout.tsx', [\n    // ... children routes\n  ]),\n])\n\nPhysical Virtual Routes\n\nPhysical virtual routes are a way to \"mount\" a directory of good ol' TanStack Router File Based routing convention under a specific URL path. This can be useful if you are using virtual routes to customize a small portion of your route tree high up in the hierarchy, but want to use the standard file-based routing convention for sub-routes and directories.\n\nConsider the following file structure:\n\n/routes\n‚îú‚îÄ‚îÄ root.tsx\n‚îú‚îÄ‚îÄ index.tsx\n‚îú‚îÄ‚îÄ pathless.tsx\n‚îú‚îÄ‚îÄ app\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard-index.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard-invoices.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ invoices-index.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ invoice-detail.tsx\n‚îî‚îÄ‚îÄ posts\n    ‚îú‚îÄ‚îÄ index.tsx\n    ‚îú‚îÄ‚îÄ $postId.tsx\n    ‚îú‚îÄ‚îÄ $postId.edit.tsx\n    ‚îú‚îÄ‚îÄ comments/\n    ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx\n    ‚îÇ   ‚îú‚îÄ‚îÄ $commentId.tsx\n    ‚îî‚îÄ‚îÄ likes/\n        ‚îú‚îÄ‚îÄ index.tsx\n        ‚îú‚îÄ‚îÄ $likeId.tsx\n\n\nLet's use virtual routes to customize our route tree for everything but posts, then use physical virtual routes to mount the posts directory under the /posts path:\n\ntsx\n// routes.ts\nexport const routes = rootRoute('root.tsx', [\n  // Set up your virtual routes as normal\n  index('index.tsx'),\n  layout('pathlessLayout.tsx', [\n    route('/dashboard', 'app/dashboard.tsx', [\n      index('app/dashboard-index.tsx'),\n      route('/invoices', 'app/dashboard-invoices.tsx', [\n        index('app/invoices-index.tsx'),\n        route('$id', 'app/invoice-detail.tsx'),\n      ]),\n    ]),\n    // Mount the `posts` directory under the `/posts` path\n    physical('/posts', 'posts'),\n  ]),\n])\n\nVirtual Routes inside of TanStack Router File Based routing\n\nThe previous section showed you how you can use TanStack Router's File Based routing convention inside of a virtual route configuration. However, the opposite is possible as well.\nYou can configure the main part of your app's route tree using TanStack Router's File Based routing convention and opt into virtual route configuration for specific subtrees.\n\nConsider the following file structure:\n\n/routes\n‚îú‚îÄ‚îÄ __root.tsx\n‚îú‚îÄ‚îÄ foo\n‚îÇ   ‚îú‚îÄ‚îÄ bar\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __virtual.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ details.tsx\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home.tsx\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ route.ts\n‚îÇ   ‚îî‚îÄ‚îÄ bar.tsx\n‚îî‚îÄ‚îÄ index.tsx\n\n\nLet's look at the bar directory which contains a special file named __virtual.ts. This file instructs the generator to switch over to virtual file route configuration for this directory (and its child directories).\n\n__virtual.ts configures the virtual routes for that particular subtree of the route tree. It uses the same API as explained above, with the only difference being that no rootRoute is defined for that subtree:\n\ntsx\n// routes/foo/bar/__virtual.ts\nimport {\n  defineVirtualSubtreeConfig,\n  index,\n  route,\n} from '@tanstack/virtual-file-routes'\n\nexport default defineVirtualSubtreeConfig([\n  index('home.tsx'),\n  route('$id', 'details.tsx'),\n])\n\n\nThe helper function defineVirtualSubtreeConfig is closely modeled after vite's defineConfig and allows you to define a subtree configuration via a default export. The default export can either be\n\na subtree config object\na function returning a subtree config object\nan async function returning a subtree config object\nInception\n\nYou can mix and match TanStack Router's File Based routing convention and virtual route configuration however you like.\nLet's go deeper!\nCheck out the following example that starts off using File Based routing convention, switches over to virtual route configuration for /posts, switches back to File Based routing convention for /posts/lets-go only to switch over to virtual route configuration again for /posts/lets-go/deeper.\n\n‚îú‚îÄ‚îÄ __root.tsx\n‚îú‚îÄ‚îÄ index.tsx\n‚îú‚îÄ‚îÄ posts\n‚îÇ   ‚îú‚îÄ‚îÄ __virtual.ts\n‚îÇ   ‚îú‚îÄ‚îÄ details.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ home.tsx\n‚îÇ   ‚îî‚îÄ‚îÄ lets-go\n‚îÇ       ‚îú‚îÄ‚îÄ deeper\n‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ __virtual.ts\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ home.tsx\n‚îÇ       ‚îî‚îÄ‚îÄ index.tsx\n‚îî‚îÄ‚îÄ posts.tsx\n\nConfiguration via the TanStack Router CLI\n\nIf you're using the TanStack Router CLI, you can configure virtual file routes by defining the path to your routes file in the tsr.config.json file:\n\njson\n// tsr.config.json\n{\n  \"virtualRouteConfig\": \"./routes.ts\"\n}\n\n\nOr you can define the virtual routes directly in the configuration, while much less common allows you to configure them via the TanStack Router CLI by adding a virtualRouteConfig object to your tsr.config.json file and defining your virtual routes and passing the resulting JSON that is generated by calling the actual rootRoute/route/index/etc functions from the @tanstack/virtual-file-routes package:\n\njson\n// tsr.config.json\n{\n  \"virtualRouteConfig\": {\n    \"type\": \"root\",\n    \"file\": \"root.tsx\",\n    \"children\": [\n      {\n        \"type\": \"index\",\n        \"file\": \"home.tsx\"\n      },\n      {\n        \"type\": \"route\",\n        \"file\": \"posts/posts.tsx\",\n        \"path\": \"/posts\",\n        \"children\": [\n          {\n            \"type\": \"index\",\n            \"file\": \"posts/posts-home.tsx\"\n          },\n          {\n            \"type\": \"route\",\n            \"file\": \"posts/posts-detail.tsx\",\n            \"path\": \"$postId\"\n          }\n        ]\n      },\n      {\n        \"type\": \"layout\",\n        \"id\": \"first\",\n        \"file\": \"layout/first-pathless-layout.tsx\",\n        \"children\": [\n          {\n            \"type\": \"layout\",\n            \"id\": \"second\",\n            \"file\": \"layout/second-pathless-layout.tsx\",\n            \"children\": [\n              {\n                \"type\": \"route\",\n                \"file\": \"a.tsx\",\n                \"path\": \"/route-a\"\n              },\n              {\n                \"type\": \"route\",\n                \"file\": \"b.tsx\",\n                \"path\": \"/route-b\"\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n\nEdit on GitHub\nFile-Based Routing\nCode-Based Routing\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "File-Based Routing | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/file-based-routing",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nFile-Based Routing\n\nMost of the TanStack Router documentation is written for file-based routing and is intended to help you understand in more detail how to configure file-based routing and the technical details behind how it works. While file-based routing is the preferred and recommended way to configure TanStack Router, you can also use code-based routing if you prefer.\n\nWhat is File-Based Routing?\n\nFile-based routing is a way to configure your routes using the filesystem. Instead of defining your route structure via code, you can define your routes using a series of files and directories that represent the route hierarchy of your application. This brings a number of benefits:\n\nSimplicity: File-based routing is visually intuitive and easy to understand for both new and experienced developers.\nOrganization: Routes are organized in a way that mirrors the URL structure of your application.\nScalability: As your application grows, file-based routing makes it easy to add new routes and maintain existing ones.\nCode-Splitting: File-based routing allows TanStack Router to automatically code-split your routes for better performance.\nType-Safety: File-based routing raises the ceiling on type-safety by generating managing type linkages for your routes, which can otherwise be a tedious process via code-based routing.\nConsistency: File-based routing enforces a consistent structure for your routes, making it easier to maintain and update your application and move from one project to another.\n/s or .s?\n\nWhile directories have long been used to represent route hierarchy, file-based routing introduces an additional concept of using the . character in the file-name to denote a route nesting. This allows you to avoid creating directories for few deeply nested routes and continue to use directories for wider route hierarchies. Let's take a look at some examples!\n\nDirectory Routes\n\nDirectories can be used to denote route hierarchy, which can be useful for organizing multiple routes into logical groups and also cutting down on the filename length for large groups of deeply nested routes.\n\nSee the example below:\n\nFilename\tRoute Path\tComponent Output\n ¶ __root.tsx\t\t<Root>\n ¶ index.tsx\t/ (exact)\t<Root><RootIndex>\n ¶ about.tsx\t/about\t<Root><About>\n ¶ posts.tsx\t/posts\t<Root><Posts>\nüìÇ posts\t\t\n‚îÑ  ¶ index.tsx\t/posts (exact)\t<Root><Posts><PostsIndex>\n‚îÑ  ¶ $postId.tsx\t/posts/$postId\t<Root><Posts><Post>\nüìÇ posts_\t\t\n‚îÑ üìÇ $postId\t\t\n‚îÑ ‚îÑ  ¶ edit.tsx\t/posts/$postId/edit\t<Root><EditPost>\n ¶ settings.tsx\t/settings\t<Root><Settings>\nüìÇ settings\t\t<Root><Settings>\n‚îÑ  ¶ profile.tsx\t/settings/profile\t<Root><Settings><Profile>\n‚îÑ  ¶ notifications.tsx\t/settings/notifications\t<Root><Settings><Notifications>\n ¶ _pathlessLayout.tsx\t\t<Root><PathlessLayout>\nüìÇ _pathlessLayout\t\t\n‚îÑ  ¶ route-a.tsx\t/route-a\t<Root><PathlessLayout><RouteA>\n‚îÑ  ¶ route-b.tsx\t/route-b\t<Root><PathlessLayout><RouteB>\nüìÇ files\t\t\n‚îÑ  ¶ $.tsx\t/files/$\t<Root><Files>\nüìÇ account\t\t\n‚îÑ  ¶ route.tsx\t/account\t<Root><Account>\n‚îÑ  ¶ overview.tsx\t/account/overview\t<Root><Account><Overview>\nFlat Routes\n\nFlat routing gives you the ability to use .s to denote route nesting levels.\n\nThis can be useful when you have a large number of uniquely deeply nested routes and want to avoid creating directories for each one:\n\nSee the example below:\n\nFilename\tRoute Path\tComponent Output\n ¶ __root.tsx\t\t<Root>\n ¶ index.tsx\t/ (exact)\t<Root><RootIndex>\n ¶ about.tsx\t/about\t<Root><About>\n ¶ posts.tsx\t/posts\t<Root><Posts>\n ¶ posts.index.tsx\t/posts (exact)\t<Root><Posts><PostsIndex>\n ¶ posts.$postId.tsx\t/posts/$postId\t<Root><Posts><Post>\n ¶ posts_.$postId.edit.tsx\t/posts/$postId/edit\t<Root><EditPost>\n ¶ settings.tsx\t/settings\t<Root><Settings>\n ¶ settings.profile.tsx\t/settings/profile\t<Root><Settings><Profile>\n ¶ settings.notifications.tsx\t/settings/notifications\t<Root><Settings><Notifications>\n ¶ _pathlessLayout.tsx\t\t<Root><PathlessLayout>\n ¶ _pathlessLayout.route-a.tsx\t/route-a\t<Root><PathlessLayout><RouteA>\n ¶ _pathlessLayout.route-b.tsx\t/route-b\t<Root><PathlessLayout><RouteB>\n ¶ files.$.tsx\t/files/$\t<Root><Files>\n ¶ account.tsx\t/account\t<Root><Account>\n ¶ account.overview.tsx\t/account/overview\t<Root><Account><Overview>\nMixed Flat and Directory Routes\n\nIt's extremely likely that a 100% directory or flat route structure won't be the best fit for your project, which is why TanStack Router allows you to mix both flat and directory routes together to create a route tree that uses the best of both worlds where it makes sense:\n\nSee the example below:\n\nFilename\tRoute Path\tComponent Output\n ¶ __root.tsx\t\t<Root>\n ¶ index.tsx\t/ (exact)\t<Root><RootIndex>\n ¶ about.tsx\t/about\t<Root><About>\n ¶ posts.tsx\t/posts\t<Root><Posts>\nüìÇ posts\t\t\n‚îÑ  ¶ index.tsx\t/posts (exact)\t<Root><Posts><PostsIndex>\n‚îÑ  ¶ $postId.tsx\t/posts/$postId\t<Root><Posts><Post>\n‚îÑ  ¶ $postId.edit.tsx\t/posts/$postId/edit\t<Root><Posts><Post><EditPost>\n ¶ settings.tsx\t/settings\t<Root><Settings>\n ¶ settings.profile.tsx\t/settings/profile\t<Root><Settings><Profile>\n ¶ settings.notifications.tsx\t/settings/notifications\t<Root><Settings><Notifications>\n ¶ account.tsx\t/account\t<Root><Account>\n ¶ account.overview.tsx\t/account/overview\t<Root><Account><Overview>\n\nBoth flat and directory routes can be mixed together to create a route tree that uses the best of both worlds where it makes sense.\n\nTip\n\nIf you find that the default file-based routing structure doesn't fit your needs, you can always use Virtual File Routes to control the source of your routes whilst still getting the awesome performance benefits of file-based routing.\n\nGetting started with File-Based Routing\n\nTo get started with file-based routing, you'll need to configure your project's bundler to use the TanStack Router Plugin or the TanStack Router CLI.\n\nTo enable file-based routing, you'll need to be using React with a supported bundler. See if your bundler is listed in the configuration guides below.\n\nInstallation with Vite\nInstallation with Rspack/Rsbuild\nInstallation with Webpack\nInstallation with Esbuild\n\nWhen using TanStack Router's file-based routing through one of the supported bundlers, our plugin will automatically generate your route configuration through your bundler's dev and build processes. It is the easiest way to use TanStack Router's route generation features.\n\nIf your bundler is not yet supported, you can reach out to us on Discord or GitHub to let us know. Till then, fear not! You can still use the @tanstack/router-cli package to generate your route tree file.\n\nEdit on GitHub\nRoute Matching\nVirtual File Routes\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Route Matching | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/route-matching",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRoute Matching\n\nRoute matching follows a consistent and predictable pattern. This guide will explain how route trees are matched.\n\nWhen TanStack Router processes your route tree, all of your routes are automatically sorted to match the most specific routes first. This means that regardless of the order your route tree is defined, routes will always be sorted in this order:\n\nIndex Route\nStatic Routes (most specific to least specific)\nDynamic Routes (longest to shortest)\nSplat/Wildcard Routes\n\nConsider the following pseudo route tree:\n\nRoot\n  - blog\n    - $postId\n    - /\n    - new\n  - /\n  - *\n  - about\n  - about/us\n\n\nAfter sorting, this route tree will become:\n\nRoot\n  - /\n  - about/us\n  - about\n  - blog\n    - /\n    - new\n    - $postId\n  - *\n\n\nThis final order represents the order in which routes will be matched based on specificity.\n\nUsing that route tree, let's follow the matching process for a few different URLs:\n\n/blog\nRoot\n  ‚ùå /\n  ‚ùå about/us\n  ‚ùå about\n  ‚è© blog\n    ‚úÖ /\n    - new\n    - $postId\n  - *\n\n/blog/my-post\nRoot\n  ‚ùå /\n  ‚ùå about/us\n  ‚ùå about\n  ‚è© blog\n    ‚ùå /\n    ‚ùå new\n    ‚úÖ $postId\n  - *\n\n/\nRoot\n  ‚úÖ /\n  - about/us\n  - about\n  - blog\n    - /\n    - new\n    - $postId\n  - *\n\n/not-a-route\nRoot\n  ‚ùå /\n  ‚ùå about/us\n  ‚ùå about\n  ‚ùå blog\n    - /\n    - new\n    - $postId\n  ‚úÖ *\n\nEdit on GitHub\nRoute Trees\nFile-Based Routing\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Route Trees | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/route-trees",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRoute Trees\n\nTanStack Router uses a nested route tree to match up the URL with the correct component tree to render.\n\nTo build a route tree, TanStack Router supports:\n\nFile-Based Routing\nCode-Based Routing\n\nBoth methods support the exact same core features and functionality, but file-based routing requires less code for the same or better results. For this reason, file-based routing is the preferred and recommended way to configure TanStack Router. Most of the documentation is written from the perspective of file-based routing.\n\nRoute Trees\n\nNested routing is a powerful concept that allows you to use a URL to render a nested component tree. For example, given the URL of /blog/posts/123, you could create a route hierarchy that looks like this:\n\ntsx\n‚îú‚îÄ‚îÄ blog\n‚îÇ   ‚îú‚îÄ‚îÄ posts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ $postId\n\n\nAnd render a component tree that looks like this:\n\ntsx\n<Blog>\n  <Posts>\n    <Post postId=\"123\" />\n  </Posts>\n</Blog>\n\n\nLet's take that concept and expand it out to a larger site structure, but with file-names now:\n\n/routes\n‚îú‚îÄ‚îÄ __root.tsx\n‚îú‚îÄ‚îÄ index.tsx\n‚îú‚îÄ‚îÄ about.tsx\n‚îú‚îÄ‚îÄ posts/\n‚îÇ   ‚îú‚îÄ‚îÄ index.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ $postId.tsx\n‚îú‚îÄ‚îÄ posts.$postId.edit.tsx\n‚îú‚îÄ‚îÄ settings/\n‚îÇ   ‚îú‚îÄ‚îÄ profile.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ notifications.tsx\n‚îú‚îÄ‚îÄ _pathlessLayout/\n‚îÇ   ‚îú‚îÄ‚îÄ route-a.tsx\n‚îú‚îÄ‚îÄ ‚îú‚îÄ‚îÄ route-b.tsx\n‚îú‚îÄ‚îÄ files/\n‚îÇ   ‚îú‚îÄ‚îÄ $.tsx\n\n\nThe above is a valid route tree configuration that can be used with TanStack Router! There's a lot of power and convention to unpack with file-based routing, so let's break it down a bit.\n\nRoute Tree Configuration\n\nRoute trees can be configured using a few different ways:\n\nFlat Routes\nDirectories\nMixed Flat Routes and Directories\nVirtual File Routes\nCode-Based Routes\n\nPlease be sure to check out the full documentation links above for each type of route tree, or just proceed to the next section to get started with file-based routing.\n\nEdit on GitHub\nRouting Concepts\nRoute Matching\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Routing Concepts | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/routing/routing-concepts",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nRouting Concepts\n\nTanStack Router supports a number of powerful routing concepts that allow you to build complex and dynamic routing systems with ease.\n\nEach of these concepts is useful and powerful, and we'll dive into each of them in the following sections.\n\nAnatomy of a Route\n\nAll other routes, other than the Root Route, are configured using the createFileRoute function, which provides type safety when using file-based routing:\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  component: PostsComponent,\n})\n\n\nThe createFileRoute function takes a single argument, the file-route's path as a string.\n\n‚ùì‚ùì‚ùì \"Wait, you're making me pass the path of the route file to createFileRoute?\"\n\nYes! But don't worry, this path is automatically written and managed by the router for you via the TanStack Router Bundler Plugin or Router CLI. So, as you create new routes, move routes around or rename routes, the path will be updated for you automatically.\n\nThe reason for this pathname has everything to do with the magical type safety of TanStack Router. Without this pathname, TypeScript would have no idea what file we're in! (We wish TypeScript had a built-in for this, but they don't yet ü§∑‚Äç‚ôÇÔ∏è)\n\nThe Root Route\n\nThe root route is the top-most route in the entire tree and encapsulates all other routes as children.\n\nIt has no path\nIt is always matched\nIts component is always rendered\n\nEven though it doesn't have a path, the root route has access to all of the same functionality as other routes including:\n\ncomponents\nloaders\nsearch param validation\netc.\n\nTo create a root route, call the createRootRoute() function and export it as the Route variable in your route file:\n\ntsx\n// Standard root route\nimport { createRootRoute } from '@tanstack/react-router'\n\nexport const Route = createRootRoute()\n\n// Root route with Context\nimport { createRootRouteWithContext } from '@tanstack/react-router'\nimport type { QueryClient } from '@tanstack/react-query'\n\nexport interface MyRouterContext {\n  queryClient: QueryClient\n}\nexport const Route = createRootRouteWithContext<MyRouterContext>()\n\n\nTo learn more about Context in TanStack Router, see the Router Context guide.\n\nBasic Routes\n\nBasic routes match a specific path, for example /about, /settings, /settings/notifications are all basic routes, as they match the path exactly.\n\nLet's take a look at an /about route:\n\ntsx\n// about.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/about')({\n  component: AboutComponent,\n})\n\nfunction AboutComponent() {\n  return <div>About</div>\n}\n\n\nBasic routes are simple and straightforward. They match the path exactly and render the provided component.\n\nIndex Routes\n\nIndex routes specifically target their parent route when it is matched exactly and no child route is matched.\n\nLet's take a look at an index route for a /posts URL:\n\ntsx\n// posts.index.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\n// Note the trailing slash, which is used to target index routes\nexport const Route = createFileRoute('/posts/')({\n  component: PostsIndexComponent,\n})\n\nfunction PostsIndexComponent() {\n  return <div>Please select a post!</div>\n}\n\n\nThis route will be matched when the URL is /posts exactly.\n\nDynamic Route Segments\n\nRoute path segments that start with a $ followed by a label are dynamic and capture that section of the URL into the params object for use in your application. For example, a pathname of /posts/123 would match the /posts/$postId route, and the params object would be { postId: '123' }.\n\nThese params are then usable in your route's configuration and components! Let's look at a posts.$postId.tsx route:\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  // In a loader\n  loader: ({ params }) => fetchPost(params.postId),\n  // Or in a component\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  // In a component!\n  const { postId } = Route.useParams()\n  return <div>Post ID: {postId}</div>\n}\n\n\nüß† Dynamic segments work at each segment of the path. For example, you could have a route with the path of /posts/$postId/$revisionId and each $ segment would be captured into the params object.\n\nSplat / Catch-All Routes\n\nA route with a path of only $ is called a \"splat\" route because it always captures any remaining section of the URL pathname from the $ to the end. The captured pathname is then available in the params object under the special _splat property.\n\nFor example, a route targeting the files/$ path is a splat route. If the URL pathname is /files/documents/hello-world, the params object would contain documents/hello-world under the special _splat property:\n\njs\n{\n  '_splat': 'documents/hello-world'\n}\n\n\n‚ö†Ô∏è In v1 of the router, splat routes are also denoted with a * instead of a _splat key for backwards compatibility. This will be removed in v2.\n\nüß† Why use $? Thanks to tools like Remix, we know that despite *s being the most common character to represent a wildcard, they do not play nice with filenames or CLI tools, so just like them, we decided to use $ instead.\n\nLayout Routes\n\nLayout routes are used to wrap child routes with additional components and logic. They are useful for:\n\nWrapping child routes with a layout component\nEnforcing a loader requirement before displaying any child routes\nValidating and providing search params to child routes\nProviding fallbacks for error components or pending elements to child routes\nProviding shared context to all child routes\nAnd more!\n\nLet's take a look at an example layout route called app.tsx:\n\nroutes/\n‚îú‚îÄ‚îÄ app.tsx\n‚îú‚îÄ‚îÄ app.dashboard.tsx\n‚îú‚îÄ‚îÄ app.settings.tsx\n\n\nIn the tree above, app.tsx is a layout route that wraps two child routes, app.dashboard.tsx and app.settings.tsx.\n\nThis tree structure is used to wrap the child routes with a layout component:\n\ntsx\nimport { Outlet, createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/app')({\n  component: AppLayoutComponent,\n})\n\nfunction AppLayoutComponent() {\n  return (\n    <div>\n      <h1>App Layout</h1>\n      <Outlet />\n    </div>\n  )\n}\n\n\nThe following table shows which component(s) will be rendered based on the URL:\n\nURL Path\tComponent\n/\t<Index>\n/app/dashboard\t<AppLayout><Dashboard>\n/app/settings\t<AppLayout><Settings>\n\nSince TanStack Router supports mixed flat and directory routes, you can also express your application's routing using layout routes within directories:\n\nroutes/\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ route.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ settings.tsx\n\n\nIn this nested tree, the app/route.tsx file is a configuration for the layout route that wraps two child routes, app/dashboard.tsx and app/settings.tsx.\n\nLayout Routes also let you enforce component and loader logic for Dynamic Route Segments:\n\nroutes/\n‚îú‚îÄ‚îÄ app/users/\n‚îÇ   ‚îú‚îÄ‚îÄ $userId/\n|   |   ‚îú‚îÄ‚îÄ route.tsx\n|   |   ‚îú‚îÄ‚îÄ index.tsx\n|   |   ‚îú‚îÄ‚îÄ edit.tsx\n\nPathless Layout Routes\n\nLike Layout Routes, Pathless Layout Routes are used to wrap child routes with additional components and logic. However, pathless layout routes do not require a matching path in the URL and are used to wrap child routes with additional components and logic without requiring a matching path in the URL.\n\nPathless Layout Routes are prefixed with an underscore (_) to denote that they are \"pathless\".\n\nüß† The part of the path after the _ prefix is used as the route's ID and is required because every route must be uniquely identifiable, especially when using TypeScript so as to avoid type errors and accomplish autocomplete effectively.\n\nLet's take a look at an example route called _pathlessLayout.tsx:\n\n\nroutes/\n‚îú‚îÄ‚îÄ _pathlessLayout.tsx\n‚îú‚îÄ‚îÄ _pathlessLayout.a.tsx\n‚îú‚îÄ‚îÄ _pathlessLayout.b.tsx\n\n\nIn the tree above, _pathlessLayout.tsx is a pathless layout route that wraps two child routes, _pathlessLayout.a.tsx and _pathlessLayout.b.tsx.\n\nThe _pathlessLayout.tsx route is used to wrap the child routes with a Pathless layout component:\n\ntsx\nimport { Outlet, createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/_pathlessLayout')({\n  component: PathlessLayoutComponent,\n})\n\nfunction PathlessLayoutComponent() {\n  return (\n    <div>\n      <h1>Pathless layout</h1>\n      <Outlet />\n    </div>\n  )\n}\n\n\nThe following table shows which component will be rendered based on the URL:\n\nURL Path\tComponent\n/\t<Index>\n/a\t<PathlessLayout><A>\n/b\t<PathlessLayout><B>\n\nSince TanStack Router supports mixed flat and directory routes, you can also express your application's routing using pathless layout routes within directories:\n\nroutes/\n‚îú‚îÄ‚îÄ _pathlessLayout/\n‚îÇ   ‚îú‚îÄ‚îÄ route.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ a.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ b.tsx\n\n\nHowever, unlike Layout Routes, since Pathless Layout Routes do match based on URL path segments, this means that these routes do not support Dynamic Route Segments as part of their path and therefore cannot be matched in the URL.\n\nThis means that you cannot do this:\n\nroutes/\n‚îú‚îÄ‚îÄ _$postId/ ‚ùå\n‚îÇ   ‚îú‚îÄ‚îÄ ...\n\n\nRather, you'd have to do this:\n\nroutes/\n‚îú‚îÄ‚îÄ $postId/\n‚îú‚îÄ‚îÄ _postPathlessLayout/ ‚úÖ\n‚îÇ   ‚îú‚îÄ‚îÄ ...\n\nNon-Nested Routes\n\nNon-nested routes can be created by suffixing a parent file route segment with a _ and are used to un-nest a route from its parents and render its own component tree.\n\nConsider the following flat route tree:\n\nroutes/\n‚îú‚îÄ‚îÄ posts.tsx\n‚îú‚îÄ‚îÄ posts.$postId.tsx\n‚îú‚îÄ‚îÄ posts_.$postId.edit.tsx\n\n\nThe following table shows which component will be rendered based on the URL:\n\nURL Path\tComponent\n/posts\t<Posts>\n/posts/123\t<Posts><Post postId=\"123\">\n/posts/123/edit\t<PostEditor postId=\"123\">\nThe posts.$postId.tsx route is nested as normal under the posts.tsx route and will render <Posts><Post>.\nThe posts_.$postId.edit.tsx route does not share the same posts prefix as the other routes and therefore will be treated as if it is a top-level route and will render <PostEditor>.\nExcluding Files and Folders from Routes\n\nFiles and folders can be excluded from route generation with a - prefix attached to the file name. This gives you the ability to colocate logic in the route directories.\n\nConsider the following route tree:\n\nroutes/\n‚îú‚îÄ‚îÄ posts.tsx\n‚îú‚îÄ‚îÄ -posts-table.tsx // üëàüèº ignored\n‚îú‚îÄ‚îÄ -components/ // üëàüèº ignored\n‚îÇ   ‚îú‚îÄ‚îÄ header.tsx // üëàüèº ignored\n‚îÇ   ‚îú‚îÄ‚îÄ footer.tsx // üëàüèº ignored\n‚îÇ   ‚îú‚îÄ‚îÄ ...\n\n\nWe can import from the excluded files into our posts route\n\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { PostsTable } from './-posts-table'\nimport { PostsHeader } from './-components/header'\nimport { PostsFooter } from './-components/footer'\n\nexport const Route = createFileRoute('/posts')({\n  loader: () => fetchPosts(),\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  const posts = Route.useLoaderData()\n\n  return (\n    <div>\n      <PostsHeader />\n      <PostsTable posts={posts} />\n      <PostsFooter />\n    </div>\n  )\n}\n\n\nThe excluded files will not be added to routeTree.gen.ts.\n\nPathless Route Group Directories\n\nPathless route group directories use () as a way to group routes files together regardless of their path. They are purely organizational and do not affect the route tree or component tree in any way.\n\nroutes/\n‚îú‚îÄ‚îÄ index.tsx\n‚îú‚îÄ‚îÄ (app)/\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ settings.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ users.tsx\n‚îú‚îÄ‚îÄ (auth)/\n‚îÇ   ‚îú‚îÄ‚îÄ login.tsx\n‚îÇ   ‚îú‚îÄ‚îÄ register.tsx\n\n\nIn the example above, the app and auth directories are purely organizational and do not affect the route tree or component tree in any way. They are used to group related routes together for easier navigation and organization.\n\nThe following table shows which component will be rendered based on the URL:\n\nURL Path\tComponent\n/\t<Index>\n/dashboard\t<Dashboard>\n/settings\t<Settings>\n/users\t<Users>\n/login\t<Login>\n/register\t<Register>\n\nAs you can see, the app and auth directories are purely organizational and do not affect the route tree or component tree in any way.\n\nEdit on GitHub\nFrequently Asked Questions\nRoute Trees\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Frequently Asked Questions | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/faq",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nFrequently Asked Questions\n\nWelcome to the TanStack Router FAQ! Here you'll find answers to common questions about the TanStack Router. If you have a question that isn't answered here, please feel free to ask in the TanStack Discord.\n\nShould I commit my routeTree.gen.ts file into git?\n\nYes! Although the route tree file (i.e. routeTree.gen.ts) is generated by the TanStack Router, it is essentially towards the runtime of your application. It is not a build artifact. The route tree file is a critical part of your application's source code, and it is used by the TanStack Router to build your application's routes at runtime.\n\nYou should commit this file into git so that other developers can use it to build your application.\n\nCan I conditionally render the Root Route component?\n\nNo, the root route is always rendered as it is the entry point of your application.\n\nIf you need to conditionally render a route's component, this usually means that the page content needs to be different based on some condition (e.g. user authentication). For this use case, you should use a Layout Route or a Pathless Layout Route to conditionally render the content.\n\nYou can restrict access to these routes using a conditional check in the beforeLoad function of the route.\n\nWhat does this look like?\nEdit on GitHub\nDecisions on DX\nRouting Concepts\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Decisions on Developer Experience | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/decisions-on-dx",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nDecisions on Developer Experience\n\nWhen people first start using TanStack Router, they often have a lot of questions that revolve around the following themes:\n\nWhy do I have to do things this way?\n\nWhy is it done this way? and not that way?\n\nI'm used to doing it this way, why should I change?\n\nAnd they are all valid questions. For the most part, people are used to using routing libraries that are very similar to each other. They all have a similar API, similar concepts, and similar ways of doing things.\n\nBut TanStack Router is different. It's not your average routing library. It's not your average state management library. It's not your average anything.\n\nTanStack Router's origin story\n\nIt's important to remember that TanStack Router's origins stem from Nozzle.io's need for a client-side routing solution that offered a first-in-class URL Search Parameters experience without compromising on the type-safety that was required to power its complex dashboards.\n\nAnd so, from TanStack Router's very inception, every facet of its design was meticulously thought out to ensure that its type-safety and developer experience were second to none.\n\nHow does TanStack Router achieve this?\n\nTypeScript! TypeScript! TypeScript!\n\nEvery aspect of TanStack Router is designed to be as type-safe as possible, and this is achieved by leveraging TypeScript's type system to its fullest extent. This involves using some very advanced and complex types, type inference, and other features to ensure that the developer experience is as smooth as possible.\n\nBut to achieve this, we had to make some decisions that deviate from the norms in the routing world.\n\nRoute configuration boilerplate?: You have to define your routes in a way that allows TypeScript to infer the types of your routes as much as possible.\nTypeScript module declaration for the router?: You have to pass the Router instance to the rest of your application using TypeScript's module declaration.\nWhy push for file-based routing over code-based?: We push for file-based routing as the preferred way to define your routes.\n\nTLDR; All the design decisions in the developer experience of using TanStack Router are made so that you can have a best-in-class type-safety experience without compromising on the control, flexibility, and maintainability of your route configurations.\n\n1. Why is the Router's configuration done this way?\n\nWhen you want to leverage the TypeScript's inference features to its fullest, you'll quickly realize that Generics are your best friend. And so, TanStack Router uses Generics everywhere to ensure that the types of your routes are inferred as much as possible.\n\nThis means that you have to define your routes in a way that allows TypeScript to infer the types of your routes as much as possible.\n\nCan I use JSX to define my routes?\n\nUsing JSX for defining your routes is out of the question, as TypeScript will not be able to infer the route configuration types of your router.\n\ntsx\n// ‚õîÔ∏è This is not possible\nfunction App() {\n  return (\n    <Router>\n      <Route path=\"/posts\" component={PostsPage} />\n      <Route path=\"/posts/$postId\" component={PostIdPage} />\n      {/* ... */}\n    </Router>\n    // ^? TypeScript cannot infer the routes in this configuration\n  )\n}\n\n\nAnd since this would mean that you'd have to manually type the to prop of the <Link> component and wouldn't catch any errors until runtime, it's not a viable option.\n\nMaybe I could define my routes as a tree of nested objects?\n\ntsx\n// ‚õîÔ∏è This file will just keep growing and growing...\nconst router = createRouter({\n  routes: {\n    posts: {\n      component: PostsPage, // /posts\n      children: {\n        $postId: {\n          component: PostIdPage, // /posts/$postId\n        },\n      },\n    },\n    // ...\n  },\n})\n\n\nAt first glance, this seems like a good idea. It's easy to visualize the entire route hierarchy in one go. But this approach has a couple of big downsides that make it not ideal for large applications:\n\nIt's not very scalable: As your application grows, the tree will grow and become harder to manage. And since it's all defined in one file, it can become very hard to maintain.\nIt's not great for code-splitting: You'd have to manually code-split each component and then pass it into the component property of the route, further complicating the route configuration with an ever-growing route configuration file.\n\nThis only gets worse as you begin to use more features of the router, such as nested context, loaders, search param validation, etc.\n\nSo, what's the best way to define my routes?\n\nWhat we found to be the best way to define your routes is to abstract the definition of the route configuration outside of the route-tree. Then stitch together your route configurations into a single cohesive route-tree that is then passed into the createRouter function.\n\nYou can read more about code-based routing to see how to define your routes in this way.\n\nTip\n\nFinding Code-based routing to be a bit too cumbersome? See why file-based routing is the preferred way to define your routes.\n\n2. Declaring the Router instance for type inference\n\nWhy do I have to declare the Router?\n\nThis declaration stuff is way too complicated for me...\n\nOnce you've constructed your routes into a tree and passed it into your Router instance (using createRouter) with all the generics working correctly, you then need to somehow pass this information to the rest of your application.\n\nThere were two approaches we considered for this:\n\nImports: You could import the Router instance from the file where you created it and use it directly in your components.\ntsx\nimport { router } from '@/src/app'\nexport const PostsIdLink = () => {\n  return (\n    <Link<typeof router> to=\"/posts/$postId\" params={{ postId: '123' }}>\n      Go to post 123\n    </Link>\n  )\n}\n\n\nA downside to this approach is that you'd have to import the entire Router instance into every file where you want to use it. This can lead to increased bundle sizes and can be cumbersome to manage, and only get worse as your application grows and you use more features of the router.\n\nModule declaration: You can use TypeScript's module declaration to declare the Router instance as a module that can be used for type inference anywhere in your application without having to import it.\n\nYou'll do this once in your application.\n\ntsx\n// src/app.tsx\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: typeof router\n  }\n}\n\n\nAnd then you can benefit from its auto-complete anywhere in your app without having to import it.\n\ntsx\nexport const PostsIdLink = () => {\n  return (\n    <Link\n      to=\"/posts/$postId\"\n      // ^? TypeScript will auto-complete this for you\n      params={{ postId: '123' }} // and this too!\n    >\n      Go to post 123\n    </Link>\n  )\n}\n\n\nWe went with module declaration, as it is what we found to be the most scalable and maintainable approach with the least amount of overhead and boilerplate.\n\n3. Why is file-based routing the preferred way to define routes?\n\nWhy are the docs pushing for file-based routing?\n\nI'm used to defining my routes in a single file, why should I change?\n\nSomething you'll notice (quite soon) in the TanStack Router documentation is that we push for file-based routing as the preferred method for defining your routes. This is because we've found that file-based routing is the most scalable and maintainable way to define your routes.\n\nTip\n\nBefore you continue, it's important you have a good understanding of code-based routing and file-based routing.\n\nAs mentioned in the beginning, TanStack Router was designed for complex applications that require a high degree of type-safety and maintainability. And to achieve this, the configuration of the router has been done in a precise way that allows TypeScript to infer the types of your routes as much as possible.\n\nA key difference in the set-up of a basic application with TanStack Router, is that your route configurations require a function to be provided to getParentRoute, that returns the parent route of the current route.\n\ntsx\nimport { createRoute } from '@tanstack/react-router'\nimport { postsRoute } from './postsRoute'\n\nexport const postsIndexRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '/',\n})\n\n\nAt this stage, this is done so the definition of postsIndexRoute can be aware of its location in the route tree and so that it can correctly infer the types of the context, path params, search params returned by the parent route. Incorrectly defining the getParentRoute function means that the properties of the parent route will not be correctly inferred by the child route.\n\nAs such, this is a critical part of the route configuration and a point of failure if not done correctly.\n\nBut this is only one part of setting up a basic application. TanStack Router requires all the routes (including the root route) to be stitched into a route-tree so that it may be passed into the createRouter function before declaring the Router instance on the module for type inference. This is another critical part of the route configuration and a point of failure if not done correctly.\n\nü§Ø If this route-tree were in its own file for an application with ~40-50 routes, it can easily grow up to 700+ lines.\n\ntsx\nconst routeTree = rootRoute.addChildren([\n  postsRoute.addChildren([postsIndexRoute, postsIdRoute]),\n])\n\n\nThis complexity only increases as you begin to use more features of the router, such as nested context, loaders, search param validation, etc. As such, it no longer becomes feasible to define your routes in a single file. And so, users end up building their own semi consistent way of defining their routes across multiple files. This can lead to inconsistencies and errors in the route configuration.\n\nFinally, comes the issue of code-splitting. As your application grows, you'll want to code-split your components to reduce the initial bundle size of your application. This can be a bit of a headache to manage when you're defining your routes in a single file or even across multiple files.\n\ntsx\nimport { createRoute, lazyRouteComponent } from '@tanstack/react-router'\nimport { postsRoute } from './postsRoute'\n\nexport const postsIndexRoute = createRoute({\n  getParentRoute: () => postsRoute,\n  path: '/',\n  component: lazyRouteComponent(() => import('../page-components/posts/index')),\n})\n\n\nAll of this boilerplate, no matter how essential for providing a best-in-class type-inference experience, can be a bit overwhelming and can lead to inconsistencies and errors in the route configuration.\n\n... and this example configuration is just for rendering a single codes-split route. Imagine having to do this for 40-50 routes. Now remember that you still haven't touched the context, loaders, search param validation, and other features of the router ü§ï.\n\nSo, why's file-based routing the preferred way?\n\nTanStack Router's file-based routing is designed to solve all of these issues. It allows you to define your routes in a predictable way that is easy to manage and maintain, and is scalable as your application grows.\n\nThe file-based routing approach is powered by the TanStack Router Bundler Plugin. It performs 3 essential tasks that solve the pain points in route configuration when using code-based routing:\n\nRoute configuration boilerplate: It generates the boilerplate for your route configurations.\nRoute tree stitching: It stitches together your route configurations into a single cohesive route-tree. Also in the background, it correctly updates the route configurations to define the getParentRoute function match the routes with their parent routes.\nCode-splitting: It automatically code-splits your route content components and updates the route configurations with the correct component. Additionally, at runtime, it ensures that the correct component is loaded when the route is visited.\n\nLet's take a look at how the route configuration for the previous example would look like with file-based routing.\n\ntsx\n// src/routes/posts/index.ts\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/')({\n  component: () => 'Posts index component goes here!!!',\n})\n\n\nThat's it! No need to worry about defining the getParentRoute function, stitching together the route-tree, or code-splitting your components. The TanStack Router Bundler Plugin handles all of this for you.\n\nAt no point does the TanStack Router Bundler Plugin take away your control over your route configurations. It's designed to be as flexible as possible, allowing you to define your routes in a way that suits your application whilst reducing the boilerplate and complexity of the route configuration.\n\nCheck out the guides for file-based routing and code-splitting for a more in-depth explanation of how they work in TanStack Router.\n\nEdit on GitHub\nMigrate from React Location\nFrequently Asked Questions\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Migration from React Location | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/migrate-from-react-location",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nMigration from React Location\n\nBefore you begin your journey in migrating from React Location, it's important that you have a good understanding of the Routing Concepts and Design Decisions used by TanStack Router.\n\nDifferences between React Location and TanStack Router\n\nReact Location and TanStack Router share much of same design decisions concepts, but there are some key differences that you should be aware of.\n\nReact Location uses generics to infer types for routes, while TanStack Router uses module declaration merging to infer types.\nRoute configuration in React Location is done using a single array of route definitions, while in TanStack Router, route configuration is done using a tree of route definitions starting with the root route.\nFile-based routing is the recommended way to define routes in TanStack Router, while React Location only allows you to define routes in a single file using a code-based approach.\nTanStack Router does support a code-based approach to defining routes, but it is not recommended for most use cases. You can read more about why, over here: why is file-based routing the preferred way to define routes?\nMigration guide\n\nIn this guide we'll go over the process of migrating the React Location Basic example over to TanStack Router using file-based routing, with the end goal of having the same functionality as the original example (styling and other non-routing related code will be omitted).\n\nTip\n\nTo use a code-based approach for defining your routes, you can read the code-based Routing guide.\n\nStep 1: Swap over to TanStack Router's dependencies\n\nFirst, we need to install the dependencies for TanStack Router.\n\nsh\nnpm install @tanstack/react-router @tanstack/router-devtools\n\n\nAnd remove the React Location dependencies.\n\nsh\nnpm uninstall @tanstack/react-location @tanstack/react-location-devtools\n\nStep 2: Use the file-based routing watcher\n\nIf your project uses Vite (or one of the supported bundlers), you can use the TanStack Router plugin to watch for changes in your routes files and automatically update the routes configuration.\n\nInstallation of the Vite plugin:\n\nsh\nnpm install -D @tanstack/router-plugin\n\n\nAnd add it to your vite.config.js:\n\njs\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n\nexport default defineConfig({\n  // ...\n  plugins: [TanStackRouterVite(), react()],\n})\n\n\nHowever, if your application does not use Vite, you use one of our other supported bundlers, or you can use the @tanstack/router-cli package to watch for changes in your routes files and automatically update the routes configuration.\n\nStep 3: Add the file-based configuration file to your project\n\nCreate a tsr.config.json file in the root of your project with the following content:\n\njson\n{\n  \"routesDirectory\": \"./src/routes\",\n  \"generatedRouteTree\": \"./src/routeTree.gen.ts\"\n}\n\n\nYou can find the full list of options for the tsr.config.json file here.\n\nStep 4: Create the routes directory\n\nCreate a routes directory in the src directory of your project.\n\nsh\nmkdir src/routes\n\nStep 5: Create the root route file\ntsx\n// src/routes/__root.tsx\nimport { createRootRoute, Outlet, Link } from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/router-devtools'\n\nexport const Route = createRootRoute({\n  component: () => {\n    return (\n      <>\n        <div>\n          <Link to=\"/\" activeOptions={{ exact: true }}>\n            Home\n          </Link>\n          <Link to=\"/posts\">Posts</Link>\n        </div>\n        <hr />\n        <Outlet />\n        <TanStackRouterDevtools />\n      </>\n    )\n  },\n})\n\nStep 6: Create the index route file\ntsx\n// src/routes/index.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/')({\n  component: Index,\n})\n\n\nYou will need to move any related components and logic needed for the index route from the src/index.tsx file to the src/routes/index.tsx file.\n\nStep 7: Create the posts route file\ntsx\n// src/routes/posts.tsx\nimport { createFileRoute, Link, Outlet } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts')({\n  component: Posts,\n  loader: async () => {\n    const posts = await fetchPosts()\n    return {\n      posts,\n    }\n  },\n})\n\nfunction Posts() {\n  const { posts } = Route.useLoaderData()\n  return (\n    <div>\n      <nav>\n        {posts.map((post) => (\n          <Link\n            key={post.id}\n            to={`/posts/$postId`}\n            params={{ postId: post.id }}\n          >\n            {post.title}\n          </Link>\n        ))}\n      </nav>\n      <Outlet />\n    </div>\n  )\n}\n\n\nYou will need to move any related components and logic needed for the posts route from the src/index.tsx file to the src/routes/posts.tsx file.\n\nStep 8: Create the posts index route file\ntsx\n// src/routes/posts.index.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/')({\n  component: PostsIndex,\n})\n\n\nYou will need to move any related components and logic needed for the posts index route from the src/index.tsx file to the src/routes/posts.index.tsx file.\n\nStep 9: Create the posts id route file\ntsx\n// src/routes/posts.$postId.tsx\nimport { createFileRoute } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/posts/$postId')({\n  component: PostsId,\n  loader: async ({ params: { postId } }) => {\n    const post = await fetchPost(postId)\n    return {\n      post,\n    }\n  },\n})\n\nfunction PostsId() {\n  const { post } = Route.useLoaderData()\n  // ...\n}\n\n\nYou will need to move any related components and logic needed for the posts id route from the src/index.tsx file to the src/routes/posts.$postId.tsx file.\n\nStep 10: Generate the route tree\n\nIf you are using one of the supported bundlers, the route tree will be generated automatically when you run the dev script.\n\nIf you are not using one of the supported bundlers, you can generate the route tree by running the following command:\n\nsh\nnpx tsr generate\n\nStep 11: Update the main entry file to render the Router\n\nOnce you've generated the route-tree, you can then update the src/index.tsx file to create the router instance and render it.\n\ntsx\n// src/index.tsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { createRouter, RouterProvider } from '@tanstack/react-router'\n\n// Import the generated route tree\nimport { routeTree } from './routeTree.gen'\n\n// Create a new router instance\nconst router = createRouter({ routeTree })\n\n// Register the router instance for type safety\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: typeof router\n  }\n}\n\nconst domElementId = 'root' // Assuming you have a root element with the id 'root'\n\n// Render the app\nconst rootElement = document.getElementById(domElementId)\nif (!rootElement) {\n  throw new Error(`Element with id ${domElementId} not found`)\n}\n\nReactDOM.createRoot(rootElement).render(\n  <React.StrictMode>\n    <RouterProvider router={router} />\n  </React.StrictMode>,\n)\n\nFinished!\n\nYou should now have successfully migrated your application from React Location to TanStack Router using file-based routing.\n\nReact Location also has a few more features that you might be using in your application. Here are some guides to help you migrate those features:\n\nSearch params\nData loading\nHistory types\nWildcard / Splat / Catch-all routes\nAuthenticated routes\n\nTanStack Router also has a few more features that you might want to explore:\n\nRouter Context\nPreloading\nPathless Layout Routes\nRoute masking\nSSR\n... and more!\n\nIf you are facing any issues or have any questions, feel free to ask for help in the TanStack Discord.\n\nEdit on GitHub\nMigrate from React Router\nDecisions on DX\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Migration from React Router Checklist | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/migrate-from-react-router",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nMigration from React Router Checklist\n\nIf your UI is blank, open the console, and you will probably have some errors that read something along the lines of cannot use 'useNavigate' outside of context . This means there are React Router api‚Äôs that are still imported and referenced that you need to find and remove. The easiest way to make sure you find all React Router imports is to uninstall react-router-dom and then you should get typescript errors in your files. Then you will know what to change to a @tanstack/react-router import.\n\nHere is the example repo\n\n Install Router - npm i @tanstack/react-router\n Optional: Uninstall React Router to get TypeScript errors on imports.\nAt this point I don‚Äôt know if you can do a gradual migration, but it seems likely you could have multiple router providers, not desirable.\nThe api‚Äôs between React Router and TanStack Router are very similar and could most likely be handled in a sprint cycle or two if that is your companies way of doing things.\n Create Routes for each existing React Router route we have\n Create root route\n Create router instance\n Add global module in main.tsx\n Remove any React Router (createBrowserRouter or BrowserRouter), Routes, and Route Components from main.tsx\n Optional: Refactor render function for custom setup/providers - The repo referenced above has an example - This was necessary in the case of Supertokens. Supertoken has a specific setup with React Router and a different setup with all other React implementations\n Set RouterProvider and pass it the router as the prop\n Replace all instances of React Router Link component with @tanstack/react-router Link component\n Add to prop with literal path\n Add params prop, where necessary with params like so params={{ orderId: order.id }}\n Replace all instances of React Router useNavigate hook with @tanstack/react-router useNavigate hook\n Set to property and params property where needed\n Replace any React Router Outlet's with the @tanstack/react-router equivalent\n If you are using useSearchParams hook from React Router, move the search params default value to the validateSearch property on a Route definition.\n Instead of using the useSearchParams hook, use @tanstack/react-router Link's search property to update the search params state\n To read search params you can do something like the following\nconst { page } = useSearch({ from: productPage.fullPath })\n If using React Router‚Äôs useParams hook, update the import to be from @tanstack/react-router and set the from property to the literal path name where you want to read the params object from\nSo say we have a route with the path name orders/$orderid.\nIn the useParams hook we would set up our hook like so: const params = useParams({ from: \"/orders/$orderId\" })\nThen wherever we wanted to access the order id we would get it off of the params object params.orderId\nEdit on GitHub\nComparison\nMigrate from React Location\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Devtools | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/devtools",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nDevtools\n\nLink, take this sword... I mean Devtools!... to help you on your way!\n\nWave your hands in the air and shout hooray because TanStack Router comes with dedicated devtools! ü•≥\n\nWhen you begin your TanStack Router journey, you'll want these devtools by your side. They help visualize all of the inner workings of TanStack Router and will likely save you hours of debugging if you find yourself in a pinch!\n\nInstallation\n\nThe devtools are a separate package that you need to install:\n\nsh\nnpm install @tanstack/react-router-devtools\n\n\nor\n\nsh\npnpm add @tanstack/react-router-devtools\n\n\nor\n\nsh\nyarn add @tanstack/react-router-devtools\n\n\nor\n\nsh\nbun add @tanstack/react-router-devtools\n\nImport the Devtools\njs\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\n\nUsing Devtools in production\n\nThe Devtools, if imported as TanStackRouterDevtools will not be shown in production. If you want to have devtools in an environment with process.env.NODE_ENV === 'production', use instead TanStackRouterDevtoolsInProd, which has all the same options:\n\ntsx\nimport { TanStackRouterDevtoolsInProd } from '@tanstack/react-router-devtools'\n\nUsing inside of the RouterProvider\n\nThe easiest way for the devtools to work is to render them inside of your root route (or any other route). This will automatically connect the devtools to the router instance.\n\ntsx\nconst rootRoute = createRootRoute({\n  component: () => (\n    <>\n      <Outlet />\n      <TanStackRouterDevtools />\n    </>\n  ),\n})\n\nconst routeTree = rootRoute.addChildren([\n  // ... other routes\n])\n\nconst router = createRouter({\n  routeTree,\n})\n\nfunction App() {\n  return <RouterProvider router={router} />\n}\n\nManually passing the Router Instance\n\nIf rendering the devtools inside of the RouterProvider isn't your cup of tea, a router prop for the devtools accepts the same router instance you pass to the Router component. This makes it possible to place the devtools anywhere on the page, not just inside the provider:\n\ntsx\nfunction App() {\n  return (\n    <>\n      <RouterProvider router={router} />\n      <TanStackRouterDevtools router={router} />\n    </>\n  )\n}\n\nFloating Mode\n\nFloating Mode will mount the devtools as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.\n\nPlace the following code as high in your React app as you can. The closer it is to the root of the page, the better it will work!\n\njs\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\n\nfunction App() {\n  return (\n    <>\n      <Router />\n      <TanStackRouterDevtools initialIsOpen={false} />\n    </>\n  )\n}\n\nFixed Mode\n\nTo control the position of the devtools, import the TanStackRouterDevtoolsPanel:\n\njs\nimport { TanStackRouterDevtoolsPanel } from '@tanstack/react-router-devtools'\n\n\nIt can then be attached to provided shadow DOM target:\n\njs\n<TanStackRouterDevtoolsPanel\n  shadowDOMTarget={shadowContainer}\n  router={router}\n/>\n\n\nClick here to see a live example of this in StackBlitz.\n\nOptions\nrouter: Router\nThe router instance to connect to\ninitialIsOpen: Boolean\nSet this true if you want the devtools to default to being open\npanelProps: PropsObject\nUse this to add props to the panel. For example, you can add className, style (merge and override default style), etc.\ncloseButtonProps: PropsObject\nUse this to add props to the close button. For example, you can add className, style (merge and override default style), onClick (extend default handler), etc.\ntoggleButtonProps: PropsObject\nUse this to add props to the toggle button. For example, you can add className, style (merge and override default style), onClick (extend default handler), etc.\nposition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\nDefaults to bottom-left\nThe position of the TanStack Router logo to open and close the devtools panel\nshadowDOMTarget?: ShadowRoot\nSpecifies a Shadow DOM target for the devtools.\nBy default, devtool styles are applied to the <head> tag of the main document (light DOM). When a shadowDOMTarget is provided, styles will be applied within this Shadow DOM instead.\nEmbedded Mode\n\nEmbedded Mode will embed the devtools as a regular component in your application. You can style it however you'd like after that!\n\njs\nimport { TanStackRouterDevtoolsPanel } from '@tanstack/react-router-devtools'\n\nfunction App() {\n  return (\n    <>\n      <Router router={router} />\n      <TanStackRouterDevtoolsPanel\n        router={router}\n        style={styles}\n        className={className}\n      />\n    </>\n  )\n}\n\nOptions\n\nUse these options to style the devtools.\n\nstyle: StyleObject\nThe standard React style object used to style a component with inline styles\nclassName: string\nThe standard React className property used to style a component with classes\nEdit on GitHub\nQuick Start\nComparison\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Comparison | TanStack Router & TanStack Start vs Next.js vs React Router / Remix | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/comparison",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nComparison | TanStack Router & TanStack Start vs Next.js vs React Router / Remix\n\nBefore you commit to a new tool, it's always nice to know how it stacks up against the competition!\n\nThis comparison table strives to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes (with notes or evidence of claims) using the \"Edit this page on GitHub\" link at the bottom of this page.\n\nFeature/Capability Key:\n\n‚úÖ 1st-class, built-in, and ready to use with no added configuration or code\nüü° Partial Support (on a scale of 5)\nüü† Supported via addon/community package\nüî∂ Possible, but requires custom code/implementation/casting\nüõë Not officially supported\n\tTanStack Router / Start\tReact Router DOM (Website)\tNext.JS (Website)\nGithub Repo / Stars\t\n\t\n\t\n\nBundle Size\t\n\t\n\t‚ùì\nHistory, Memory & Hash Routers\t‚úÖ\t‚úÖ\tüõë\nNested / Layout Routes\t‚úÖ\t‚úÖ\tüü°\nSuspense-like Route Transitions\t‚úÖ\t‚úÖ\t‚úÖ\nTypesafe Routes\t‚úÖ\tüü° (1/5)\tüü°\nCode-based Routes\t‚úÖ\t‚úÖ\tüõë\nFile-based Routes\t‚úÖ\t‚úÖ\t‚úÖ\nVirtual/Programmatic File-based Routes\t‚úÖ\t‚úÖ\tüõë\nRouter Loaders\t‚úÖ\t‚úÖ\t‚úÖ\nSWR Loader Caching\t‚úÖ\tüõë\t‚úÖ\nRoute Prefetching\t‚úÖ\t‚úÖ\t‚úÖ\nAuto Route Prefetching\t‚úÖ\t‚úÖ\t‚úÖ\nRoute Prefetching Delay\t‚úÖ\tüî∂\tüõë\nPath Params\t‚úÖ\t‚úÖ\t‚úÖ\nTypesafe Path Params\t‚úÖ\t‚úÖ\tüõë\nTypesafe Route Context\t‚úÖ\tüõë\tüõë\nPath Param Validation\t‚úÖ\tüõë\tüõë\nCustom Path Param Parsing/Serialization\t‚úÖ\tüõë\tüõë\nRanked Routes\t‚úÖ\t‚úÖ\t‚úÖ\nActive Link Customization\t‚úÖ\t‚úÖ\t‚úÖ\nOptimistic UI\t‚úÖ\t‚úÖ\tüî∂\nTypesafe Absolute + Relative Navigation\t‚úÖ\tüü° (1/5 via buildHref util)\tüü† (IDE plugin)\nRoute Mount/Transition/Unmount Events\t‚úÖ\tüõë\tüõë\nDevtools\t‚úÖ\tüü†\tüõë\nBasic Search Params\t‚úÖ\t‚úÖ\t‚úÖ\nSearch Param Hooks\t‚úÖ\t‚úÖ\t‚úÖ\n<Link/>/useNavigate Search Param API\t‚úÖ\tüü° (search-string only via the to/search options)\tüü° (search-string only via the to/search options)\nJSON Search Params\t‚úÖ\tüî∂\tüî∂\nTypeSafe Search Params\t‚úÖ\tüõë\tüõë\nSearch Param Schema Validation\t‚úÖ\tüõë\tüõë\nSearch Param Immutability + Structural Sharing\t‚úÖ\tüî∂\tüõë\nCustom Search Param parsing/serialization\t‚úÖ\tüî∂\tüõë\nSearch Param Middleware\t‚úÖ\tüõë\tüõë\nSuspense Route Elements\t‚úÖ\t‚úÖ\t‚úÖ\nRoute Error Elements\t‚úÖ\t‚úÖ\t‚úÖ\nRoute Pending Elements\t‚úÖ\t‚úÖ\t‚úÖ\n<Block>/useBlocker\t‚úÖ\tüî∂ (no hard reloads or cross-origin navigation)\tüõë\nDeferred Primitives\t‚úÖ\t‚úÖ\t‚úÖ\nNavigation Scroll Restoration\t‚úÖ\t‚úÖ\t‚ùì\nElementScroll Restoration\t‚úÖ\tüõë\tüõë\nAsync Scroll Restoration\t‚úÖ\tüõë\tüõë\nRouter Invalidation\t‚úÖ\t‚úÖ\t‚úÖ\nRuntime Route Manipulation (Fog of War)\tüõë\t‚úÖ\t‚úÖ\nParallel Routes\tüõë\tüõë\t‚úÖ\n--\t--\t--\t--\nFull Stack\t--\t--\t--\nSSR\t‚úÖ\t‚úÖ\t‚úÖ\nStreaming SSR\t‚úÖ\t‚úÖ\t‚úÖ\nGeneric RPCs\t‚úÖ\tüõë\tüõë\nGeneric RPC Middleware\t‚úÖ\tüõë\tüõë\nReact Server Functions\t‚úÖ\tüõë\t‚úÖ\nReact Server Function Middleware\t‚úÖ\tüõë\tüõë\nAPI Routes\t‚úÖ\t‚úÖ\t‚úÖ\nAPI Middleware\t‚úÖ\tüõë\t‚úÖ\nReact Server Components\tüõë\tüü° (Experimental)\t‚úÖ\n<Form> API\tüõë\t‚úÖ\t‚úÖ\nEdit on GitHub\nDevtools\nMigrate from React Router\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Installation | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/installation",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nInstallation\n\nYou can install TanStack Router with any NPM package manager.\n\nsh\nnpm install @tanstack/react-router\n# or\npnpm add @tanstack/react-router\n# or\nyarn add @tanstack/react-router\n# or\nbun add @tanstack/react-router\n# or\ndeno add npm:@tanstack/react-router\n\n\nTanStack Router is currently only compatible with React (with ReactDOM) and Solid. If you would like to contribute to the React Native, Angular, or Vue adapter, please reach out to us on Discord.\n\nRequirements\nreact either v18.x.x or v19.x.x\nreact-dom, either v18.x.x or v19.x.x\nNote that ReactDOM.createRoot is required.\nThe legacy .render() function is not supported.\n\nTypeScript is optional, but HIGHLY recommended! If you are using it, please ensure you are using typescript>=v5.3.x.\n\nImportant\n\nWe aim to support the last five minor versions of TypeScript. If you are using an older version, you may run into issues. Please upgrade to the latest version of TypeScript to ensure compatibility. We may drop support for older versions of TypeScript, outside of the range mentioned above, without warning in a minor or patch release.\n\nEdit on GitHub\nOverview\nQuick Start\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Quick Start | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/quick-start",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nQuick Start\n\nIf you're feeling impatient and prefer to skip all of our wonderful documentation, here is the bare minimum to get going with TanStack Router using both file-based route generation and code-based route configuration:\n\nUsing File-Based Route Generation\n\nFile based route generation (through Vite, and other supported bundlers) is the recommended way to use TanStack Router as it provides the best experience, performance, and ergonomics for the least amount of effort.\n\nScaffolding Your First TanStack Router Project\nsh\nnpx create-tsrouter-app@latest my-app --template file-router\n\n\nSee create-tsrouter-app for more options.\n\nManual Setup\n\nAlternatively, you can manually setup the project using the following steps:\n\nInstall TanStack Router, Vite Plugin, and the Router Devtools\nsh\nnpm install @tanstack/react-router @tanstack/react-router-devtools\nnpm install -D @tanstack/router-plugin\n# or\npnpm add @tanstack/react-router @tanstack/react-router-devtools\npnpm add -D @tanstack/router-plugin\n# or\nyarn add @tanstack/react-router @tanstack/react-router-devtools\nyarn add -D @tanstack/router-plugin\n# or\nbun add @tanstack/react-router @tanstack/react-router-devtools\nbun add -D @tanstack/router-plugin\n# or\ndeno add npm:@tanstack/react-router npm:@tanstack/router-plugin npm:@tanstack/react-router-devtools\n\nConfigure the Vite Plugin\ntsx\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { TanStackRouterVite } from '@tanstack/router-plugin/vite'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    // Please make sure that '@tanstack/router-plugin' is passed before '@vitejs/plugin-react'\n    TanStackRouterVite({ target: 'react', autoCodeSplitting: true }),\n    react(),\n    // ...,\n  ],\n})\n\n\nTip\n\nIf you are not using Vite, or any of the supported bundlers, you can check out the TanStack Router CLI guide for more info.\n\nCreate the following files:\n\nsrc/routes/__root.tsx (with two '_' characters)\nsrc/routes/index.tsx\nsrc/routes/about.tsx\nsrc/main.tsx\nsrc/routes/__root.tsx\ntsx\nimport { createRootRoute, Link, Outlet } from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\n\nexport const Route = createRootRoute({\n  component: () => (\n    <>\n      <div className=\"p-2 flex gap-2\">\n        <Link to=\"/\" className=\"[&.active]:font-bold\">\n          Home\n        </Link>{' '}\n        <Link to=\"/about\" className=\"[&.active]:font-bold\">\n          About\n        </Link>\n      </div>\n      <hr />\n      <Outlet />\n      <TanStackRouterDevtools />\n    </>\n  ),\n})\n\nsrc/routes/index.tsx\ntsx\nimport { createLazyFileRoute } from '@tanstack/react-router'\n\nexport const Route = createLazyFileRoute('/')({\n  component: Index,\n})\n\nfunction Index() {\n  return (\n    <div className=\"p-2\">\n      <h3>Welcome Home!</h3>\n    </div>\n  )\n}\n\nsrc/routes/about.tsx\ntsx\nimport { createLazyFileRoute } from '@tanstack/react-router'\n\nexport const Route = createLazyFileRoute('/about')({\n  component: About,\n})\n\nfunction About() {\n  return <div className=\"p-2\">Hello from About!</div>\n}\n\nsrc/main.tsx\n\nRegardless of whether you are using the @tanstack/router-plugin package and running the npm run dev/npm run build scripts, or manually running the tsr watch/tsr generate commands from your package scripts, the route tree file will be generated at src/routeTree.gen.ts.\n\nImport the generated route tree and create a new router instance:\n\ntsx\nimport { StrictMode } from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { RouterProvider, createRouter } from '@tanstack/react-router'\n\n// Import the generated route tree\nimport { routeTree } from './routeTree.gen'\n\n// Create a new router instance\nconst router = createRouter({ routeTree })\n\n// Register the router instance for type safety\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: typeof router\n  }\n}\n\n// Render the app\nconst rootElement = document.getElementById('root')!\nif (!rootElement.innerHTML) {\n  const root = ReactDOM.createRoot(rootElement)\n  root.render(\n    <StrictMode>\n      <RouterProvider router={router} />\n    </StrictMode>,\n  )\n}\n\n\nIf you are working with this pattern you should change the id of the root <div> on your index.html file to <div id='root'></div>\n\nUsing Code-Based Route Configuration\n\nImportant\n\nThe following example shows how to configure routes using code, and for simplicity's sake is in a single file for this demo. While code-based generation allows you to declare many routes and even the router instance in a single file, we recommend splitting your routes into separate files for better organization and performance as your application grows.\n\ntsx\nimport { StrictMode } from 'react'\nimport ReactDOM from 'react-dom/client'\nimport {\n  Outlet,\n  RouterProvider,\n  Link,\n  createRouter,\n  createRoute,\n  createRootRoute,\n} from '@tanstack/react-router'\nimport { TanStackRouterDevtools } from '@tanstack/react-router-devtools'\n\nconst rootRoute = createRootRoute({\n  component: () => (\n    <>\n      <div className=\"p-2 flex gap-2\">\n        <Link to=\"/\" className=\"[&.active]:font-bold\">\n          Home\n        </Link>{' '}\n        <Link to=\"/about\" className=\"[&.active]:font-bold\">\n          About\n        </Link>\n      </div>\n      <hr />\n      <Outlet />\n      <TanStackRouterDevtools />\n    </>\n  ),\n})\n\nconst indexRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/',\n  component: function Index() {\n    return (\n      <div className=\"p-2\">\n        <h3>Welcome Home!</h3>\n      </div>\n    )\n  },\n})\n\nconst aboutRoute = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '/about',\n  component: function About() {\n    return <div className=\"p-2\">Hello from About!</div>\n  },\n})\n\nconst routeTree = rootRoute.addChildren([indexRoute, aboutRoute])\n\nconst router = createRouter({ routeTree })\n\ndeclare module '@tanstack/react-router' {\n  interface Register {\n    router: typeof router\n  }\n}\n\nconst rootElement = document.getElementById('app')!\nif (!rootElement.innerHTML) {\n  const root = ReactDOM.createRoot(rootElement)\n  root.render(\n    <StrictMode>\n      <RouterProvider router={router} />\n    </StrictMode>,\n  )\n}\n\n\nIf you glossed over these examples or didn't understand something, we don't blame you, because there's so much more to learn to really take advantage of TanStack Router! Let's move on.\n\nEdit on GitHub\nInstallation\nDevtools\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nROUTER\nA powerful React router for client-side and full-stack react applications. Fully type-safe APIs, first-class search-params for managing state in the URL and seamless integration with the existing React ecosystem.\nLEARN MORE\nTANSTACK\nRANGER\nHeadless, lightweight, and extensible primitives for building range and multi-range sliders.\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  },
  {
    "title": "Overview | TanStack Router React Docs",
    "url": "https://tanstack.com/router/latest/docs/framework/react/overview",
    "html": "TanStack\nRouter v1\nAUTO\nSearch...\n+ K\nFRAMEWORK\nReact\nVERSION\nLatest\nMENU\nHome\nFrameworks\nGitHub\nDiscord\nGETTING STARTED\nOverview\nreact\nInstallation\nreact\nQuick Start\nreact\nDevtools\nreact\nComparison\nreact\nMigrate from React Router\nreact\nMigrate from React Location\nreact\nDecisions on DX\nreact\nFrequently Asked Questions\nreact\nROUTING\nRouting Concepts\nreact\nRoute Trees\nreact\nRoute Matching\nreact\nFile-Based Routing\nreact\nVirtual File Routes\nreact\nCode-Based Routing\nreact\nInstallation with Vite\nreact\nInstallation with Rspack/Rsbuild\nreact\nInstallation with Webpack\nreact\nInstallation with Esbuild\nreact\nInstallation with the Router CLI\nreact\nFile Naming Conventions\nreact\nGUIDES\nCode Splitting\nreact\nAutomatic Code Splitting\nreact\nCreating a Router\nreact\nOutlets\nreact\nNavigation\nreact\nPath Params\nreact\nSearch Params\nreact\nLink Options\nreact\nCustom Links\nreact\nData Loading\nreact\nDeferred Data Loading\nreact\nExternal Data Loading\nreact\nData Mutations\nreact\nType Safety\nreact\nType Utilities\nreact\nPreloading\nreact\nDocument Head Management\nreact\nRoute Masking\nreact\nNavigation Blocking\nreact\nCustom Search Param Serialization\nreact\nHistory Types\nreact\nRouter Context\nreact\nNot Found Errors\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nStatic Route Data\nreact\nSSR\nreact\nRender Optimizations\nreact\nAPI\nFile-Based Routing\ncore\nRouter\nreact\nESLINT\nESLint Plugin Router\ncore\nCreate Route Property Order\ncore\nROUTER EXAMPLES\nQuickstart (file-based)\nreact\nQuickstart (code-based)\nreact\nBasic (file-based)\nreact\nBasic (code-based)\nreact\nBasic + React Query (file-based)\nreact\nBasic + React Query (code-based)\nreact\nBasic + SSR (file-based)\nreact\nBasic + SSR Streaming (file-based)\nreact\nKitchen Sink (file-based)\nreact\nKitchen Sink (code-based)\nreact\nKitchen Sink + React Query (file-based)\nreact\nKitchen Sink + React Query (code-based)\nreact\nLocation Masking\nreact\nAuthenticated Routes\nreact\nScroll Restoration\nreact\nDeferred Data\nreact\nNavigation Blocking\nreact\nView Transitions\nreact\nWith tRPC\nreact\nWith tRPC + React Query\nreact\nMonorepo basic\nreact\nMonorepo basic (with lazy loading)\nreact\nMonorepo with React Query\nreact\nOverview\n\nTanStack Router is a router for building React and Solid applications. Some of its features include:\n\n100% inferred TypeScript support\nTypesafe navigation\nNested Routing and layout routes (with pathless layouts)\nBuilt-in Route Loaders w/ SWR Caching\nDesigned for client-side data caches (TanStack Query, SWR, etc.)\nAutomatic route prefetching\nAsynchronous route elements and error boundaries\nFile-based Route Generation\nTypesafe JSON-first Search Params state management APIs\nPath and Search Parameter Schema Validation\nSearch Param Navigation APIs\nCustom Search Param parser/serializer support\nSearch param middleware\nRoute matching/loading middleware\n\nTo get started quickly, head to the next page. For a more lengthy explanation, buckle up while I bring you up to speed!\n\n\"A Fork in the Route\"\n\nUsing a router to build applications is widely regarded as a must-have and is usually one of the first choices you‚Äôll make in your tech stack.\n\nSo, why should you choose TanStack Router over another router?\n\nTo answer this question, we need to look at the other options in the space. There are many if you look hard enough, but in my experience, only a couple are worth exploring seriously:\n\nNext.js - Widely regarded as the de facto framework for starting a new React project, it‚Äôs laser focused on performance, workflow, and bleeding edge technology. Its APIs and abstractions are powerful, but can sometimes come across as non-standard. Its extremely fast growth and adoption in the industry has resulted in a featured packed experience, but not at the expense of feeling overwhelming and sometimes bloated.\nRemix / React Router - A full-stack framework based on the historically successful React Router offers a similarly powerful developer and user experience, with APIs and vision based firmly on web standards like Request/Response and a focus on running anywhere JS can run. Many of its APIs and abstractions are wonderfully designed and were inspiration for more than a few TanStack Router APIs. That said, its rigid design, bolted-on type safety and sometimes strict over-adherence to platform APIs can leave some developers wanting more.\n\nBoth of these frameworks (and their routers) are great, and I can personally attest that both are very good solutions for building React applications. My experience has also taught me that these solutions could also be much better, especially around the actual routing APIs that are available to developers to make their apps faster, easier, and more enjoyable to work with.\n\nIt's probably no surprise at this point that picking a router is so important that it is often tied 1-to-1 with your choice of framework, since most frameworks rely on a specific router.\n\nDoes this mean that TanStack Router is a framework?\n\nTanStack Router itself is not a \"framework\" in the traditional sense, since it doesn't address a few other common full-stack concerns. However TanStack Router has been designed to be upgradable to a full-stack framework when used in conjunction with other tools that address bundling, deployments, and server-side-specific functionality. This is why we are currently developing TanStack Start, a full-stack framework that is built on top of TanStack Router and tools like Nitro, and Vite.\n\nFor a deeper dive on the history of TanStack Router, feel free to read TanStack Router's History.\n\nWhy TanStack Router?\n\nTanStack Router delivers on the same fundamental expectations as other routers that you‚Äôve come to expect:\n\nNested routes, layout routes, grouped routes\nFile-based Routing\nParallel data loading\nPrefetching\nURL Path Params\nError Boundaries and Handling\nSSR\nRoute Masking\n\nAnd it also delivers some new features that raise the bar:\n\n100% inferred TypeScript support\nTypesafe navigation\nBuilt-in SWR Caching for loaders\nDesigned for client-side data caches (TanStack Query, SWR, etc.)\nTypesafe JSON-first Search Params state management APIs\nPath and Search Parameter Schema Validation\nSearch Parameter Navigation APIs\nCustom Search Param parser/serializer support\nSearch param middleware\nInherited Route Context\nMixed file-based and code-based routing\n\nLet‚Äôs dive into some of the more important ones in more detail!\n\n100% Inferred TypeScript Support\n\nEverything these days is written ‚Äúin Typescript‚Äù or at the very least offers type definitions that are veneered over runtime functionality, but too few packages in the ecosystem actually design their APIs with TypeScript in mind. So while I‚Äôm pleased that your router is auto-completing your option fields and catching a few property/method typos here and there, there is much more to be had.\n\nTanStack Router is fully aware of all of your routes and their configuration at any given point in your code. This includes the path, path params, search params, context, and any other configuration you‚Äôve provided. Ultimately this means that you can navigate to any route in your app with 100% type safety and confidence that your link or navigate call will succeed.\nTanStack Router provides lossless type-inference. It uses countless generic type parameters to enforce and propagate any type information you give it throughout the rest of its API and ultimately your app. No other router offers this level of type safety and developer confidence.\n\nWhat does all of that mean for you?\n\nFaster feature development with auto-completion and type hints\nSafer and faster refactors\nConfidence that your code will work as expected\n1st Class Search Parameters\n\nSearch parameters are often an afterthought, treated like a black box of strings (or string) that you can parse and update, but not much else. Existing solutions are not type-safe either, adding to the caution that is required to deal with them. Even the most \"modern\" frameworks and routers and leave it up to you to figure out how to manage this state. Sometimes they'll parse the search string into an object for you, or sometimes you're left to do it yourself with URLSearchParams.\n\nLet's step back and remember that search params are the most powerful state manager in your entire application. They are global, serializable, bookmarkable, and shareable making them the perfect place to store any kind of state that needs to survive a page refresh or a social share.\n\nTo live up to that responsibility, search parameters are a first-class citizen in TanStack Router. While still based on standard URLSearchParams, TanStack Router uses a powerful parser/serializer to manage deeper and more complex data structures in your search params, all while keeping them type-safe and easy to work with.\n\nIt's like having useState right in the URL!\n\nSearch parameters are:\n\nAutomatically parsed and serialized as JSON\nValidated and typed\nInherited from parent routes\nAccessible in loaders, components, and hooks\nEasily modified with the useSearch hook, Link, navigate, and router.navigate APIs\nCustomizable with a custom search filters and middleware\nSubscribed via fine-grained search param selectors for efficient re-renders\n\nOnce you start using TanStack Router's search parameters, you'll wonder how you ever lived without them.\n\nBuilt-In Caching and Friendly Data Loading\n\nData loading is a critical part of any application and while most existing routers offer some form of critical data loading APIs, they often fall short when it comes to caching and data lifecycle management. Existing solutions suffer from a few common problems:\n\nNo caching at all. Data is always fresh, but your users are left waiting for frequently accessed data to load over and over again.\nOverly-aggressive caching. Data is cached for too long, leading to stale data and a poor user experience.\nBlunt invalidation strategies and APIs. Data may be invalidated too often, leading to unnecessary network requests and wasted resources, or you may not have any fine-grained control over when data is invalidated at all.\n\nTanStack Router solves these problems with a two-prong approach to caching and data loading:\n\nBuilt-in Cache\n\nTanStack Router provides a light-weight built-in caching layer that works seamlessly with the Router. This caching layer is loosely based on TanStack Query, but with fewer features and a much smaller API surface area. Like TanStack Query, sane but powerful defaults guarantee that your data is cached for reuse, invalidated when necessary, and garbage collected when not in use. It also provides a simple API for invalidating the cache manually when needed.\n\nFlexible & Powerful Data Lifecycle APIs\n\nTanStack Router is designed with a flexible and powerful data loading API that more easily integrates with existing data fetching libraries like TanStack Query, SWR, Apollo, Relay, or even your own custom data fetching solution. Configurable APIs like context, beforeLoad, loaderDeps and loader work in unison to make it easy to define declarative data dependencies, prefetch data, and manage the lifecycle of an external data source with ease.\n\nInherited Route Context\n\nTanStack Router's router and route context is a powerful feature that allows you to define context that is specific to a route which is then inherited by all child routes. Even the router and root routes themselves can provide context. Context can be built up both synchronously and asynchronously, and can be used to share data, configuration, or even functions between routes and route configurations. This is especially useful for scenarios like:\n\nAuthentication and Authorization\nHybrid SSR/CSR data fetching and preloading\nTheming\nSingletons and global utilities\nCurried or partial application across preloading, loading, and rendering stages\n\nAlso, what would route context be if it weren't type-safe? TanStack Router's route context is fully type-safe and inferred at zero cost to you.\n\nFile-based and/or Code-Based Routing\n\nTanStack Router supports both file-based and code-based routing at the same time. This flexibility allows you to choose the approach that best fits your project's needs.\n\nTanStack Router's file-based routing approach is uniquely user-facing. Route configuration is generated for you either by the Vite plugin or TanStack Router CLI, leaving the usage of said generated code up to you! This means that you're always in total control of your routes and router, even if you use file-based routing.\n\nAcknowledgements\n\nTanStack Router builds on concepts and patterns popularized by many other OSS projects, including:\n\nTRPC\nRemix\nChicane\nNext.js\n\nWe acknowledge the investment, risk and research that went into their development, but are excited to push the bar they have set even higher.\n\nLet's go!\n\nEnough overview, there's so much more to do with TanStack Router. Hit that next button and let's get started!\n\nEdit on GitHub\nDiscord\nInstallation\nOUR PARTNERS\nOFFICIAL DEPLOYMENT PARTNER\nTANSTACK\nQUERY\nPowerful asynchronous state management, server-state utilities and data fetching. Fetch, cache, update, and wrangle all forms of async data in your TS/JS, React, Vue, Solid, Svelte & Angular applications all without touching any \"global state\"\nLEARN MORE\nTANSTACK\nDB\nTanStack DB extends TanStack Query with collections, live queries and optimistic mutations that keep your UI reactive, consistent and blazing fast üî•\nLEARN MORE\nSUBSCRIBE TO BYTES\n\nYour weekly dose of JavaScript news. Delivered every Monday to over 100,000 devs, for free.\n\nSubscribe\n\nNo spam. Unsubscribe at any time."
  }
]