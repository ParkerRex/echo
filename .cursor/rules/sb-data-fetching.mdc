---
description: Guidelines for writing queries with Supabase
globs: 
alwaysApply: false
---
---
description: Guidelines for Supabase data fetching (server & client).
globs: supabase/queries/**/*.ts, src/app/**/{page,layout}.tsx, src/components/**/*.tsx
alwaysApply: true
---

- **Purpose:** Standardize how data is fetched from Supabase, covering both server components/dedicated functions and client components.
- **Location:**
    - Server-side fetching functions: `supabase/queries/`.
    - Client-side fetching: Directly within client components (marked with `"use client"`) or custom hooks.

- **Function Structure (Server-Side Queries):**
    - **Naming:** Use descriptive names prefixed with `get` (e.g., `getUserProfile`, `getActivePosts`).
    - **Signature:** Functions must be `async`.
    - **Return Type:** Clearly define the expected return type (e.g., `Promise<Type[]>`, `Promise<Type | null>`). Leverage generated Supabase types.

- **Supabase Client:**
    - **Server-Side:** Always import and use the server client `createClient` from `@@supabase/clients/server`.
    - **Client-Side:** Always import and use the client singleton `supabase` from `@@supabase/clients/client`.

    ```typescript
    // ✅ DO: Import the correct client based on context

    // Server-Side (e.g., in supabase/queries/ or Server Components)
    import { createClient } from "@/supabase/clients/server";
    const supabase = await createClient(); // Call createClient to get instance

    // Client-Side (e.g., in "use client" components or hooks)
    import supabase from "@/supabase/clients/client";
    // supabase is the singleton instance, ready to use
    ```

- **Type Safety:**
    - Import the main `Database` type from `@/supabase/types`.
    - Define specific row types using `Database["public"]["Tables"]["table_name"]["Row"]`.

    ```typescript
    // ✅ DO: Define speciftype { Database } from "@/supabase/types";
    type PromptType = Database["public"]["Tables"]["prompt_types"]["Row"];
    ```

- **Fetching Data:**
    - Use `supabase.from('table_name').select('columns')` for queries.
    - Apply filters (`.eq()`, `.neq()`, etc.) and ordering (`.order()`) as needed.
    - Use `.single()` or `.maybeSingle()` when expecting one or zero rows.

    **Server-Side Example (@get-prompt-types.ts):**
    ```typescript
    // In supabase/queries/get-prompt-types.ts
    import { createClient } from "@/supabase/clients/server";
    import type { Database } from "@/supabase/types";
    import log from "@/utils/logger";

    export type PromptType = Database["public"]["Tables"]["prompt_types"]["Row"];

    export async function getPromptTypes(): Promise<PromptType[]> {
      const supabase = await createClient(); // Get server client instance
      const { data, error } = await supabase
        .from("prompt_types")
        .select("*")
        .order("name", { ascending: true });
      // ... error handling and return ...
      if (error) {
        log.error("Error fetching prompt types:", error);
        throw new Error("Failed to fetch prompt types");
      }
      return data || [];
    }
    ```

    **Client-Side Example (Inside a React Component):**
    ```typescript
    // In src/components/PromptTypeList.tsx
    "use client";

    import { useState, useEffect } from "react";
    import supabase from "@/supabase/clients/client"; // Import client singleton
    import type { Database } from "@/supabase/types";
    import log from "@/utils/logger"; // Client-side safe logger if needed

    type PromptType = Database["public"]["Tables"]["prompt_types"]["Row"];

    export function PromptTypeList() {
      const [promptTypes, setPromptTypes] = useState<PromptType[]>([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);

      useEffect(() => {
        async function fetchPromptTypes() {
          setLoading(true);
          setError(null);
          const { data, error: fetchError } = await supabase // Use client singleton
            .from("prompt_types")
            .select("*")
            .order("name", { ascending: true });

          if (fetchError) {
            log.error("Client Error fetching prompt types:", fetchError);
            setError("Failed to load prompt types.");
            setPromptTypes([]);
          } else {
            setPromptTypes(data || []);
          }
          setLoading(false);
        }

        fetchPromptTypes();
      }, []); // Fetch on mount

      if (loading) return <p>Loading...</p>;
      if (error) return <p>Error: {error}</p>;

      return (
        <ul>
          {promptTypes.map((type) => (
            <li key={type.id}>{type.name}</li>
          ))}
        </ul>
      );
    }

    ```

- **Error Handling:**
    - **Server-Side:** Check `error`, log using server-safe `log` utility, and `throw new Error`.
    - **Client-Side:** Check `error`, update component state (`setError`), potentially log to console or a client-side logging service. Avoid throwing errors that crash the component unless handled by an Error Boundary.

- **Return Value / State Update:**
    - **Server-Side:** Return `data` directly (or handle `null`).
    - **Client-Side:** Update component state (`setPromptTypes(data || [])`) to trigger re-renders.